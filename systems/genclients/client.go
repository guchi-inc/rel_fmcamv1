// Code generated by ent, DO NOT EDIT.

package genclients

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"fmcam/systems/genclients/migrate"

	"fmcam/systems/genclients/alerts"
	"fmcam/systems/genclients/apikeys"
	"fmcam/systems/genclients/capturelogs"
	"fmcam/systems/genclients/devices"
	"fmcam/systems/genclients/faces"
	"fmcam/systems/genclients/fieldmetadata"
	"fmcam/systems/genclients/fmalertdefinition"
	"fmcam/systems/genclients/fmalertgroup"
	"fmcam/systems/genclients/fmdedicatedservices"
	"fmcam/systems/genclients/fmdemands"
	"fmcam/systems/genclients/fmpmsapi"
	"fmcam/systems/genclients/fmuseraccount"
	"fmcam/systems/genclients/govarea"
	"fmcam/systems/genclients/govcity"
	"fmcam/systems/genclients/govstreet"
	"fmcam/systems/genclients/grouprofiletypemapping"
	"fmcam/systems/genclients/profiles"
	"fmcam/systems/genclients/profiletype"
	"fmcam/systems/genclients/province"
	"fmcam/systems/genclients/sqllog"
	"fmcam/systems/genclients/temporaryface"
	"fmcam/systems/genclients/tenants"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Alerts is the client for interacting with the Alerts builders.
	Alerts *AlertsClient
	// Apikeys is the client for interacting with the Apikeys builders.
	Apikeys *ApikeysClient
	// CaptureLogs is the client for interacting with the CaptureLogs builders.
	CaptureLogs *CaptureLogsClient
	// Devices is the client for interacting with the Devices builders.
	Devices *DevicesClient
	// FMPMSApi is the client for interacting with the FMPMSApi builders.
	FMPMSApi *FMPMSApiClient
	// Faces is the client for interacting with the Faces builders.
	Faces *FacesClient
	// FieldMetadata is the client for interacting with the FieldMetadata builders.
	FieldMetadata *FieldMetadataClient
	// FmAlertDefinition is the client for interacting with the FmAlertDefinition builders.
	FmAlertDefinition *FmAlertDefinitionClient
	// FmAlertGroup is the client for interacting with the FmAlertGroup builders.
	FmAlertGroup *FmAlertGroupClient
	// FmDedicatedServices is the client for interacting with the FmDedicatedServices builders.
	FmDedicatedServices *FmDedicatedServicesClient
	// FmDemands is the client for interacting with the FmDemands builders.
	FmDemands *FmDemandsClient
	// FmUserAccount is the client for interacting with the FmUserAccount builders.
	FmUserAccount *FmUserAccountClient
	// GovArea is the client for interacting with the GovArea builders.
	GovArea *GovAreaClient
	// GovCity is the client for interacting with the GovCity builders.
	GovCity *GovCityClient
	// GovStreet is the client for interacting with the GovStreet builders.
	GovStreet *GovStreetClient
	// GrouProfileTypeMapping is the client for interacting with the GrouProfileTypeMapping builders.
	GrouProfileTypeMapping *GrouProfileTypeMappingClient
	// ProfileType is the client for interacting with the ProfileType builders.
	ProfileType *ProfileTypeClient
	// Profiles is the client for interacting with the Profiles builders.
	Profiles *ProfilesClient
	// Province is the client for interacting with the Province builders.
	Province *ProvinceClient
	// SqlLog is the client for interacting with the SqlLog builders.
	SqlLog *SqlLogClient
	// TemporaryFace is the client for interacting with the TemporaryFace builders.
	TemporaryFace *TemporaryFaceClient
	// Tenants is the client for interacting with the Tenants builders.
	Tenants *TenantsClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Alerts = NewAlertsClient(c.config)
	c.Apikeys = NewApikeysClient(c.config)
	c.CaptureLogs = NewCaptureLogsClient(c.config)
	c.Devices = NewDevicesClient(c.config)
	c.FMPMSApi = NewFMPMSApiClient(c.config)
	c.Faces = NewFacesClient(c.config)
	c.FieldMetadata = NewFieldMetadataClient(c.config)
	c.FmAlertDefinition = NewFmAlertDefinitionClient(c.config)
	c.FmAlertGroup = NewFmAlertGroupClient(c.config)
	c.FmDedicatedServices = NewFmDedicatedServicesClient(c.config)
	c.FmDemands = NewFmDemandsClient(c.config)
	c.FmUserAccount = NewFmUserAccountClient(c.config)
	c.GovArea = NewGovAreaClient(c.config)
	c.GovCity = NewGovCityClient(c.config)
	c.GovStreet = NewGovStreetClient(c.config)
	c.GrouProfileTypeMapping = NewGrouProfileTypeMappingClient(c.config)
	c.ProfileType = NewProfileTypeClient(c.config)
	c.Profiles = NewProfilesClient(c.config)
	c.Province = NewProvinceClient(c.config)
	c.SqlLog = NewSqlLogClient(c.config)
	c.TemporaryFace = NewTemporaryFaceClient(c.config)
	c.Tenants = NewTenantsClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("genclients: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("genclients: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Alerts:                 NewAlertsClient(cfg),
		Apikeys:                NewApikeysClient(cfg),
		CaptureLogs:            NewCaptureLogsClient(cfg),
		Devices:                NewDevicesClient(cfg),
		FMPMSApi:               NewFMPMSApiClient(cfg),
		Faces:                  NewFacesClient(cfg),
		FieldMetadata:          NewFieldMetadataClient(cfg),
		FmAlertDefinition:      NewFmAlertDefinitionClient(cfg),
		FmAlertGroup:           NewFmAlertGroupClient(cfg),
		FmDedicatedServices:    NewFmDedicatedServicesClient(cfg),
		FmDemands:              NewFmDemandsClient(cfg),
		FmUserAccount:          NewFmUserAccountClient(cfg),
		GovArea:                NewGovAreaClient(cfg),
		GovCity:                NewGovCityClient(cfg),
		GovStreet:              NewGovStreetClient(cfg),
		GrouProfileTypeMapping: NewGrouProfileTypeMappingClient(cfg),
		ProfileType:            NewProfileTypeClient(cfg),
		Profiles:               NewProfilesClient(cfg),
		Province:               NewProvinceClient(cfg),
		SqlLog:                 NewSqlLogClient(cfg),
		TemporaryFace:          NewTemporaryFaceClient(cfg),
		Tenants:                NewTenantsClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Alerts:                 NewAlertsClient(cfg),
		Apikeys:                NewApikeysClient(cfg),
		CaptureLogs:            NewCaptureLogsClient(cfg),
		Devices:                NewDevicesClient(cfg),
		FMPMSApi:               NewFMPMSApiClient(cfg),
		Faces:                  NewFacesClient(cfg),
		FieldMetadata:          NewFieldMetadataClient(cfg),
		FmAlertDefinition:      NewFmAlertDefinitionClient(cfg),
		FmAlertGroup:           NewFmAlertGroupClient(cfg),
		FmDedicatedServices:    NewFmDedicatedServicesClient(cfg),
		FmDemands:              NewFmDemandsClient(cfg),
		FmUserAccount:          NewFmUserAccountClient(cfg),
		GovArea:                NewGovAreaClient(cfg),
		GovCity:                NewGovCityClient(cfg),
		GovStreet:              NewGovStreetClient(cfg),
		GrouProfileTypeMapping: NewGrouProfileTypeMappingClient(cfg),
		ProfileType:            NewProfileTypeClient(cfg),
		Profiles:               NewProfilesClient(cfg),
		Province:               NewProvinceClient(cfg),
		SqlLog:                 NewSqlLogClient(cfg),
		TemporaryFace:          NewTemporaryFaceClient(cfg),
		Tenants:                NewTenantsClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Alerts.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Alerts, c.Apikeys, c.CaptureLogs, c.Devices, c.FMPMSApi, c.Faces,
		c.FieldMetadata, c.FmAlertDefinition, c.FmAlertGroup, c.FmDedicatedServices,
		c.FmDemands, c.FmUserAccount, c.GovArea, c.GovCity, c.GovStreet,
		c.GrouProfileTypeMapping, c.ProfileType, c.Profiles, c.Province, c.SqlLog,
		c.TemporaryFace, c.Tenants,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Alerts, c.Apikeys, c.CaptureLogs, c.Devices, c.FMPMSApi, c.Faces,
		c.FieldMetadata, c.FmAlertDefinition, c.FmAlertGroup, c.FmDedicatedServices,
		c.FmDemands, c.FmUserAccount, c.GovArea, c.GovCity, c.GovStreet,
		c.GrouProfileTypeMapping, c.ProfileType, c.Profiles, c.Province, c.SqlLog,
		c.TemporaryFace, c.Tenants,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AlertsMutation:
		return c.Alerts.mutate(ctx, m)
	case *ApikeysMutation:
		return c.Apikeys.mutate(ctx, m)
	case *CaptureLogsMutation:
		return c.CaptureLogs.mutate(ctx, m)
	case *DevicesMutation:
		return c.Devices.mutate(ctx, m)
	case *FMPMSApiMutation:
		return c.FMPMSApi.mutate(ctx, m)
	case *FacesMutation:
		return c.Faces.mutate(ctx, m)
	case *FieldMetadataMutation:
		return c.FieldMetadata.mutate(ctx, m)
	case *FmAlertDefinitionMutation:
		return c.FmAlertDefinition.mutate(ctx, m)
	case *FmAlertGroupMutation:
		return c.FmAlertGroup.mutate(ctx, m)
	case *FmDedicatedServicesMutation:
		return c.FmDedicatedServices.mutate(ctx, m)
	case *FmDemandsMutation:
		return c.FmDemands.mutate(ctx, m)
	case *FmUserAccountMutation:
		return c.FmUserAccount.mutate(ctx, m)
	case *GovAreaMutation:
		return c.GovArea.mutate(ctx, m)
	case *GovCityMutation:
		return c.GovCity.mutate(ctx, m)
	case *GovStreetMutation:
		return c.GovStreet.mutate(ctx, m)
	case *GrouProfileTypeMappingMutation:
		return c.GrouProfileTypeMapping.mutate(ctx, m)
	case *ProfileTypeMutation:
		return c.ProfileType.mutate(ctx, m)
	case *ProfilesMutation:
		return c.Profiles.mutate(ctx, m)
	case *ProvinceMutation:
		return c.Province.mutate(ctx, m)
	case *SqlLogMutation:
		return c.SqlLog.mutate(ctx, m)
	case *TemporaryFaceMutation:
		return c.TemporaryFace.mutate(ctx, m)
	case *TenantsMutation:
		return c.Tenants.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("genclients: unknown mutation type %T", m)
	}
}

// AlertsClient is a client for the Alerts schema.
type AlertsClient struct {
	config
}

// NewAlertsClient returns a client for the Alerts from the given config.
func NewAlertsClient(c config) *AlertsClient {
	return &AlertsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `alerts.Hooks(f(g(h())))`.
func (c *AlertsClient) Use(hooks ...Hook) {
	c.hooks.Alerts = append(c.hooks.Alerts, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `alerts.Intercept(f(g(h())))`.
func (c *AlertsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Alerts = append(c.inters.Alerts, interceptors...)
}

// Create returns a builder for creating a Alerts entity.
func (c *AlertsClient) Create() *AlertsCreate {
	mutation := newAlertsMutation(c.config, OpCreate)
	return &AlertsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Alerts entities.
func (c *AlertsClient) CreateBulk(builders ...*AlertsCreate) *AlertsCreateBulk {
	return &AlertsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlertsClient) MapCreateBulk(slice any, setFunc func(*AlertsCreate, int)) *AlertsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlertsCreateBulk{err: fmt.Errorf("calling to AlertsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlertsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlertsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Alerts.
func (c *AlertsClient) Update() *AlertsUpdate {
	mutation := newAlertsMutation(c.config, OpUpdate)
	return &AlertsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlertsClient) UpdateOne(a *Alerts) *AlertsUpdateOne {
	mutation := newAlertsMutation(c.config, OpUpdateOne, withAlerts(a))
	return &AlertsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlertsClient) UpdateOneID(id int64) *AlertsUpdateOne {
	mutation := newAlertsMutation(c.config, OpUpdateOne, withAlertsID(id))
	return &AlertsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Alerts.
func (c *AlertsClient) Delete() *AlertsDelete {
	mutation := newAlertsMutation(c.config, OpDelete)
	return &AlertsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlertsClient) DeleteOne(a *Alerts) *AlertsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlertsClient) DeleteOneID(id int64) *AlertsDeleteOne {
	builder := c.Delete().Where(alerts.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlertsDeleteOne{builder}
}

// Query returns a query builder for Alerts.
func (c *AlertsClient) Query() *AlertsQuery {
	return &AlertsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlerts},
		inters: c.Interceptors(),
	}
}

// Get returns a Alerts entity by its id.
func (c *AlertsClient) Get(ctx context.Context, id int64) (*Alerts, error) {
	return c.Query().Where(alerts.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlertsClient) GetX(ctx context.Context, id int64) *Alerts {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AlertsClient) Hooks() []Hook {
	return c.hooks.Alerts
}

// Interceptors returns the client interceptors.
func (c *AlertsClient) Interceptors() []Interceptor {
	return c.inters.Alerts
}

func (c *AlertsClient) mutate(ctx context.Context, m *AlertsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlertsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlertsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlertsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlertsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Alerts mutation op: %q", m.Op())
	}
}

// ApikeysClient is a client for the Apikeys schema.
type ApikeysClient struct {
	config
}

// NewApikeysClient returns a client for the Apikeys from the given config.
func NewApikeysClient(c config) *ApikeysClient {
	return &ApikeysClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apikeys.Hooks(f(g(h())))`.
func (c *ApikeysClient) Use(hooks ...Hook) {
	c.hooks.Apikeys = append(c.hooks.Apikeys, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apikeys.Intercept(f(g(h())))`.
func (c *ApikeysClient) Intercept(interceptors ...Interceptor) {
	c.inters.Apikeys = append(c.inters.Apikeys, interceptors...)
}

// Create returns a builder for creating a Apikeys entity.
func (c *ApikeysClient) Create() *ApikeysCreate {
	mutation := newApikeysMutation(c.config, OpCreate)
	return &ApikeysCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Apikeys entities.
func (c *ApikeysClient) CreateBulk(builders ...*ApikeysCreate) *ApikeysCreateBulk {
	return &ApikeysCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApikeysClient) MapCreateBulk(slice any, setFunc func(*ApikeysCreate, int)) *ApikeysCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApikeysCreateBulk{err: fmt.Errorf("calling to ApikeysClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApikeysCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApikeysCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Apikeys.
func (c *ApikeysClient) Update() *ApikeysUpdate {
	mutation := newApikeysMutation(c.config, OpUpdate)
	return &ApikeysUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApikeysClient) UpdateOne(a *Apikeys) *ApikeysUpdateOne {
	mutation := newApikeysMutation(c.config, OpUpdateOne, withApikeys(a))
	return &ApikeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApikeysClient) UpdateOneID(id int64) *ApikeysUpdateOne {
	mutation := newApikeysMutation(c.config, OpUpdateOne, withApikeysID(id))
	return &ApikeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Apikeys.
func (c *ApikeysClient) Delete() *ApikeysDelete {
	mutation := newApikeysMutation(c.config, OpDelete)
	return &ApikeysDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApikeysClient) DeleteOne(a *Apikeys) *ApikeysDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApikeysClient) DeleteOneID(id int64) *ApikeysDeleteOne {
	builder := c.Delete().Where(apikeys.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApikeysDeleteOne{builder}
}

// Query returns a query builder for Apikeys.
func (c *ApikeysClient) Query() *ApikeysQuery {
	return &ApikeysQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApikeys},
		inters: c.Interceptors(),
	}
}

// Get returns a Apikeys entity by its id.
func (c *ApikeysClient) Get(ctx context.Context, id int64) (*Apikeys, error) {
	return c.Query().Where(apikeys.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApikeysClient) GetX(ctx context.Context, id int64) *Apikeys {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApikeysClient) Hooks() []Hook {
	return c.hooks.Apikeys
}

// Interceptors returns the client interceptors.
func (c *ApikeysClient) Interceptors() []Interceptor {
	return c.inters.Apikeys
}

func (c *ApikeysClient) mutate(ctx context.Context, m *ApikeysMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApikeysCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApikeysUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApikeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApikeysDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Apikeys mutation op: %q", m.Op())
	}
}

// CaptureLogsClient is a client for the CaptureLogs schema.
type CaptureLogsClient struct {
	config
}

// NewCaptureLogsClient returns a client for the CaptureLogs from the given config.
func NewCaptureLogsClient(c config) *CaptureLogsClient {
	return &CaptureLogsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `capturelogs.Hooks(f(g(h())))`.
func (c *CaptureLogsClient) Use(hooks ...Hook) {
	c.hooks.CaptureLogs = append(c.hooks.CaptureLogs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `capturelogs.Intercept(f(g(h())))`.
func (c *CaptureLogsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CaptureLogs = append(c.inters.CaptureLogs, interceptors...)
}

// Create returns a builder for creating a CaptureLogs entity.
func (c *CaptureLogsClient) Create() *CaptureLogsCreate {
	mutation := newCaptureLogsMutation(c.config, OpCreate)
	return &CaptureLogsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CaptureLogs entities.
func (c *CaptureLogsClient) CreateBulk(builders ...*CaptureLogsCreate) *CaptureLogsCreateBulk {
	return &CaptureLogsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CaptureLogsClient) MapCreateBulk(slice any, setFunc func(*CaptureLogsCreate, int)) *CaptureLogsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CaptureLogsCreateBulk{err: fmt.Errorf("calling to CaptureLogsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CaptureLogsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CaptureLogsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CaptureLogs.
func (c *CaptureLogsClient) Update() *CaptureLogsUpdate {
	mutation := newCaptureLogsMutation(c.config, OpUpdate)
	return &CaptureLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CaptureLogsClient) UpdateOne(cl *CaptureLogs) *CaptureLogsUpdateOne {
	mutation := newCaptureLogsMutation(c.config, OpUpdateOne, withCaptureLogs(cl))
	return &CaptureLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CaptureLogsClient) UpdateOneID(id int64) *CaptureLogsUpdateOne {
	mutation := newCaptureLogsMutation(c.config, OpUpdateOne, withCaptureLogsID(id))
	return &CaptureLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CaptureLogs.
func (c *CaptureLogsClient) Delete() *CaptureLogsDelete {
	mutation := newCaptureLogsMutation(c.config, OpDelete)
	return &CaptureLogsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CaptureLogsClient) DeleteOne(cl *CaptureLogs) *CaptureLogsDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CaptureLogsClient) DeleteOneID(id int64) *CaptureLogsDeleteOne {
	builder := c.Delete().Where(capturelogs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CaptureLogsDeleteOne{builder}
}

// Query returns a query builder for CaptureLogs.
func (c *CaptureLogsClient) Query() *CaptureLogsQuery {
	return &CaptureLogsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCaptureLogs},
		inters: c.Interceptors(),
	}
}

// Get returns a CaptureLogs entity by its id.
func (c *CaptureLogsClient) Get(ctx context.Context, id int64) (*CaptureLogs, error) {
	return c.Query().Where(capturelogs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CaptureLogsClient) GetX(ctx context.Context, id int64) *CaptureLogs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CaptureLogsClient) Hooks() []Hook {
	return c.hooks.CaptureLogs
}

// Interceptors returns the client interceptors.
func (c *CaptureLogsClient) Interceptors() []Interceptor {
	return c.inters.CaptureLogs
}

func (c *CaptureLogsClient) mutate(ctx context.Context, m *CaptureLogsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CaptureLogsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CaptureLogsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CaptureLogsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CaptureLogsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown CaptureLogs mutation op: %q", m.Op())
	}
}

// DevicesClient is a client for the Devices schema.
type DevicesClient struct {
	config
}

// NewDevicesClient returns a client for the Devices from the given config.
func NewDevicesClient(c config) *DevicesClient {
	return &DevicesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `devices.Hooks(f(g(h())))`.
func (c *DevicesClient) Use(hooks ...Hook) {
	c.hooks.Devices = append(c.hooks.Devices, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `devices.Intercept(f(g(h())))`.
func (c *DevicesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Devices = append(c.inters.Devices, interceptors...)
}

// Create returns a builder for creating a Devices entity.
func (c *DevicesClient) Create() *DevicesCreate {
	mutation := newDevicesMutation(c.config, OpCreate)
	return &DevicesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Devices entities.
func (c *DevicesClient) CreateBulk(builders ...*DevicesCreate) *DevicesCreateBulk {
	return &DevicesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DevicesClient) MapCreateBulk(slice any, setFunc func(*DevicesCreate, int)) *DevicesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DevicesCreateBulk{err: fmt.Errorf("calling to DevicesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DevicesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DevicesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Devices.
func (c *DevicesClient) Update() *DevicesUpdate {
	mutation := newDevicesMutation(c.config, OpUpdate)
	return &DevicesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DevicesClient) UpdateOne(d *Devices) *DevicesUpdateOne {
	mutation := newDevicesMutation(c.config, OpUpdateOne, withDevices(d))
	return &DevicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DevicesClient) UpdateOneID(id int64) *DevicesUpdateOne {
	mutation := newDevicesMutation(c.config, OpUpdateOne, withDevicesID(id))
	return &DevicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Devices.
func (c *DevicesClient) Delete() *DevicesDelete {
	mutation := newDevicesMutation(c.config, OpDelete)
	return &DevicesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DevicesClient) DeleteOne(d *Devices) *DevicesDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DevicesClient) DeleteOneID(id int64) *DevicesDeleteOne {
	builder := c.Delete().Where(devices.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DevicesDeleteOne{builder}
}

// Query returns a query builder for Devices.
func (c *DevicesClient) Query() *DevicesQuery {
	return &DevicesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDevices},
		inters: c.Interceptors(),
	}
}

// Get returns a Devices entity by its id.
func (c *DevicesClient) Get(ctx context.Context, id int64) (*Devices, error) {
	return c.Query().Where(devices.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DevicesClient) GetX(ctx context.Context, id int64) *Devices {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DevicesClient) Hooks() []Hook {
	return c.hooks.Devices
}

// Interceptors returns the client interceptors.
func (c *DevicesClient) Interceptors() []Interceptor {
	return c.inters.Devices
}

func (c *DevicesClient) mutate(ctx context.Context, m *DevicesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DevicesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DevicesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DevicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DevicesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Devices mutation op: %q", m.Op())
	}
}

// FMPMSApiClient is a client for the FMPMSApi schema.
type FMPMSApiClient struct {
	config
}

// NewFMPMSApiClient returns a client for the FMPMSApi from the given config.
func NewFMPMSApiClient(c config) *FMPMSApiClient {
	return &FMPMSApiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fmpmsapi.Hooks(f(g(h())))`.
func (c *FMPMSApiClient) Use(hooks ...Hook) {
	c.hooks.FMPMSApi = append(c.hooks.FMPMSApi, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fmpmsapi.Intercept(f(g(h())))`.
func (c *FMPMSApiClient) Intercept(interceptors ...Interceptor) {
	c.inters.FMPMSApi = append(c.inters.FMPMSApi, interceptors...)
}

// Create returns a builder for creating a FMPMSApi entity.
func (c *FMPMSApiClient) Create() *FMPMSApiCreate {
	mutation := newFMPMSApiMutation(c.config, OpCreate)
	return &FMPMSApiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FMPMSApi entities.
func (c *FMPMSApiClient) CreateBulk(builders ...*FMPMSApiCreate) *FMPMSApiCreateBulk {
	return &FMPMSApiCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FMPMSApiClient) MapCreateBulk(slice any, setFunc func(*FMPMSApiCreate, int)) *FMPMSApiCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FMPMSApiCreateBulk{err: fmt.Errorf("calling to FMPMSApiClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FMPMSApiCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FMPMSApiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FMPMSApi.
func (c *FMPMSApiClient) Update() *FMPMSApiUpdate {
	mutation := newFMPMSApiMutation(c.config, OpUpdate)
	return &FMPMSApiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FMPMSApiClient) UpdateOne(fa *FMPMSApi) *FMPMSApiUpdateOne {
	mutation := newFMPMSApiMutation(c.config, OpUpdateOne, withFMPMSApi(fa))
	return &FMPMSApiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FMPMSApiClient) UpdateOneID(id int64) *FMPMSApiUpdateOne {
	mutation := newFMPMSApiMutation(c.config, OpUpdateOne, withFMPMSApiID(id))
	return &FMPMSApiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FMPMSApi.
func (c *FMPMSApiClient) Delete() *FMPMSApiDelete {
	mutation := newFMPMSApiMutation(c.config, OpDelete)
	return &FMPMSApiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FMPMSApiClient) DeleteOne(fa *FMPMSApi) *FMPMSApiDeleteOne {
	return c.DeleteOneID(fa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FMPMSApiClient) DeleteOneID(id int64) *FMPMSApiDeleteOne {
	builder := c.Delete().Where(fmpmsapi.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FMPMSApiDeleteOne{builder}
}

// Query returns a query builder for FMPMSApi.
func (c *FMPMSApiClient) Query() *FMPMSApiQuery {
	return &FMPMSApiQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFMPMSApi},
		inters: c.Interceptors(),
	}
}

// Get returns a FMPMSApi entity by its id.
func (c *FMPMSApiClient) Get(ctx context.Context, id int64) (*FMPMSApi, error) {
	return c.Query().Where(fmpmsapi.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FMPMSApiClient) GetX(ctx context.Context, id int64) *FMPMSApi {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FMPMSApiClient) Hooks() []Hook {
	return c.hooks.FMPMSApi
}

// Interceptors returns the client interceptors.
func (c *FMPMSApiClient) Interceptors() []Interceptor {
	return c.inters.FMPMSApi
}

func (c *FMPMSApiClient) mutate(ctx context.Context, m *FMPMSApiMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FMPMSApiCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FMPMSApiUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FMPMSApiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FMPMSApiDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FMPMSApi mutation op: %q", m.Op())
	}
}

// FacesClient is a client for the Faces schema.
type FacesClient struct {
	config
}

// NewFacesClient returns a client for the Faces from the given config.
func NewFacesClient(c config) *FacesClient {
	return &FacesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `faces.Hooks(f(g(h())))`.
func (c *FacesClient) Use(hooks ...Hook) {
	c.hooks.Faces = append(c.hooks.Faces, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `faces.Intercept(f(g(h())))`.
func (c *FacesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Faces = append(c.inters.Faces, interceptors...)
}

// Create returns a builder for creating a Faces entity.
func (c *FacesClient) Create() *FacesCreate {
	mutation := newFacesMutation(c.config, OpCreate)
	return &FacesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Faces entities.
func (c *FacesClient) CreateBulk(builders ...*FacesCreate) *FacesCreateBulk {
	return &FacesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FacesClient) MapCreateBulk(slice any, setFunc func(*FacesCreate, int)) *FacesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FacesCreateBulk{err: fmt.Errorf("calling to FacesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FacesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FacesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Faces.
func (c *FacesClient) Update() *FacesUpdate {
	mutation := newFacesMutation(c.config, OpUpdate)
	return &FacesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FacesClient) UpdateOne(f *Faces) *FacesUpdateOne {
	mutation := newFacesMutation(c.config, OpUpdateOne, withFaces(f))
	return &FacesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FacesClient) UpdateOneID(id int64) *FacesUpdateOne {
	mutation := newFacesMutation(c.config, OpUpdateOne, withFacesID(id))
	return &FacesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Faces.
func (c *FacesClient) Delete() *FacesDelete {
	mutation := newFacesMutation(c.config, OpDelete)
	return &FacesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FacesClient) DeleteOne(f *Faces) *FacesDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FacesClient) DeleteOneID(id int64) *FacesDeleteOne {
	builder := c.Delete().Where(faces.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FacesDeleteOne{builder}
}

// Query returns a query builder for Faces.
func (c *FacesClient) Query() *FacesQuery {
	return &FacesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFaces},
		inters: c.Interceptors(),
	}
}

// Get returns a Faces entity by its id.
func (c *FacesClient) Get(ctx context.Context, id int64) (*Faces, error) {
	return c.Query().Where(faces.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FacesClient) GetX(ctx context.Context, id int64) *Faces {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FacesClient) Hooks() []Hook {
	return c.hooks.Faces
}

// Interceptors returns the client interceptors.
func (c *FacesClient) Interceptors() []Interceptor {
	return c.inters.Faces
}

func (c *FacesClient) mutate(ctx context.Context, m *FacesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FacesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FacesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FacesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FacesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Faces mutation op: %q", m.Op())
	}
}

// FieldMetadataClient is a client for the FieldMetadata schema.
type FieldMetadataClient struct {
	config
}

// NewFieldMetadataClient returns a client for the FieldMetadata from the given config.
func NewFieldMetadataClient(c config) *FieldMetadataClient {
	return &FieldMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fieldmetadata.Hooks(f(g(h())))`.
func (c *FieldMetadataClient) Use(hooks ...Hook) {
	c.hooks.FieldMetadata = append(c.hooks.FieldMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fieldmetadata.Intercept(f(g(h())))`.
func (c *FieldMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.FieldMetadata = append(c.inters.FieldMetadata, interceptors...)
}

// Create returns a builder for creating a FieldMetadata entity.
func (c *FieldMetadataClient) Create() *FieldMetadataCreate {
	mutation := newFieldMetadataMutation(c.config, OpCreate)
	return &FieldMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FieldMetadata entities.
func (c *FieldMetadataClient) CreateBulk(builders ...*FieldMetadataCreate) *FieldMetadataCreateBulk {
	return &FieldMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FieldMetadataClient) MapCreateBulk(slice any, setFunc func(*FieldMetadataCreate, int)) *FieldMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FieldMetadataCreateBulk{err: fmt.Errorf("calling to FieldMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FieldMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FieldMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FieldMetadata.
func (c *FieldMetadataClient) Update() *FieldMetadataUpdate {
	mutation := newFieldMetadataMutation(c.config, OpUpdate)
	return &FieldMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FieldMetadataClient) UpdateOne(fm *FieldMetadata) *FieldMetadataUpdateOne {
	mutation := newFieldMetadataMutation(c.config, OpUpdateOne, withFieldMetadata(fm))
	return &FieldMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FieldMetadataClient) UpdateOneID(id int64) *FieldMetadataUpdateOne {
	mutation := newFieldMetadataMutation(c.config, OpUpdateOne, withFieldMetadataID(id))
	return &FieldMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FieldMetadata.
func (c *FieldMetadataClient) Delete() *FieldMetadataDelete {
	mutation := newFieldMetadataMutation(c.config, OpDelete)
	return &FieldMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FieldMetadataClient) DeleteOne(fm *FieldMetadata) *FieldMetadataDeleteOne {
	return c.DeleteOneID(fm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FieldMetadataClient) DeleteOneID(id int64) *FieldMetadataDeleteOne {
	builder := c.Delete().Where(fieldmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FieldMetadataDeleteOne{builder}
}

// Query returns a query builder for FieldMetadata.
func (c *FieldMetadataClient) Query() *FieldMetadataQuery {
	return &FieldMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFieldMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a FieldMetadata entity by its id.
func (c *FieldMetadataClient) Get(ctx context.Context, id int64) (*FieldMetadata, error) {
	return c.Query().Where(fieldmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FieldMetadataClient) GetX(ctx context.Context, id int64) *FieldMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FieldMetadataClient) Hooks() []Hook {
	return c.hooks.FieldMetadata
}

// Interceptors returns the client interceptors.
func (c *FieldMetadataClient) Interceptors() []Interceptor {
	return c.inters.FieldMetadata
}

func (c *FieldMetadataClient) mutate(ctx context.Context, m *FieldMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FieldMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FieldMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FieldMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FieldMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FieldMetadata mutation op: %q", m.Op())
	}
}

// FmAlertDefinitionClient is a client for the FmAlertDefinition schema.
type FmAlertDefinitionClient struct {
	config
}

// NewFmAlertDefinitionClient returns a client for the FmAlertDefinition from the given config.
func NewFmAlertDefinitionClient(c config) *FmAlertDefinitionClient {
	return &FmAlertDefinitionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fmalertdefinition.Hooks(f(g(h())))`.
func (c *FmAlertDefinitionClient) Use(hooks ...Hook) {
	c.hooks.FmAlertDefinition = append(c.hooks.FmAlertDefinition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fmalertdefinition.Intercept(f(g(h())))`.
func (c *FmAlertDefinitionClient) Intercept(interceptors ...Interceptor) {
	c.inters.FmAlertDefinition = append(c.inters.FmAlertDefinition, interceptors...)
}

// Create returns a builder for creating a FmAlertDefinition entity.
func (c *FmAlertDefinitionClient) Create() *FmAlertDefinitionCreate {
	mutation := newFmAlertDefinitionMutation(c.config, OpCreate)
	return &FmAlertDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FmAlertDefinition entities.
func (c *FmAlertDefinitionClient) CreateBulk(builders ...*FmAlertDefinitionCreate) *FmAlertDefinitionCreateBulk {
	return &FmAlertDefinitionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FmAlertDefinitionClient) MapCreateBulk(slice any, setFunc func(*FmAlertDefinitionCreate, int)) *FmAlertDefinitionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FmAlertDefinitionCreateBulk{err: fmt.Errorf("calling to FmAlertDefinitionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FmAlertDefinitionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FmAlertDefinitionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FmAlertDefinition.
func (c *FmAlertDefinitionClient) Update() *FmAlertDefinitionUpdate {
	mutation := newFmAlertDefinitionMutation(c.config, OpUpdate)
	return &FmAlertDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FmAlertDefinitionClient) UpdateOne(fad *FmAlertDefinition) *FmAlertDefinitionUpdateOne {
	mutation := newFmAlertDefinitionMutation(c.config, OpUpdateOne, withFmAlertDefinition(fad))
	return &FmAlertDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FmAlertDefinitionClient) UpdateOneID(id int64) *FmAlertDefinitionUpdateOne {
	mutation := newFmAlertDefinitionMutation(c.config, OpUpdateOne, withFmAlertDefinitionID(id))
	return &FmAlertDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FmAlertDefinition.
func (c *FmAlertDefinitionClient) Delete() *FmAlertDefinitionDelete {
	mutation := newFmAlertDefinitionMutation(c.config, OpDelete)
	return &FmAlertDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FmAlertDefinitionClient) DeleteOne(fad *FmAlertDefinition) *FmAlertDefinitionDeleteOne {
	return c.DeleteOneID(fad.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FmAlertDefinitionClient) DeleteOneID(id int64) *FmAlertDefinitionDeleteOne {
	builder := c.Delete().Where(fmalertdefinition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FmAlertDefinitionDeleteOne{builder}
}

// Query returns a query builder for FmAlertDefinition.
func (c *FmAlertDefinitionClient) Query() *FmAlertDefinitionQuery {
	return &FmAlertDefinitionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFmAlertDefinition},
		inters: c.Interceptors(),
	}
}

// Get returns a FmAlertDefinition entity by its id.
func (c *FmAlertDefinitionClient) Get(ctx context.Context, id int64) (*FmAlertDefinition, error) {
	return c.Query().Where(fmalertdefinition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FmAlertDefinitionClient) GetX(ctx context.Context, id int64) *FmAlertDefinition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FmAlertDefinitionClient) Hooks() []Hook {
	return c.hooks.FmAlertDefinition
}

// Interceptors returns the client interceptors.
func (c *FmAlertDefinitionClient) Interceptors() []Interceptor {
	return c.inters.FmAlertDefinition
}

func (c *FmAlertDefinitionClient) mutate(ctx context.Context, m *FmAlertDefinitionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FmAlertDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FmAlertDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FmAlertDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FmAlertDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FmAlertDefinition mutation op: %q", m.Op())
	}
}

// FmAlertGroupClient is a client for the FmAlertGroup schema.
type FmAlertGroupClient struct {
	config
}

// NewFmAlertGroupClient returns a client for the FmAlertGroup from the given config.
func NewFmAlertGroupClient(c config) *FmAlertGroupClient {
	return &FmAlertGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fmalertgroup.Hooks(f(g(h())))`.
func (c *FmAlertGroupClient) Use(hooks ...Hook) {
	c.hooks.FmAlertGroup = append(c.hooks.FmAlertGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fmalertgroup.Intercept(f(g(h())))`.
func (c *FmAlertGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.FmAlertGroup = append(c.inters.FmAlertGroup, interceptors...)
}

// Create returns a builder for creating a FmAlertGroup entity.
func (c *FmAlertGroupClient) Create() *FmAlertGroupCreate {
	mutation := newFmAlertGroupMutation(c.config, OpCreate)
	return &FmAlertGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FmAlertGroup entities.
func (c *FmAlertGroupClient) CreateBulk(builders ...*FmAlertGroupCreate) *FmAlertGroupCreateBulk {
	return &FmAlertGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FmAlertGroupClient) MapCreateBulk(slice any, setFunc func(*FmAlertGroupCreate, int)) *FmAlertGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FmAlertGroupCreateBulk{err: fmt.Errorf("calling to FmAlertGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FmAlertGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FmAlertGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FmAlertGroup.
func (c *FmAlertGroupClient) Update() *FmAlertGroupUpdate {
	mutation := newFmAlertGroupMutation(c.config, OpUpdate)
	return &FmAlertGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FmAlertGroupClient) UpdateOne(fag *FmAlertGroup) *FmAlertGroupUpdateOne {
	mutation := newFmAlertGroupMutation(c.config, OpUpdateOne, withFmAlertGroup(fag))
	return &FmAlertGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FmAlertGroupClient) UpdateOneID(id int64) *FmAlertGroupUpdateOne {
	mutation := newFmAlertGroupMutation(c.config, OpUpdateOne, withFmAlertGroupID(id))
	return &FmAlertGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FmAlertGroup.
func (c *FmAlertGroupClient) Delete() *FmAlertGroupDelete {
	mutation := newFmAlertGroupMutation(c.config, OpDelete)
	return &FmAlertGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FmAlertGroupClient) DeleteOne(fag *FmAlertGroup) *FmAlertGroupDeleteOne {
	return c.DeleteOneID(fag.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FmAlertGroupClient) DeleteOneID(id int64) *FmAlertGroupDeleteOne {
	builder := c.Delete().Where(fmalertgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FmAlertGroupDeleteOne{builder}
}

// Query returns a query builder for FmAlertGroup.
func (c *FmAlertGroupClient) Query() *FmAlertGroupQuery {
	return &FmAlertGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFmAlertGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a FmAlertGroup entity by its id.
func (c *FmAlertGroupClient) Get(ctx context.Context, id int64) (*FmAlertGroup, error) {
	return c.Query().Where(fmalertgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FmAlertGroupClient) GetX(ctx context.Context, id int64) *FmAlertGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FmAlertGroupClient) Hooks() []Hook {
	return c.hooks.FmAlertGroup
}

// Interceptors returns the client interceptors.
func (c *FmAlertGroupClient) Interceptors() []Interceptor {
	return c.inters.FmAlertGroup
}

func (c *FmAlertGroupClient) mutate(ctx context.Context, m *FmAlertGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FmAlertGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FmAlertGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FmAlertGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FmAlertGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FmAlertGroup mutation op: %q", m.Op())
	}
}

// FmDedicatedServicesClient is a client for the FmDedicatedServices schema.
type FmDedicatedServicesClient struct {
	config
}

// NewFmDedicatedServicesClient returns a client for the FmDedicatedServices from the given config.
func NewFmDedicatedServicesClient(c config) *FmDedicatedServicesClient {
	return &FmDedicatedServicesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fmdedicatedservices.Hooks(f(g(h())))`.
func (c *FmDedicatedServicesClient) Use(hooks ...Hook) {
	c.hooks.FmDedicatedServices = append(c.hooks.FmDedicatedServices, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fmdedicatedservices.Intercept(f(g(h())))`.
func (c *FmDedicatedServicesClient) Intercept(interceptors ...Interceptor) {
	c.inters.FmDedicatedServices = append(c.inters.FmDedicatedServices, interceptors...)
}

// Create returns a builder for creating a FmDedicatedServices entity.
func (c *FmDedicatedServicesClient) Create() *FmDedicatedServicesCreate {
	mutation := newFmDedicatedServicesMutation(c.config, OpCreate)
	return &FmDedicatedServicesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FmDedicatedServices entities.
func (c *FmDedicatedServicesClient) CreateBulk(builders ...*FmDedicatedServicesCreate) *FmDedicatedServicesCreateBulk {
	return &FmDedicatedServicesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FmDedicatedServicesClient) MapCreateBulk(slice any, setFunc func(*FmDedicatedServicesCreate, int)) *FmDedicatedServicesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FmDedicatedServicesCreateBulk{err: fmt.Errorf("calling to FmDedicatedServicesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FmDedicatedServicesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FmDedicatedServicesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FmDedicatedServices.
func (c *FmDedicatedServicesClient) Update() *FmDedicatedServicesUpdate {
	mutation := newFmDedicatedServicesMutation(c.config, OpUpdate)
	return &FmDedicatedServicesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FmDedicatedServicesClient) UpdateOne(fds *FmDedicatedServices) *FmDedicatedServicesUpdateOne {
	mutation := newFmDedicatedServicesMutation(c.config, OpUpdateOne, withFmDedicatedServices(fds))
	return &FmDedicatedServicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FmDedicatedServicesClient) UpdateOneID(id int64) *FmDedicatedServicesUpdateOne {
	mutation := newFmDedicatedServicesMutation(c.config, OpUpdateOne, withFmDedicatedServicesID(id))
	return &FmDedicatedServicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FmDedicatedServices.
func (c *FmDedicatedServicesClient) Delete() *FmDedicatedServicesDelete {
	mutation := newFmDedicatedServicesMutation(c.config, OpDelete)
	return &FmDedicatedServicesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FmDedicatedServicesClient) DeleteOne(fds *FmDedicatedServices) *FmDedicatedServicesDeleteOne {
	return c.DeleteOneID(fds.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FmDedicatedServicesClient) DeleteOneID(id int64) *FmDedicatedServicesDeleteOne {
	builder := c.Delete().Where(fmdedicatedservices.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FmDedicatedServicesDeleteOne{builder}
}

// Query returns a query builder for FmDedicatedServices.
func (c *FmDedicatedServicesClient) Query() *FmDedicatedServicesQuery {
	return &FmDedicatedServicesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFmDedicatedServices},
		inters: c.Interceptors(),
	}
}

// Get returns a FmDedicatedServices entity by its id.
func (c *FmDedicatedServicesClient) Get(ctx context.Context, id int64) (*FmDedicatedServices, error) {
	return c.Query().Where(fmdedicatedservices.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FmDedicatedServicesClient) GetX(ctx context.Context, id int64) *FmDedicatedServices {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FmDedicatedServicesClient) Hooks() []Hook {
	return c.hooks.FmDedicatedServices
}

// Interceptors returns the client interceptors.
func (c *FmDedicatedServicesClient) Interceptors() []Interceptor {
	return c.inters.FmDedicatedServices
}

func (c *FmDedicatedServicesClient) mutate(ctx context.Context, m *FmDedicatedServicesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FmDedicatedServicesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FmDedicatedServicesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FmDedicatedServicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FmDedicatedServicesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FmDedicatedServices mutation op: %q", m.Op())
	}
}

// FmDemandsClient is a client for the FmDemands schema.
type FmDemandsClient struct {
	config
}

// NewFmDemandsClient returns a client for the FmDemands from the given config.
func NewFmDemandsClient(c config) *FmDemandsClient {
	return &FmDemandsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fmdemands.Hooks(f(g(h())))`.
func (c *FmDemandsClient) Use(hooks ...Hook) {
	c.hooks.FmDemands = append(c.hooks.FmDemands, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fmdemands.Intercept(f(g(h())))`.
func (c *FmDemandsClient) Intercept(interceptors ...Interceptor) {
	c.inters.FmDemands = append(c.inters.FmDemands, interceptors...)
}

// Create returns a builder for creating a FmDemands entity.
func (c *FmDemandsClient) Create() *FmDemandsCreate {
	mutation := newFmDemandsMutation(c.config, OpCreate)
	return &FmDemandsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FmDemands entities.
func (c *FmDemandsClient) CreateBulk(builders ...*FmDemandsCreate) *FmDemandsCreateBulk {
	return &FmDemandsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FmDemandsClient) MapCreateBulk(slice any, setFunc func(*FmDemandsCreate, int)) *FmDemandsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FmDemandsCreateBulk{err: fmt.Errorf("calling to FmDemandsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FmDemandsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FmDemandsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FmDemands.
func (c *FmDemandsClient) Update() *FmDemandsUpdate {
	mutation := newFmDemandsMutation(c.config, OpUpdate)
	return &FmDemandsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FmDemandsClient) UpdateOne(fd *FmDemands) *FmDemandsUpdateOne {
	mutation := newFmDemandsMutation(c.config, OpUpdateOne, withFmDemands(fd))
	return &FmDemandsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FmDemandsClient) UpdateOneID(id int64) *FmDemandsUpdateOne {
	mutation := newFmDemandsMutation(c.config, OpUpdateOne, withFmDemandsID(id))
	return &FmDemandsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FmDemands.
func (c *FmDemandsClient) Delete() *FmDemandsDelete {
	mutation := newFmDemandsMutation(c.config, OpDelete)
	return &FmDemandsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FmDemandsClient) DeleteOne(fd *FmDemands) *FmDemandsDeleteOne {
	return c.DeleteOneID(fd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FmDemandsClient) DeleteOneID(id int64) *FmDemandsDeleteOne {
	builder := c.Delete().Where(fmdemands.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FmDemandsDeleteOne{builder}
}

// Query returns a query builder for FmDemands.
func (c *FmDemandsClient) Query() *FmDemandsQuery {
	return &FmDemandsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFmDemands},
		inters: c.Interceptors(),
	}
}

// Get returns a FmDemands entity by its id.
func (c *FmDemandsClient) Get(ctx context.Context, id int64) (*FmDemands, error) {
	return c.Query().Where(fmdemands.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FmDemandsClient) GetX(ctx context.Context, id int64) *FmDemands {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FmDemandsClient) Hooks() []Hook {
	return c.hooks.FmDemands
}

// Interceptors returns the client interceptors.
func (c *FmDemandsClient) Interceptors() []Interceptor {
	return c.inters.FmDemands
}

func (c *FmDemandsClient) mutate(ctx context.Context, m *FmDemandsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FmDemandsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FmDemandsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FmDemandsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FmDemandsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FmDemands mutation op: %q", m.Op())
	}
}

// FmUserAccountClient is a client for the FmUserAccount schema.
type FmUserAccountClient struct {
	config
}

// NewFmUserAccountClient returns a client for the FmUserAccount from the given config.
func NewFmUserAccountClient(c config) *FmUserAccountClient {
	return &FmUserAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fmuseraccount.Hooks(f(g(h())))`.
func (c *FmUserAccountClient) Use(hooks ...Hook) {
	c.hooks.FmUserAccount = append(c.hooks.FmUserAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fmuseraccount.Intercept(f(g(h())))`.
func (c *FmUserAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.FmUserAccount = append(c.inters.FmUserAccount, interceptors...)
}

// Create returns a builder for creating a FmUserAccount entity.
func (c *FmUserAccountClient) Create() *FmUserAccountCreate {
	mutation := newFmUserAccountMutation(c.config, OpCreate)
	return &FmUserAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FmUserAccount entities.
func (c *FmUserAccountClient) CreateBulk(builders ...*FmUserAccountCreate) *FmUserAccountCreateBulk {
	return &FmUserAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FmUserAccountClient) MapCreateBulk(slice any, setFunc func(*FmUserAccountCreate, int)) *FmUserAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FmUserAccountCreateBulk{err: fmt.Errorf("calling to FmUserAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FmUserAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FmUserAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FmUserAccount.
func (c *FmUserAccountClient) Update() *FmUserAccountUpdate {
	mutation := newFmUserAccountMutation(c.config, OpUpdate)
	return &FmUserAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FmUserAccountClient) UpdateOne(fua *FmUserAccount) *FmUserAccountUpdateOne {
	mutation := newFmUserAccountMutation(c.config, OpUpdateOne, withFmUserAccount(fua))
	return &FmUserAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FmUserAccountClient) UpdateOneID(id int64) *FmUserAccountUpdateOne {
	mutation := newFmUserAccountMutation(c.config, OpUpdateOne, withFmUserAccountID(id))
	return &FmUserAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FmUserAccount.
func (c *FmUserAccountClient) Delete() *FmUserAccountDelete {
	mutation := newFmUserAccountMutation(c.config, OpDelete)
	return &FmUserAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FmUserAccountClient) DeleteOne(fua *FmUserAccount) *FmUserAccountDeleteOne {
	return c.DeleteOneID(fua.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FmUserAccountClient) DeleteOneID(id int64) *FmUserAccountDeleteOne {
	builder := c.Delete().Where(fmuseraccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FmUserAccountDeleteOne{builder}
}

// Query returns a query builder for FmUserAccount.
func (c *FmUserAccountClient) Query() *FmUserAccountQuery {
	return &FmUserAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFmUserAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a FmUserAccount entity by its id.
func (c *FmUserAccountClient) Get(ctx context.Context, id int64) (*FmUserAccount, error) {
	return c.Query().Where(fmuseraccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FmUserAccountClient) GetX(ctx context.Context, id int64) *FmUserAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FmUserAccountClient) Hooks() []Hook {
	return c.hooks.FmUserAccount
}

// Interceptors returns the client interceptors.
func (c *FmUserAccountClient) Interceptors() []Interceptor {
	return c.inters.FmUserAccount
}

func (c *FmUserAccountClient) mutate(ctx context.Context, m *FmUserAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FmUserAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FmUserAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FmUserAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FmUserAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown FmUserAccount mutation op: %q", m.Op())
	}
}

// GovAreaClient is a client for the GovArea schema.
type GovAreaClient struct {
	config
}

// NewGovAreaClient returns a client for the GovArea from the given config.
func NewGovAreaClient(c config) *GovAreaClient {
	return &GovAreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `govarea.Hooks(f(g(h())))`.
func (c *GovAreaClient) Use(hooks ...Hook) {
	c.hooks.GovArea = append(c.hooks.GovArea, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `govarea.Intercept(f(g(h())))`.
func (c *GovAreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.GovArea = append(c.inters.GovArea, interceptors...)
}

// Create returns a builder for creating a GovArea entity.
func (c *GovAreaClient) Create() *GovAreaCreate {
	mutation := newGovAreaMutation(c.config, OpCreate)
	return &GovAreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GovArea entities.
func (c *GovAreaClient) CreateBulk(builders ...*GovAreaCreate) *GovAreaCreateBulk {
	return &GovAreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GovAreaClient) MapCreateBulk(slice any, setFunc func(*GovAreaCreate, int)) *GovAreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GovAreaCreateBulk{err: fmt.Errorf("calling to GovAreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GovAreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GovAreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GovArea.
func (c *GovAreaClient) Update() *GovAreaUpdate {
	mutation := newGovAreaMutation(c.config, OpUpdate)
	return &GovAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GovAreaClient) UpdateOne(ga *GovArea) *GovAreaUpdateOne {
	mutation := newGovAreaMutation(c.config, OpUpdateOne, withGovArea(ga))
	return &GovAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GovAreaClient) UpdateOneID(id int64) *GovAreaUpdateOne {
	mutation := newGovAreaMutation(c.config, OpUpdateOne, withGovAreaID(id))
	return &GovAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GovArea.
func (c *GovAreaClient) Delete() *GovAreaDelete {
	mutation := newGovAreaMutation(c.config, OpDelete)
	return &GovAreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GovAreaClient) DeleteOne(ga *GovArea) *GovAreaDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GovAreaClient) DeleteOneID(id int64) *GovAreaDeleteOne {
	builder := c.Delete().Where(govarea.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GovAreaDeleteOne{builder}
}

// Query returns a query builder for GovArea.
func (c *GovAreaClient) Query() *GovAreaQuery {
	return &GovAreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGovArea},
		inters: c.Interceptors(),
	}
}

// Get returns a GovArea entity by its id.
func (c *GovAreaClient) Get(ctx context.Context, id int64) (*GovArea, error) {
	return c.Query().Where(govarea.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GovAreaClient) GetX(ctx context.Context, id int64) *GovArea {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GovAreaClient) Hooks() []Hook {
	return c.hooks.GovArea
}

// Interceptors returns the client interceptors.
func (c *GovAreaClient) Interceptors() []Interceptor {
	return c.inters.GovArea
}

func (c *GovAreaClient) mutate(ctx context.Context, m *GovAreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GovAreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GovAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GovAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GovAreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown GovArea mutation op: %q", m.Op())
	}
}

// GovCityClient is a client for the GovCity schema.
type GovCityClient struct {
	config
}

// NewGovCityClient returns a client for the GovCity from the given config.
func NewGovCityClient(c config) *GovCityClient {
	return &GovCityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `govcity.Hooks(f(g(h())))`.
func (c *GovCityClient) Use(hooks ...Hook) {
	c.hooks.GovCity = append(c.hooks.GovCity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `govcity.Intercept(f(g(h())))`.
func (c *GovCityClient) Intercept(interceptors ...Interceptor) {
	c.inters.GovCity = append(c.inters.GovCity, interceptors...)
}

// Create returns a builder for creating a GovCity entity.
func (c *GovCityClient) Create() *GovCityCreate {
	mutation := newGovCityMutation(c.config, OpCreate)
	return &GovCityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GovCity entities.
func (c *GovCityClient) CreateBulk(builders ...*GovCityCreate) *GovCityCreateBulk {
	return &GovCityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GovCityClient) MapCreateBulk(slice any, setFunc func(*GovCityCreate, int)) *GovCityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GovCityCreateBulk{err: fmt.Errorf("calling to GovCityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GovCityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GovCityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GovCity.
func (c *GovCityClient) Update() *GovCityUpdate {
	mutation := newGovCityMutation(c.config, OpUpdate)
	return &GovCityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GovCityClient) UpdateOne(gc *GovCity) *GovCityUpdateOne {
	mutation := newGovCityMutation(c.config, OpUpdateOne, withGovCity(gc))
	return &GovCityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GovCityClient) UpdateOneID(id int64) *GovCityUpdateOne {
	mutation := newGovCityMutation(c.config, OpUpdateOne, withGovCityID(id))
	return &GovCityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GovCity.
func (c *GovCityClient) Delete() *GovCityDelete {
	mutation := newGovCityMutation(c.config, OpDelete)
	return &GovCityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GovCityClient) DeleteOne(gc *GovCity) *GovCityDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GovCityClient) DeleteOneID(id int64) *GovCityDeleteOne {
	builder := c.Delete().Where(govcity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GovCityDeleteOne{builder}
}

// Query returns a query builder for GovCity.
func (c *GovCityClient) Query() *GovCityQuery {
	return &GovCityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGovCity},
		inters: c.Interceptors(),
	}
}

// Get returns a GovCity entity by its id.
func (c *GovCityClient) Get(ctx context.Context, id int64) (*GovCity, error) {
	return c.Query().Where(govcity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GovCityClient) GetX(ctx context.Context, id int64) *GovCity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GovCityClient) Hooks() []Hook {
	return c.hooks.GovCity
}

// Interceptors returns the client interceptors.
func (c *GovCityClient) Interceptors() []Interceptor {
	return c.inters.GovCity
}

func (c *GovCityClient) mutate(ctx context.Context, m *GovCityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GovCityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GovCityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GovCityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GovCityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown GovCity mutation op: %q", m.Op())
	}
}

// GovStreetClient is a client for the GovStreet schema.
type GovStreetClient struct {
	config
}

// NewGovStreetClient returns a client for the GovStreet from the given config.
func NewGovStreetClient(c config) *GovStreetClient {
	return &GovStreetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `govstreet.Hooks(f(g(h())))`.
func (c *GovStreetClient) Use(hooks ...Hook) {
	c.hooks.GovStreet = append(c.hooks.GovStreet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `govstreet.Intercept(f(g(h())))`.
func (c *GovStreetClient) Intercept(interceptors ...Interceptor) {
	c.inters.GovStreet = append(c.inters.GovStreet, interceptors...)
}

// Create returns a builder for creating a GovStreet entity.
func (c *GovStreetClient) Create() *GovStreetCreate {
	mutation := newGovStreetMutation(c.config, OpCreate)
	return &GovStreetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GovStreet entities.
func (c *GovStreetClient) CreateBulk(builders ...*GovStreetCreate) *GovStreetCreateBulk {
	return &GovStreetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GovStreetClient) MapCreateBulk(slice any, setFunc func(*GovStreetCreate, int)) *GovStreetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GovStreetCreateBulk{err: fmt.Errorf("calling to GovStreetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GovStreetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GovStreetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GovStreet.
func (c *GovStreetClient) Update() *GovStreetUpdate {
	mutation := newGovStreetMutation(c.config, OpUpdate)
	return &GovStreetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GovStreetClient) UpdateOne(gs *GovStreet) *GovStreetUpdateOne {
	mutation := newGovStreetMutation(c.config, OpUpdateOne, withGovStreet(gs))
	return &GovStreetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GovStreetClient) UpdateOneID(id int64) *GovStreetUpdateOne {
	mutation := newGovStreetMutation(c.config, OpUpdateOne, withGovStreetID(id))
	return &GovStreetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GovStreet.
func (c *GovStreetClient) Delete() *GovStreetDelete {
	mutation := newGovStreetMutation(c.config, OpDelete)
	return &GovStreetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GovStreetClient) DeleteOne(gs *GovStreet) *GovStreetDeleteOne {
	return c.DeleteOneID(gs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GovStreetClient) DeleteOneID(id int64) *GovStreetDeleteOne {
	builder := c.Delete().Where(govstreet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GovStreetDeleteOne{builder}
}

// Query returns a query builder for GovStreet.
func (c *GovStreetClient) Query() *GovStreetQuery {
	return &GovStreetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGovStreet},
		inters: c.Interceptors(),
	}
}

// Get returns a GovStreet entity by its id.
func (c *GovStreetClient) Get(ctx context.Context, id int64) (*GovStreet, error) {
	return c.Query().Where(govstreet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GovStreetClient) GetX(ctx context.Context, id int64) *GovStreet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GovStreetClient) Hooks() []Hook {
	return c.hooks.GovStreet
}

// Interceptors returns the client interceptors.
func (c *GovStreetClient) Interceptors() []Interceptor {
	return c.inters.GovStreet
}

func (c *GovStreetClient) mutate(ctx context.Context, m *GovStreetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GovStreetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GovStreetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GovStreetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GovStreetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown GovStreet mutation op: %q", m.Op())
	}
}

// GrouProfileTypeMappingClient is a client for the GrouProfileTypeMapping schema.
type GrouProfileTypeMappingClient struct {
	config
}

// NewGrouProfileTypeMappingClient returns a client for the GrouProfileTypeMapping from the given config.
func NewGrouProfileTypeMappingClient(c config) *GrouProfileTypeMappingClient {
	return &GrouProfileTypeMappingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grouprofiletypemapping.Hooks(f(g(h())))`.
func (c *GrouProfileTypeMappingClient) Use(hooks ...Hook) {
	c.hooks.GrouProfileTypeMapping = append(c.hooks.GrouProfileTypeMapping, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grouprofiletypemapping.Intercept(f(g(h())))`.
func (c *GrouProfileTypeMappingClient) Intercept(interceptors ...Interceptor) {
	c.inters.GrouProfileTypeMapping = append(c.inters.GrouProfileTypeMapping, interceptors...)
}

// Create returns a builder for creating a GrouProfileTypeMapping entity.
func (c *GrouProfileTypeMappingClient) Create() *GrouProfileTypeMappingCreate {
	mutation := newGrouProfileTypeMappingMutation(c.config, OpCreate)
	return &GrouProfileTypeMappingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GrouProfileTypeMapping entities.
func (c *GrouProfileTypeMappingClient) CreateBulk(builders ...*GrouProfileTypeMappingCreate) *GrouProfileTypeMappingCreateBulk {
	return &GrouProfileTypeMappingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GrouProfileTypeMappingClient) MapCreateBulk(slice any, setFunc func(*GrouProfileTypeMappingCreate, int)) *GrouProfileTypeMappingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GrouProfileTypeMappingCreateBulk{err: fmt.Errorf("calling to GrouProfileTypeMappingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GrouProfileTypeMappingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GrouProfileTypeMappingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GrouProfileTypeMapping.
func (c *GrouProfileTypeMappingClient) Update() *GrouProfileTypeMappingUpdate {
	mutation := newGrouProfileTypeMappingMutation(c.config, OpUpdate)
	return &GrouProfileTypeMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GrouProfileTypeMappingClient) UpdateOne(gptm *GrouProfileTypeMapping) *GrouProfileTypeMappingUpdateOne {
	mutation := newGrouProfileTypeMappingMutation(c.config, OpUpdateOne, withGrouProfileTypeMapping(gptm))
	return &GrouProfileTypeMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GrouProfileTypeMappingClient) UpdateOneID(id int64) *GrouProfileTypeMappingUpdateOne {
	mutation := newGrouProfileTypeMappingMutation(c.config, OpUpdateOne, withGrouProfileTypeMappingID(id))
	return &GrouProfileTypeMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GrouProfileTypeMapping.
func (c *GrouProfileTypeMappingClient) Delete() *GrouProfileTypeMappingDelete {
	mutation := newGrouProfileTypeMappingMutation(c.config, OpDelete)
	return &GrouProfileTypeMappingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GrouProfileTypeMappingClient) DeleteOne(gptm *GrouProfileTypeMapping) *GrouProfileTypeMappingDeleteOne {
	return c.DeleteOneID(gptm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GrouProfileTypeMappingClient) DeleteOneID(id int64) *GrouProfileTypeMappingDeleteOne {
	builder := c.Delete().Where(grouprofiletypemapping.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GrouProfileTypeMappingDeleteOne{builder}
}

// Query returns a query builder for GrouProfileTypeMapping.
func (c *GrouProfileTypeMappingClient) Query() *GrouProfileTypeMappingQuery {
	return &GrouProfileTypeMappingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGrouProfileTypeMapping},
		inters: c.Interceptors(),
	}
}

// Get returns a GrouProfileTypeMapping entity by its id.
func (c *GrouProfileTypeMappingClient) Get(ctx context.Context, id int64) (*GrouProfileTypeMapping, error) {
	return c.Query().Where(grouprofiletypemapping.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GrouProfileTypeMappingClient) GetX(ctx context.Context, id int64) *GrouProfileTypeMapping {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GrouProfileTypeMappingClient) Hooks() []Hook {
	return c.hooks.GrouProfileTypeMapping
}

// Interceptors returns the client interceptors.
func (c *GrouProfileTypeMappingClient) Interceptors() []Interceptor {
	return c.inters.GrouProfileTypeMapping
}

func (c *GrouProfileTypeMappingClient) mutate(ctx context.Context, m *GrouProfileTypeMappingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GrouProfileTypeMappingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GrouProfileTypeMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GrouProfileTypeMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GrouProfileTypeMappingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown GrouProfileTypeMapping mutation op: %q", m.Op())
	}
}

// ProfileTypeClient is a client for the ProfileType schema.
type ProfileTypeClient struct {
	config
}

// NewProfileTypeClient returns a client for the ProfileType from the given config.
func NewProfileTypeClient(c config) *ProfileTypeClient {
	return &ProfileTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profiletype.Hooks(f(g(h())))`.
func (c *ProfileTypeClient) Use(hooks ...Hook) {
	c.hooks.ProfileType = append(c.hooks.ProfileType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profiletype.Intercept(f(g(h())))`.
func (c *ProfileTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfileType = append(c.inters.ProfileType, interceptors...)
}

// Create returns a builder for creating a ProfileType entity.
func (c *ProfileTypeClient) Create() *ProfileTypeCreate {
	mutation := newProfileTypeMutation(c.config, OpCreate)
	return &ProfileTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfileType entities.
func (c *ProfileTypeClient) CreateBulk(builders ...*ProfileTypeCreate) *ProfileTypeCreateBulk {
	return &ProfileTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileTypeClient) MapCreateBulk(slice any, setFunc func(*ProfileTypeCreate, int)) *ProfileTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileTypeCreateBulk{err: fmt.Errorf("calling to ProfileTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfileType.
func (c *ProfileTypeClient) Update() *ProfileTypeUpdate {
	mutation := newProfileTypeMutation(c.config, OpUpdate)
	return &ProfileTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileTypeClient) UpdateOne(pt *ProfileType) *ProfileTypeUpdateOne {
	mutation := newProfileTypeMutation(c.config, OpUpdateOne, withProfileType(pt))
	return &ProfileTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileTypeClient) UpdateOneID(id int64) *ProfileTypeUpdateOne {
	mutation := newProfileTypeMutation(c.config, OpUpdateOne, withProfileTypeID(id))
	return &ProfileTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfileType.
func (c *ProfileTypeClient) Delete() *ProfileTypeDelete {
	mutation := newProfileTypeMutation(c.config, OpDelete)
	return &ProfileTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileTypeClient) DeleteOne(pt *ProfileType) *ProfileTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileTypeClient) DeleteOneID(id int64) *ProfileTypeDeleteOne {
	builder := c.Delete().Where(profiletype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileTypeDeleteOne{builder}
}

// Query returns a query builder for ProfileType.
func (c *ProfileTypeClient) Query() *ProfileTypeQuery {
	return &ProfileTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfileType},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfileType entity by its id.
func (c *ProfileTypeClient) Get(ctx context.Context, id int64) (*ProfileType, error) {
	return c.Query().Where(profiletype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileTypeClient) GetX(ctx context.Context, id int64) *ProfileType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProfileTypeClient) Hooks() []Hook {
	return c.hooks.ProfileType
}

// Interceptors returns the client interceptors.
func (c *ProfileTypeClient) Interceptors() []Interceptor {
	return c.inters.ProfileType
}

func (c *ProfileTypeClient) mutate(ctx context.Context, m *ProfileTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown ProfileType mutation op: %q", m.Op())
	}
}

// ProfilesClient is a client for the Profiles schema.
type ProfilesClient struct {
	config
}

// NewProfilesClient returns a client for the Profiles from the given config.
func NewProfilesClient(c config) *ProfilesClient {
	return &ProfilesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profiles.Hooks(f(g(h())))`.
func (c *ProfilesClient) Use(hooks ...Hook) {
	c.hooks.Profiles = append(c.hooks.Profiles, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profiles.Intercept(f(g(h())))`.
func (c *ProfilesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Profiles = append(c.inters.Profiles, interceptors...)
}

// Create returns a builder for creating a Profiles entity.
func (c *ProfilesClient) Create() *ProfilesCreate {
	mutation := newProfilesMutation(c.config, OpCreate)
	return &ProfilesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profiles entities.
func (c *ProfilesClient) CreateBulk(builders ...*ProfilesCreate) *ProfilesCreateBulk {
	return &ProfilesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfilesClient) MapCreateBulk(slice any, setFunc func(*ProfilesCreate, int)) *ProfilesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfilesCreateBulk{err: fmt.Errorf("calling to ProfilesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfilesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfilesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profiles.
func (c *ProfilesClient) Update() *ProfilesUpdate {
	mutation := newProfilesMutation(c.config, OpUpdate)
	return &ProfilesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfilesClient) UpdateOne(pr *Profiles) *ProfilesUpdateOne {
	mutation := newProfilesMutation(c.config, OpUpdateOne, withProfiles(pr))
	return &ProfilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfilesClient) UpdateOneID(id int64) *ProfilesUpdateOne {
	mutation := newProfilesMutation(c.config, OpUpdateOne, withProfilesID(id))
	return &ProfilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profiles.
func (c *ProfilesClient) Delete() *ProfilesDelete {
	mutation := newProfilesMutation(c.config, OpDelete)
	return &ProfilesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfilesClient) DeleteOne(pr *Profiles) *ProfilesDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfilesClient) DeleteOneID(id int64) *ProfilesDeleteOne {
	builder := c.Delete().Where(profiles.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfilesDeleteOne{builder}
}

// Query returns a query builder for Profiles.
func (c *ProfilesClient) Query() *ProfilesQuery {
	return &ProfilesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfiles},
		inters: c.Interceptors(),
	}
}

// Get returns a Profiles entity by its id.
func (c *ProfilesClient) Get(ctx context.Context, id int64) (*Profiles, error) {
	return c.Query().Where(profiles.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfilesClient) GetX(ctx context.Context, id int64) *Profiles {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProfilesClient) Hooks() []Hook {
	return c.hooks.Profiles
}

// Interceptors returns the client interceptors.
func (c *ProfilesClient) Interceptors() []Interceptor {
	return c.inters.Profiles
}

func (c *ProfilesClient) mutate(ctx context.Context, m *ProfilesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfilesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfilesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfilesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfilesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Profiles mutation op: %q", m.Op())
	}
}

// ProvinceClient is a client for the Province schema.
type ProvinceClient struct {
	config
}

// NewProvinceClient returns a client for the Province from the given config.
func NewProvinceClient(c config) *ProvinceClient {
	return &ProvinceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `province.Hooks(f(g(h())))`.
func (c *ProvinceClient) Use(hooks ...Hook) {
	c.hooks.Province = append(c.hooks.Province, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `province.Intercept(f(g(h())))`.
func (c *ProvinceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Province = append(c.inters.Province, interceptors...)
}

// Create returns a builder for creating a Province entity.
func (c *ProvinceClient) Create() *ProvinceCreate {
	mutation := newProvinceMutation(c.config, OpCreate)
	return &ProvinceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Province entities.
func (c *ProvinceClient) CreateBulk(builders ...*ProvinceCreate) *ProvinceCreateBulk {
	return &ProvinceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvinceClient) MapCreateBulk(slice any, setFunc func(*ProvinceCreate, int)) *ProvinceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvinceCreateBulk{err: fmt.Errorf("calling to ProvinceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvinceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvinceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Province.
func (c *ProvinceClient) Update() *ProvinceUpdate {
	mutation := newProvinceMutation(c.config, OpUpdate)
	return &ProvinceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvinceClient) UpdateOne(pr *Province) *ProvinceUpdateOne {
	mutation := newProvinceMutation(c.config, OpUpdateOne, withProvince(pr))
	return &ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvinceClient) UpdateOneID(id int64) *ProvinceUpdateOne {
	mutation := newProvinceMutation(c.config, OpUpdateOne, withProvinceID(id))
	return &ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Province.
func (c *ProvinceClient) Delete() *ProvinceDelete {
	mutation := newProvinceMutation(c.config, OpDelete)
	return &ProvinceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvinceClient) DeleteOne(pr *Province) *ProvinceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvinceClient) DeleteOneID(id int64) *ProvinceDeleteOne {
	builder := c.Delete().Where(province.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvinceDeleteOne{builder}
}

// Query returns a query builder for Province.
func (c *ProvinceClient) Query() *ProvinceQuery {
	return &ProvinceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvince},
		inters: c.Interceptors(),
	}
}

// Get returns a Province entity by its id.
func (c *ProvinceClient) Get(ctx context.Context, id int64) (*Province, error) {
	return c.Query().Where(province.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvinceClient) GetX(ctx context.Context, id int64) *Province {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProvinceClient) Hooks() []Hook {
	return c.hooks.Province
}

// Interceptors returns the client interceptors.
func (c *ProvinceClient) Interceptors() []Interceptor {
	return c.inters.Province
}

func (c *ProvinceClient) mutate(ctx context.Context, m *ProvinceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvinceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvinceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvinceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Province mutation op: %q", m.Op())
	}
}

// SqlLogClient is a client for the SqlLog schema.
type SqlLogClient struct {
	config
}

// NewSqlLogClient returns a client for the SqlLog from the given config.
func NewSqlLogClient(c config) *SqlLogClient {
	return &SqlLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sqllog.Hooks(f(g(h())))`.
func (c *SqlLogClient) Use(hooks ...Hook) {
	c.hooks.SqlLog = append(c.hooks.SqlLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sqllog.Intercept(f(g(h())))`.
func (c *SqlLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.SqlLog = append(c.inters.SqlLog, interceptors...)
}

// Create returns a builder for creating a SqlLog entity.
func (c *SqlLogClient) Create() *SqlLogCreate {
	mutation := newSqlLogMutation(c.config, OpCreate)
	return &SqlLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SqlLog entities.
func (c *SqlLogClient) CreateBulk(builders ...*SqlLogCreate) *SqlLogCreateBulk {
	return &SqlLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SqlLogClient) MapCreateBulk(slice any, setFunc func(*SqlLogCreate, int)) *SqlLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SqlLogCreateBulk{err: fmt.Errorf("calling to SqlLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SqlLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SqlLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SqlLog.
func (c *SqlLogClient) Update() *SqlLogUpdate {
	mutation := newSqlLogMutation(c.config, OpUpdate)
	return &SqlLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SqlLogClient) UpdateOne(sl *SqlLog) *SqlLogUpdateOne {
	mutation := newSqlLogMutation(c.config, OpUpdateOne, withSqlLog(sl))
	return &SqlLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SqlLogClient) UpdateOneID(id int) *SqlLogUpdateOne {
	mutation := newSqlLogMutation(c.config, OpUpdateOne, withSqlLogID(id))
	return &SqlLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SqlLog.
func (c *SqlLogClient) Delete() *SqlLogDelete {
	mutation := newSqlLogMutation(c.config, OpDelete)
	return &SqlLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SqlLogClient) DeleteOne(sl *SqlLog) *SqlLogDeleteOne {
	return c.DeleteOneID(sl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SqlLogClient) DeleteOneID(id int) *SqlLogDeleteOne {
	builder := c.Delete().Where(sqllog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SqlLogDeleteOne{builder}
}

// Query returns a query builder for SqlLog.
func (c *SqlLogClient) Query() *SqlLogQuery {
	return &SqlLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSqlLog},
		inters: c.Interceptors(),
	}
}

// Get returns a SqlLog entity by its id.
func (c *SqlLogClient) Get(ctx context.Context, id int) (*SqlLog, error) {
	return c.Query().Where(sqllog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SqlLogClient) GetX(ctx context.Context, id int) *SqlLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SqlLogClient) Hooks() []Hook {
	return c.hooks.SqlLog
}

// Interceptors returns the client interceptors.
func (c *SqlLogClient) Interceptors() []Interceptor {
	return c.inters.SqlLog
}

func (c *SqlLogClient) mutate(ctx context.Context, m *SqlLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SqlLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SqlLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SqlLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SqlLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown SqlLog mutation op: %q", m.Op())
	}
}

// TemporaryFaceClient is a client for the TemporaryFace schema.
type TemporaryFaceClient struct {
	config
}

// NewTemporaryFaceClient returns a client for the TemporaryFace from the given config.
func NewTemporaryFaceClient(c config) *TemporaryFaceClient {
	return &TemporaryFaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `temporaryface.Hooks(f(g(h())))`.
func (c *TemporaryFaceClient) Use(hooks ...Hook) {
	c.hooks.TemporaryFace = append(c.hooks.TemporaryFace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `temporaryface.Intercept(f(g(h())))`.
func (c *TemporaryFaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.TemporaryFace = append(c.inters.TemporaryFace, interceptors...)
}

// Create returns a builder for creating a TemporaryFace entity.
func (c *TemporaryFaceClient) Create() *TemporaryFaceCreate {
	mutation := newTemporaryFaceMutation(c.config, OpCreate)
	return &TemporaryFaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TemporaryFace entities.
func (c *TemporaryFaceClient) CreateBulk(builders ...*TemporaryFaceCreate) *TemporaryFaceCreateBulk {
	return &TemporaryFaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemporaryFaceClient) MapCreateBulk(slice any, setFunc func(*TemporaryFaceCreate, int)) *TemporaryFaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemporaryFaceCreateBulk{err: fmt.Errorf("calling to TemporaryFaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemporaryFaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemporaryFaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TemporaryFace.
func (c *TemporaryFaceClient) Update() *TemporaryFaceUpdate {
	mutation := newTemporaryFaceMutation(c.config, OpUpdate)
	return &TemporaryFaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemporaryFaceClient) UpdateOne(tf *TemporaryFace) *TemporaryFaceUpdateOne {
	mutation := newTemporaryFaceMutation(c.config, OpUpdateOne, withTemporaryFace(tf))
	return &TemporaryFaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemporaryFaceClient) UpdateOneID(id int64) *TemporaryFaceUpdateOne {
	mutation := newTemporaryFaceMutation(c.config, OpUpdateOne, withTemporaryFaceID(id))
	return &TemporaryFaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TemporaryFace.
func (c *TemporaryFaceClient) Delete() *TemporaryFaceDelete {
	mutation := newTemporaryFaceMutation(c.config, OpDelete)
	return &TemporaryFaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemporaryFaceClient) DeleteOne(tf *TemporaryFace) *TemporaryFaceDeleteOne {
	return c.DeleteOneID(tf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemporaryFaceClient) DeleteOneID(id int64) *TemporaryFaceDeleteOne {
	builder := c.Delete().Where(temporaryface.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemporaryFaceDeleteOne{builder}
}

// Query returns a query builder for TemporaryFace.
func (c *TemporaryFaceClient) Query() *TemporaryFaceQuery {
	return &TemporaryFaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemporaryFace},
		inters: c.Interceptors(),
	}
}

// Get returns a TemporaryFace entity by its id.
func (c *TemporaryFaceClient) Get(ctx context.Context, id int64) (*TemporaryFace, error) {
	return c.Query().Where(temporaryface.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemporaryFaceClient) GetX(ctx context.Context, id int64) *TemporaryFace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TemporaryFaceClient) Hooks() []Hook {
	return c.hooks.TemporaryFace
}

// Interceptors returns the client interceptors.
func (c *TemporaryFaceClient) Interceptors() []Interceptor {
	return c.inters.TemporaryFace
}

func (c *TemporaryFaceClient) mutate(ctx context.Context, m *TemporaryFaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemporaryFaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemporaryFaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemporaryFaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemporaryFaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown TemporaryFace mutation op: %q", m.Op())
	}
}

// TenantsClient is a client for the Tenants schema.
type TenantsClient struct {
	config
}

// NewTenantsClient returns a client for the Tenants from the given config.
func NewTenantsClient(c config) *TenantsClient {
	return &TenantsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenants.Hooks(f(g(h())))`.
func (c *TenantsClient) Use(hooks ...Hook) {
	c.hooks.Tenants = append(c.hooks.Tenants, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenants.Intercept(f(g(h())))`.
func (c *TenantsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tenants = append(c.inters.Tenants, interceptors...)
}

// Create returns a builder for creating a Tenants entity.
func (c *TenantsClient) Create() *TenantsCreate {
	mutation := newTenantsMutation(c.config, OpCreate)
	return &TenantsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tenants entities.
func (c *TenantsClient) CreateBulk(builders ...*TenantsCreate) *TenantsCreateBulk {
	return &TenantsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantsClient) MapCreateBulk(slice any, setFunc func(*TenantsCreate, int)) *TenantsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantsCreateBulk{err: fmt.Errorf("calling to TenantsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tenants.
func (c *TenantsClient) Update() *TenantsUpdate {
	mutation := newTenantsMutation(c.config, OpUpdate)
	return &TenantsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantsClient) UpdateOne(t *Tenants) *TenantsUpdateOne {
	mutation := newTenantsMutation(c.config, OpUpdateOne, withTenants(t))
	return &TenantsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantsClient) UpdateOneID(id int64) *TenantsUpdateOne {
	mutation := newTenantsMutation(c.config, OpUpdateOne, withTenantsID(id))
	return &TenantsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tenants.
func (c *TenantsClient) Delete() *TenantsDelete {
	mutation := newTenantsMutation(c.config, OpDelete)
	return &TenantsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantsClient) DeleteOne(t *Tenants) *TenantsDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantsClient) DeleteOneID(id int64) *TenantsDeleteOne {
	builder := c.Delete().Where(tenants.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantsDeleteOne{builder}
}

// Query returns a query builder for Tenants.
func (c *TenantsClient) Query() *TenantsQuery {
	return &TenantsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenants},
		inters: c.Interceptors(),
	}
}

// Get returns a Tenants entity by its id.
func (c *TenantsClient) Get(ctx context.Context, id int64) (*Tenants, error) {
	return c.Query().Where(tenants.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantsClient) GetX(ctx context.Context, id int64) *Tenants {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TenantsClient) Hooks() []Hook {
	return c.hooks.Tenants
}

// Interceptors returns the client interceptors.
func (c *TenantsClient) Interceptors() []Interceptor {
	return c.inters.Tenants
}

func (c *TenantsClient) mutate(ctx context.Context, m *TenantsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("genclients: unknown Tenants mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Alerts, Apikeys, CaptureLogs, Devices, FMPMSApi, Faces, FieldMetadata,
		FmAlertDefinition, FmAlertGroup, FmDedicatedServices, FmDemands, FmUserAccount,
		GovArea, GovCity, GovStreet, GrouProfileTypeMapping, ProfileType, Profiles,
		Province, SqlLog, TemporaryFace, Tenants []ent.Hook
	}
	inters struct {
		Alerts, Apikeys, CaptureLogs, Devices, FMPMSApi, Faces, FieldMetadata,
		FmAlertDefinition, FmAlertGroup, FmDedicatedServices, FmDemands, FmUserAccount,
		GovArea, GovCity, GovStreet, GrouProfileTypeMapping, ProfileType, Profiles,
		Province, SqlLog, TemporaryFace, Tenants []ent.Interceptor
	}
)
