// Code generated by ent, DO NOT EDIT.

package genclients

import (
	"context"
	"errors"
	"fmcam/models/schema"
	"fmcam/systems/genclients/alerts"
	"fmcam/systems/genclients/apikeys"
	"fmcam/systems/genclients/capturelogs"
	"fmcam/systems/genclients/devices"
	"fmcam/systems/genclients/faces"
	"fmcam/systems/genclients/fieldmetadata"
	"fmcam/systems/genclients/fmalertdefinition"
	"fmcam/systems/genclients/fmalertgroup"
	"fmcam/systems/genclients/fmdedicatedservices"
	"fmcam/systems/genclients/fmdemands"
	"fmcam/systems/genclients/fmpmsapi"
	"fmcam/systems/genclients/fmuseraccount"
	"fmcam/systems/genclients/govarea"
	"fmcam/systems/genclients/govcity"
	"fmcam/systems/genclients/govstreet"
	"fmcam/systems/genclients/grouprofiletypemapping"
	"fmcam/systems/genclients/predicate"
	"fmcam/systems/genclients/profiles"
	"fmcam/systems/genclients/profiletype"
	"fmcam/systems/genclients/province"
	"fmcam/systems/genclients/sqllog"
	"fmcam/systems/genclients/temporaryface"
	"fmcam/systems/genclients/tenants"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlerts                 = "Alerts"
	TypeApikeys                = "Apikeys"
	TypeCaptureLogs            = "CaptureLogs"
	TypeDevices                = "Devices"
	TypeFMPMSApi               = "FMPMSApi"
	TypeFaces                  = "Faces"
	TypeFieldMetadata          = "FieldMetadata"
	TypeFmAlertDefinition      = "FmAlertDefinition"
	TypeFmAlertGroup           = "FmAlertGroup"
	TypeFmDedicatedServices    = "FmDedicatedServices"
	TypeFmDemands              = "FmDemands"
	TypeFmUserAccount          = "FmUserAccount"
	TypeGovArea                = "GovArea"
	TypeGovCity                = "GovCity"
	TypeGovStreet              = "GovStreet"
	TypeGrouProfileTypeMapping = "GrouProfileTypeMapping"
	TypeProfileType            = "ProfileType"
	TypeProfiles               = "Profiles"
	TypeProvince               = "Province"
	TypeSqlLog                 = "SqlLog"
	TypeTemporaryFace          = "TemporaryFace"
	TypeTenants                = "Tenants"
)

// AlertsMutation represents an operation that mutates the Alerts nodes in the graph.
type AlertsMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	tenant_id         *uuid.UUID
	capture_log_id    *int64
	addcapture_log_id *int64
	device_id         *int64
	adddevice_id      *int64
	alert_level       *int8
	addalert_level    *int8
	status            *int8
	addstatus         *int8
	fm_user_id        *int64
	addfm_user_id     *int64
	handled_time      *time.Time
	remarks           *string
	created_time      *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Alerts, error)
	predicates        []predicate.Alerts
}

var _ ent.Mutation = (*AlertsMutation)(nil)

// alertsOption allows management of the mutation configuration using functional options.
type alertsOption func(*AlertsMutation)

// newAlertsMutation creates new mutation for the Alerts entity.
func newAlertsMutation(c config, op Op, opts ...alertsOption) *AlertsMutation {
	m := &AlertsMutation{
		config:        c,
		op:            op,
		typ:           TypeAlerts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertsID sets the ID field of the mutation.
func withAlertsID(id int64) alertsOption {
	return func(m *AlertsMutation) {
		var (
			err   error
			once  sync.Once
			value *Alerts
		)
		m.oldValue = func(ctx context.Context) (*Alerts, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alerts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlerts sets the old Alerts of the mutation.
func withAlerts(node *Alerts) alertsOption {
	return func(m *AlertsMutation) {
		m.oldValue = func(context.Context) (*Alerts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Alerts entities.
func (m *AlertsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alerts.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AlertsMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AlertsMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AlertsMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetCaptureLogID sets the "capture_log_id" field.
func (m *AlertsMutation) SetCaptureLogID(i int64) {
	m.capture_log_id = &i
	m.addcapture_log_id = nil
}

// CaptureLogID returns the value of the "capture_log_id" field in the mutation.
func (m *AlertsMutation) CaptureLogID() (r int64, exists bool) {
	v := m.capture_log_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCaptureLogID returns the old "capture_log_id" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldCaptureLogID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaptureLogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaptureLogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaptureLogID: %w", err)
	}
	return oldValue.CaptureLogID, nil
}

// AddCaptureLogID adds i to the "capture_log_id" field.
func (m *AlertsMutation) AddCaptureLogID(i int64) {
	if m.addcapture_log_id != nil {
		*m.addcapture_log_id += i
	} else {
		m.addcapture_log_id = &i
	}
}

// AddedCaptureLogID returns the value that was added to the "capture_log_id" field in this mutation.
func (m *AlertsMutation) AddedCaptureLogID() (r int64, exists bool) {
	v := m.addcapture_log_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaptureLogID resets all changes to the "capture_log_id" field.
func (m *AlertsMutation) ResetCaptureLogID() {
	m.capture_log_id = nil
	m.addcapture_log_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *AlertsMutation) SetDeviceID(i int64) {
	m.device_id = &i
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AlertsMutation) DeviceID() (r int64, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds i to the "device_id" field.
func (m *AlertsMutation) AddDeviceID(i int64) {
	if m.adddevice_id != nil {
		*m.adddevice_id += i
	} else {
		m.adddevice_id = &i
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *AlertsMutation) AddedDeviceID() (r int64, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AlertsMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetAlertLevel sets the "alert_level" field.
func (m *AlertsMutation) SetAlertLevel(i int8) {
	m.alert_level = &i
	m.addalert_level = nil
}

// AlertLevel returns the value of the "alert_level" field in the mutation.
func (m *AlertsMutation) AlertLevel() (r int8, exists bool) {
	v := m.alert_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertLevel returns the old "alert_level" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldAlertLevel(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertLevel: %w", err)
	}
	return oldValue.AlertLevel, nil
}

// AddAlertLevel adds i to the "alert_level" field.
func (m *AlertsMutation) AddAlertLevel(i int8) {
	if m.addalert_level != nil {
		*m.addalert_level += i
	} else {
		m.addalert_level = &i
	}
}

// AddedAlertLevel returns the value that was added to the "alert_level" field in this mutation.
func (m *AlertsMutation) AddedAlertLevel() (r int8, exists bool) {
	v := m.addalert_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlertLevel resets all changes to the "alert_level" field.
func (m *AlertsMutation) ResetAlertLevel() {
	m.alert_level = nil
	m.addalert_level = nil
}

// SetStatus sets the "status" field.
func (m *AlertsMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AlertsMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AlertsMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AlertsMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AlertsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetFmUserID sets the "fm_user_id" field.
func (m *AlertsMutation) SetFmUserID(i int64) {
	m.fm_user_id = &i
	m.addfm_user_id = nil
}

// FmUserID returns the value of the "fm_user_id" field in the mutation.
func (m *AlertsMutation) FmUserID() (r int64, exists bool) {
	v := m.fm_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFmUserID returns the old "fm_user_id" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldFmUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFmUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFmUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFmUserID: %w", err)
	}
	return oldValue.FmUserID, nil
}

// AddFmUserID adds i to the "fm_user_id" field.
func (m *AlertsMutation) AddFmUserID(i int64) {
	if m.addfm_user_id != nil {
		*m.addfm_user_id += i
	} else {
		m.addfm_user_id = &i
	}
}

// AddedFmUserID returns the value that was added to the "fm_user_id" field in this mutation.
func (m *AlertsMutation) AddedFmUserID() (r int64, exists bool) {
	v := m.addfm_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFmUserID clears the value of the "fm_user_id" field.
func (m *AlertsMutation) ClearFmUserID() {
	m.fm_user_id = nil
	m.addfm_user_id = nil
	m.clearedFields[alerts.FieldFmUserID] = struct{}{}
}

// FmUserIDCleared returns if the "fm_user_id" field was cleared in this mutation.
func (m *AlertsMutation) FmUserIDCleared() bool {
	_, ok := m.clearedFields[alerts.FieldFmUserID]
	return ok
}

// ResetFmUserID resets all changes to the "fm_user_id" field.
func (m *AlertsMutation) ResetFmUserID() {
	m.fm_user_id = nil
	m.addfm_user_id = nil
	delete(m.clearedFields, alerts.FieldFmUserID)
}

// SetHandledTime sets the "handled_time" field.
func (m *AlertsMutation) SetHandledTime(t time.Time) {
	m.handled_time = &t
}

// HandledTime returns the value of the "handled_time" field in the mutation.
func (m *AlertsMutation) HandledTime() (r time.Time, exists bool) {
	v := m.handled_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHandledTime returns the old "handled_time" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldHandledTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandledTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandledTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandledTime: %w", err)
	}
	return oldValue.HandledTime, nil
}

// ClearHandledTime clears the value of the "handled_time" field.
func (m *AlertsMutation) ClearHandledTime() {
	m.handled_time = nil
	m.clearedFields[alerts.FieldHandledTime] = struct{}{}
}

// HandledTimeCleared returns if the "handled_time" field was cleared in this mutation.
func (m *AlertsMutation) HandledTimeCleared() bool {
	_, ok := m.clearedFields[alerts.FieldHandledTime]
	return ok
}

// ResetHandledTime resets all changes to the "handled_time" field.
func (m *AlertsMutation) ResetHandledTime() {
	m.handled_time = nil
	delete(m.clearedFields, alerts.FieldHandledTime)
}

// SetRemarks sets the "remarks" field.
func (m *AlertsMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *AlertsMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *AlertsMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[alerts.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *AlertsMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[alerts.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *AlertsMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, alerts.FieldRemarks)
}

// SetCreatedTime sets the "created_time" field.
func (m *AlertsMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *AlertsMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Alerts entity.
// If the Alerts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertsMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *AlertsMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[alerts.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *AlertsMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[alerts.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *AlertsMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, alerts.FieldCreatedTime)
}

// Where appends a list predicates to the AlertsMutation builder.
func (m *AlertsMutation) Where(ps ...predicate.Alerts) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alerts, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alerts).
func (m *AlertsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant_id != nil {
		fields = append(fields, alerts.FieldTenantID)
	}
	if m.capture_log_id != nil {
		fields = append(fields, alerts.FieldCaptureLogID)
	}
	if m.device_id != nil {
		fields = append(fields, alerts.FieldDeviceID)
	}
	if m.alert_level != nil {
		fields = append(fields, alerts.FieldAlertLevel)
	}
	if m.status != nil {
		fields = append(fields, alerts.FieldStatus)
	}
	if m.fm_user_id != nil {
		fields = append(fields, alerts.FieldFmUserID)
	}
	if m.handled_time != nil {
		fields = append(fields, alerts.FieldHandledTime)
	}
	if m.remarks != nil {
		fields = append(fields, alerts.FieldRemarks)
	}
	if m.created_time != nil {
		fields = append(fields, alerts.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alerts.FieldTenantID:
		return m.TenantID()
	case alerts.FieldCaptureLogID:
		return m.CaptureLogID()
	case alerts.FieldDeviceID:
		return m.DeviceID()
	case alerts.FieldAlertLevel:
		return m.AlertLevel()
	case alerts.FieldStatus:
		return m.Status()
	case alerts.FieldFmUserID:
		return m.FmUserID()
	case alerts.FieldHandledTime:
		return m.HandledTime()
	case alerts.FieldRemarks:
		return m.Remarks()
	case alerts.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alerts.FieldTenantID:
		return m.OldTenantID(ctx)
	case alerts.FieldCaptureLogID:
		return m.OldCaptureLogID(ctx)
	case alerts.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case alerts.FieldAlertLevel:
		return m.OldAlertLevel(ctx)
	case alerts.FieldStatus:
		return m.OldStatus(ctx)
	case alerts.FieldFmUserID:
		return m.OldFmUserID(ctx)
	case alerts.FieldHandledTime:
		return m.OldHandledTime(ctx)
	case alerts.FieldRemarks:
		return m.OldRemarks(ctx)
	case alerts.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Alerts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alerts.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case alerts.FieldCaptureLogID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaptureLogID(v)
		return nil
	case alerts.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case alerts.FieldAlertLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertLevel(v)
		return nil
	case alerts.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case alerts.FieldFmUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFmUserID(v)
		return nil
	case alerts.FieldHandledTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandledTime(v)
		return nil
	case alerts.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case alerts.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Alerts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertsMutation) AddedFields() []string {
	var fields []string
	if m.addcapture_log_id != nil {
		fields = append(fields, alerts.FieldCaptureLogID)
	}
	if m.adddevice_id != nil {
		fields = append(fields, alerts.FieldDeviceID)
	}
	if m.addalert_level != nil {
		fields = append(fields, alerts.FieldAlertLevel)
	}
	if m.addstatus != nil {
		fields = append(fields, alerts.FieldStatus)
	}
	if m.addfm_user_id != nil {
		fields = append(fields, alerts.FieldFmUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alerts.FieldCaptureLogID:
		return m.AddedCaptureLogID()
	case alerts.FieldDeviceID:
		return m.AddedDeviceID()
	case alerts.FieldAlertLevel:
		return m.AddedAlertLevel()
	case alerts.FieldStatus:
		return m.AddedStatus()
	case alerts.FieldFmUserID:
		return m.AddedFmUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alerts.FieldCaptureLogID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaptureLogID(v)
		return nil
	case alerts.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	case alerts.FieldAlertLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlertLevel(v)
		return nil
	case alerts.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case alerts.FieldFmUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFmUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Alerts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alerts.FieldFmUserID) {
		fields = append(fields, alerts.FieldFmUserID)
	}
	if m.FieldCleared(alerts.FieldHandledTime) {
		fields = append(fields, alerts.FieldHandledTime)
	}
	if m.FieldCleared(alerts.FieldRemarks) {
		fields = append(fields, alerts.FieldRemarks)
	}
	if m.FieldCleared(alerts.FieldCreatedTime) {
		fields = append(fields, alerts.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertsMutation) ClearField(name string) error {
	switch name {
	case alerts.FieldFmUserID:
		m.ClearFmUserID()
		return nil
	case alerts.FieldHandledTime:
		m.ClearHandledTime()
		return nil
	case alerts.FieldRemarks:
		m.ClearRemarks()
		return nil
	case alerts.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Alerts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertsMutation) ResetField(name string) error {
	switch name {
	case alerts.FieldTenantID:
		m.ResetTenantID()
		return nil
	case alerts.FieldCaptureLogID:
		m.ResetCaptureLogID()
		return nil
	case alerts.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case alerts.FieldAlertLevel:
		m.ResetAlertLevel()
		return nil
	case alerts.FieldStatus:
		m.ResetStatus()
		return nil
	case alerts.FieldFmUserID:
		m.ResetFmUserID()
		return nil
	case alerts.FieldHandledTime:
		m.ResetHandledTime()
		return nil
	case alerts.FieldRemarks:
		m.ResetRemarks()
		return nil
	case alerts.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Alerts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Alerts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Alerts edge %s", name)
}

// ApikeysMutation represents an operation that mutates the Apikeys nodes in the graph.
type ApikeysMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	user_id        *int64
	adduser_id     *int64
	tenant_id      *uuid.UUID
	usage_count    *int64
	addusage_count *int64
	api_key        *string
	key_name       *string
	enabled        *bool
	expires_time   *time.Time
	created_time   *time.Time
	updated_time   *time.Time
	last_used_time *time.Time
	_type          *int
	add_type       *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Apikeys, error)
	predicates     []predicate.Apikeys
}

var _ ent.Mutation = (*ApikeysMutation)(nil)

// apikeysOption allows management of the mutation configuration using functional options.
type apikeysOption func(*ApikeysMutation)

// newApikeysMutation creates new mutation for the Apikeys entity.
func newApikeysMutation(c config, op Op, opts ...apikeysOption) *ApikeysMutation {
	m := &ApikeysMutation{
		config:        c,
		op:            op,
		typ:           TypeApikeys,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApikeysID sets the ID field of the mutation.
func withApikeysID(id int64) apikeysOption {
	return func(m *ApikeysMutation) {
		var (
			err   error
			once  sync.Once
			value *Apikeys
		)
		m.oldValue = func(ctx context.Context) (*Apikeys, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Apikeys.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApikeys sets the old Apikeys of the mutation.
func withApikeys(node *Apikeys) apikeysOption {
	return func(m *ApikeysMutation) {
		m.oldValue = func(context.Context) (*Apikeys, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApikeysMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApikeysMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Apikeys entities.
func (m *ApikeysMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApikeysMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApikeysMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Apikeys.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ApikeysMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApikeysMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ApikeysMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ApikeysMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApikeysMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[apikeys.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApikeysMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[apikeys.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApikeysMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, apikeys.FieldUserID)
}

// SetTenantID sets the "tenant_id" field.
func (m *ApikeysMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ApikeysMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ApikeysMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *ApikeysMutation) SetUsageCount(i int64) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *ApikeysMutation) UsageCount() (r int64, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldUsageCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *ApikeysMutation) AddUsageCount(i int64) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *ApikeysMutation) AddedUsageCount() (r int64, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *ApikeysMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetAPIKey sets the "api_key" field.
func (m *ApikeysMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *ApikeysMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *ApikeysMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetKeyName sets the "key_name" field.
func (m *ApikeysMutation) SetKeyName(s string) {
	m.key_name = &s
}

// KeyName returns the value of the "key_name" field in the mutation.
func (m *ApikeysMutation) KeyName() (r string, exists bool) {
	v := m.key_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyName returns the old "key_name" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldKeyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyName: %w", err)
	}
	return oldValue.KeyName, nil
}

// ResetKeyName resets all changes to the "key_name" field.
func (m *ApikeysMutation) ResetKeyName() {
	m.key_name = nil
}

// SetEnabled sets the "enabled" field.
func (m *ApikeysMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ApikeysMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *ApikeysMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[apikeys.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *ApikeysMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[apikeys.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ApikeysMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, apikeys.FieldEnabled)
}

// SetExpiresTime sets the "expires_time" field.
func (m *ApikeysMutation) SetExpiresTime(t time.Time) {
	m.expires_time = &t
}

// ExpiresTime returns the value of the "expires_time" field in the mutation.
func (m *ApikeysMutation) ExpiresTime() (r time.Time, exists bool) {
	v := m.expires_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresTime returns the old "expires_time" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldExpiresTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresTime: %w", err)
	}
	return oldValue.ExpiresTime, nil
}

// ResetExpiresTime resets all changes to the "expires_time" field.
func (m *ApikeysMutation) ResetExpiresTime() {
	m.expires_time = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ApikeysMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ApikeysMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ApikeysMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *ApikeysMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *ApikeysMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *ApikeysMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[apikeys.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *ApikeysMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[apikeys.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *ApikeysMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, apikeys.FieldUpdatedTime)
}

// SetLastUsedTime sets the "last_used_time" field.
func (m *ApikeysMutation) SetLastUsedTime(t time.Time) {
	m.last_used_time = &t
}

// LastUsedTime returns the value of the "last_used_time" field in the mutation.
func (m *ApikeysMutation) LastUsedTime() (r time.Time, exists bool) {
	v := m.last_used_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedTime returns the old "last_used_time" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldLastUsedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedTime: %w", err)
	}
	return oldValue.LastUsedTime, nil
}

// ClearLastUsedTime clears the value of the "last_used_time" field.
func (m *ApikeysMutation) ClearLastUsedTime() {
	m.last_used_time = nil
	m.clearedFields[apikeys.FieldLastUsedTime] = struct{}{}
}

// LastUsedTimeCleared returns if the "last_used_time" field was cleared in this mutation.
func (m *ApikeysMutation) LastUsedTimeCleared() bool {
	_, ok := m.clearedFields[apikeys.FieldLastUsedTime]
	return ok
}

// ResetLastUsedTime resets all changes to the "last_used_time" field.
func (m *ApikeysMutation) ResetLastUsedTime() {
	m.last_used_time = nil
	delete(m.clearedFields, apikeys.FieldLastUsedTime)
}

// SetType sets the "type" field.
func (m *ApikeysMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ApikeysMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Apikeys entity.
// If the Apikeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApikeysMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ApikeysMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ApikeysMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *ApikeysMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[apikeys.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ApikeysMutation) TypeCleared() bool {
	_, ok := m.clearedFields[apikeys.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ApikeysMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, apikeys.FieldType)
}

// Where appends a list predicates to the ApikeysMutation builder.
func (m *ApikeysMutation) Where(ps ...predicate.Apikeys) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApikeysMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApikeysMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Apikeys, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApikeysMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApikeysMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Apikeys).
func (m *ApikeysMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApikeysMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user_id != nil {
		fields = append(fields, apikeys.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, apikeys.FieldTenantID)
	}
	if m.usage_count != nil {
		fields = append(fields, apikeys.FieldUsageCount)
	}
	if m.api_key != nil {
		fields = append(fields, apikeys.FieldAPIKey)
	}
	if m.key_name != nil {
		fields = append(fields, apikeys.FieldKeyName)
	}
	if m.enabled != nil {
		fields = append(fields, apikeys.FieldEnabled)
	}
	if m.expires_time != nil {
		fields = append(fields, apikeys.FieldExpiresTime)
	}
	if m.created_time != nil {
		fields = append(fields, apikeys.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, apikeys.FieldUpdatedTime)
	}
	if m.last_used_time != nil {
		fields = append(fields, apikeys.FieldLastUsedTime)
	}
	if m._type != nil {
		fields = append(fields, apikeys.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApikeysMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikeys.FieldUserID:
		return m.UserID()
	case apikeys.FieldTenantID:
		return m.TenantID()
	case apikeys.FieldUsageCount:
		return m.UsageCount()
	case apikeys.FieldAPIKey:
		return m.APIKey()
	case apikeys.FieldKeyName:
		return m.KeyName()
	case apikeys.FieldEnabled:
		return m.Enabled()
	case apikeys.FieldExpiresTime:
		return m.ExpiresTime()
	case apikeys.FieldCreatedTime:
		return m.CreatedTime()
	case apikeys.FieldUpdatedTime:
		return m.UpdatedTime()
	case apikeys.FieldLastUsedTime:
		return m.LastUsedTime()
	case apikeys.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApikeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikeys.FieldUserID:
		return m.OldUserID(ctx)
	case apikeys.FieldTenantID:
		return m.OldTenantID(ctx)
	case apikeys.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case apikeys.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case apikeys.FieldKeyName:
		return m.OldKeyName(ctx)
	case apikeys.FieldEnabled:
		return m.OldEnabled(ctx)
	case apikeys.FieldExpiresTime:
		return m.OldExpiresTime(ctx)
	case apikeys.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case apikeys.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case apikeys.FieldLastUsedTime:
		return m.OldLastUsedTime(ctx)
	case apikeys.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Apikeys field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApikeysMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikeys.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikeys.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case apikeys.FieldUsageCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case apikeys.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case apikeys.FieldKeyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyName(v)
		return nil
	case apikeys.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case apikeys.FieldExpiresTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresTime(v)
		return nil
	case apikeys.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case apikeys.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case apikeys.FieldLastUsedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedTime(v)
		return nil
	case apikeys.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Apikeys field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApikeysMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, apikeys.FieldUserID)
	}
	if m.addusage_count != nil {
		fields = append(fields, apikeys.FieldUsageCount)
	}
	if m.add_type != nil {
		fields = append(fields, apikeys.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApikeysMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikeys.FieldUserID:
		return m.AddedUserID()
	case apikeys.FieldUsageCount:
		return m.AddedUsageCount()
	case apikeys.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApikeysMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikeys.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case apikeys.FieldUsageCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	case apikeys.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Apikeys numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApikeysMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikeys.FieldUserID) {
		fields = append(fields, apikeys.FieldUserID)
	}
	if m.FieldCleared(apikeys.FieldEnabled) {
		fields = append(fields, apikeys.FieldEnabled)
	}
	if m.FieldCleared(apikeys.FieldUpdatedTime) {
		fields = append(fields, apikeys.FieldUpdatedTime)
	}
	if m.FieldCleared(apikeys.FieldLastUsedTime) {
		fields = append(fields, apikeys.FieldLastUsedTime)
	}
	if m.FieldCleared(apikeys.FieldType) {
		fields = append(fields, apikeys.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApikeysMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApikeysMutation) ClearField(name string) error {
	switch name {
	case apikeys.FieldUserID:
		m.ClearUserID()
		return nil
	case apikeys.FieldEnabled:
		m.ClearEnabled()
		return nil
	case apikeys.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	case apikeys.FieldLastUsedTime:
		m.ClearLastUsedTime()
		return nil
	case apikeys.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Apikeys nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApikeysMutation) ResetField(name string) error {
	switch name {
	case apikeys.FieldUserID:
		m.ResetUserID()
		return nil
	case apikeys.FieldTenantID:
		m.ResetTenantID()
		return nil
	case apikeys.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case apikeys.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case apikeys.FieldKeyName:
		m.ResetKeyName()
		return nil
	case apikeys.FieldEnabled:
		m.ResetEnabled()
		return nil
	case apikeys.FieldExpiresTime:
		m.ResetExpiresTime()
		return nil
	case apikeys.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case apikeys.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case apikeys.FieldLastUsedTime:
		m.ResetLastUsedTime()
		return nil
	case apikeys.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Apikeys field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApikeysMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApikeysMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApikeysMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApikeysMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApikeysMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApikeysMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApikeysMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Apikeys unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApikeysMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Apikeys edge %s", name)
}

// CaptureLogsMutation represents an operation that mutates the CaptureLogs nodes in the graph.
type CaptureLogsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	tenant_id             *uuid.UUID
	device_id             *int64
	adddevice_id          *int64
	matched_profile_id    *int64
	addmatched_profile_id *int64
	func_type             *int8
	addfunc_type          *int8
	match_score           *float32
	addmatch_score        *float32
	has_alert             *bool
	device_name           *string
	device_location       *string
	content               *string
	capture_image_url     *string
	capture_time          *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*CaptureLogs, error)
	predicates            []predicate.CaptureLogs
}

var _ ent.Mutation = (*CaptureLogsMutation)(nil)

// capturelogsOption allows management of the mutation configuration using functional options.
type capturelogsOption func(*CaptureLogsMutation)

// newCaptureLogsMutation creates new mutation for the CaptureLogs entity.
func newCaptureLogsMutation(c config, op Op, opts ...capturelogsOption) *CaptureLogsMutation {
	m := &CaptureLogsMutation{
		config:        c,
		op:            op,
		typ:           TypeCaptureLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCaptureLogsID sets the ID field of the mutation.
func withCaptureLogsID(id int64) capturelogsOption {
	return func(m *CaptureLogsMutation) {
		var (
			err   error
			once  sync.Once
			value *CaptureLogs
		)
		m.oldValue = func(ctx context.Context) (*CaptureLogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CaptureLogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCaptureLogs sets the old CaptureLogs of the mutation.
func withCaptureLogs(node *CaptureLogs) capturelogsOption {
	return func(m *CaptureLogsMutation) {
		m.oldValue = func(context.Context) (*CaptureLogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CaptureLogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CaptureLogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CaptureLogs entities.
func (m *CaptureLogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CaptureLogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CaptureLogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CaptureLogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CaptureLogsMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CaptureLogsMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CaptureLogsMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CaptureLogsMutation) SetDeviceID(i int64) {
	m.device_id = &i
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CaptureLogsMutation) DeviceID() (r int64, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldDeviceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds i to the "device_id" field.
func (m *CaptureLogsMutation) AddDeviceID(i int64) {
	if m.adddevice_id != nil {
		*m.adddevice_id += i
	} else {
		m.adddevice_id = &i
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *CaptureLogsMutation) AddedDeviceID() (r int64, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CaptureLogsMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetMatchedProfileID sets the "matched_profile_id" field.
func (m *CaptureLogsMutation) SetMatchedProfileID(i int64) {
	m.matched_profile_id = &i
	m.addmatched_profile_id = nil
}

// MatchedProfileID returns the value of the "matched_profile_id" field in the mutation.
func (m *CaptureLogsMutation) MatchedProfileID() (r int64, exists bool) {
	v := m.matched_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchedProfileID returns the old "matched_profile_id" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldMatchedProfileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchedProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchedProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchedProfileID: %w", err)
	}
	return oldValue.MatchedProfileID, nil
}

// AddMatchedProfileID adds i to the "matched_profile_id" field.
func (m *CaptureLogsMutation) AddMatchedProfileID(i int64) {
	if m.addmatched_profile_id != nil {
		*m.addmatched_profile_id += i
	} else {
		m.addmatched_profile_id = &i
	}
}

// AddedMatchedProfileID returns the value that was added to the "matched_profile_id" field in this mutation.
func (m *CaptureLogsMutation) AddedMatchedProfileID() (r int64, exists bool) {
	v := m.addmatched_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMatchedProfileID resets all changes to the "matched_profile_id" field.
func (m *CaptureLogsMutation) ResetMatchedProfileID() {
	m.matched_profile_id = nil
	m.addmatched_profile_id = nil
}

// SetFuncType sets the "func_type" field.
func (m *CaptureLogsMutation) SetFuncType(i int8) {
	m.func_type = &i
	m.addfunc_type = nil
}

// FuncType returns the value of the "func_type" field in the mutation.
func (m *CaptureLogsMutation) FuncType() (r int8, exists bool) {
	v := m.func_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFuncType returns the old "func_type" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldFuncType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuncType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuncType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuncType: %w", err)
	}
	return oldValue.FuncType, nil
}

// AddFuncType adds i to the "func_type" field.
func (m *CaptureLogsMutation) AddFuncType(i int8) {
	if m.addfunc_type != nil {
		*m.addfunc_type += i
	} else {
		m.addfunc_type = &i
	}
}

// AddedFuncType returns the value that was added to the "func_type" field in this mutation.
func (m *CaptureLogsMutation) AddedFuncType() (r int8, exists bool) {
	v := m.addfunc_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearFuncType clears the value of the "func_type" field.
func (m *CaptureLogsMutation) ClearFuncType() {
	m.func_type = nil
	m.addfunc_type = nil
	m.clearedFields[capturelogs.FieldFuncType] = struct{}{}
}

// FuncTypeCleared returns if the "func_type" field was cleared in this mutation.
func (m *CaptureLogsMutation) FuncTypeCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldFuncType]
	return ok
}

// ResetFuncType resets all changes to the "func_type" field.
func (m *CaptureLogsMutation) ResetFuncType() {
	m.func_type = nil
	m.addfunc_type = nil
	delete(m.clearedFields, capturelogs.FieldFuncType)
}

// SetMatchScore sets the "match_score" field.
func (m *CaptureLogsMutation) SetMatchScore(f float32) {
	m.match_score = &f
	m.addmatch_score = nil
}

// MatchScore returns the value of the "match_score" field in the mutation.
func (m *CaptureLogsMutation) MatchScore() (r float32, exists bool) {
	v := m.match_score
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchScore returns the old "match_score" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldMatchScore(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchScore: %w", err)
	}
	return oldValue.MatchScore, nil
}

// AddMatchScore adds f to the "match_score" field.
func (m *CaptureLogsMutation) AddMatchScore(f float32) {
	if m.addmatch_score != nil {
		*m.addmatch_score += f
	} else {
		m.addmatch_score = &f
	}
}

// AddedMatchScore returns the value that was added to the "match_score" field in this mutation.
func (m *CaptureLogsMutation) AddedMatchScore() (r float32, exists bool) {
	v := m.addmatch_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearMatchScore clears the value of the "match_score" field.
func (m *CaptureLogsMutation) ClearMatchScore() {
	m.match_score = nil
	m.addmatch_score = nil
	m.clearedFields[capturelogs.FieldMatchScore] = struct{}{}
}

// MatchScoreCleared returns if the "match_score" field was cleared in this mutation.
func (m *CaptureLogsMutation) MatchScoreCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldMatchScore]
	return ok
}

// ResetMatchScore resets all changes to the "match_score" field.
func (m *CaptureLogsMutation) ResetMatchScore() {
	m.match_score = nil
	m.addmatch_score = nil
	delete(m.clearedFields, capturelogs.FieldMatchScore)
}

// SetHasAlert sets the "has_alert" field.
func (m *CaptureLogsMutation) SetHasAlert(b bool) {
	m.has_alert = &b
}

// HasAlert returns the value of the "has_alert" field in the mutation.
func (m *CaptureLogsMutation) HasAlert() (r bool, exists bool) {
	v := m.has_alert
	if v == nil {
		return
	}
	return *v, true
}

// OldHasAlert returns the old "has_alert" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldHasAlert(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasAlert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasAlert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasAlert: %w", err)
	}
	return oldValue.HasAlert, nil
}

// ResetHasAlert resets all changes to the "has_alert" field.
func (m *CaptureLogsMutation) ResetHasAlert() {
	m.has_alert = nil
}

// SetDeviceName sets the "device_name" field.
func (m *CaptureLogsMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *CaptureLogsMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldDeviceName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *CaptureLogsMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[capturelogs.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *CaptureLogsMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *CaptureLogsMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, capturelogs.FieldDeviceName)
}

// SetDeviceLocation sets the "device_location" field.
func (m *CaptureLogsMutation) SetDeviceLocation(s string) {
	m.device_location = &s
}

// DeviceLocation returns the value of the "device_location" field in the mutation.
func (m *CaptureLogsMutation) DeviceLocation() (r string, exists bool) {
	v := m.device_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceLocation returns the old "device_location" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldDeviceLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceLocation: %w", err)
	}
	return oldValue.DeviceLocation, nil
}

// ClearDeviceLocation clears the value of the "device_location" field.
func (m *CaptureLogsMutation) ClearDeviceLocation() {
	m.device_location = nil
	m.clearedFields[capturelogs.FieldDeviceLocation] = struct{}{}
}

// DeviceLocationCleared returns if the "device_location" field was cleared in this mutation.
func (m *CaptureLogsMutation) DeviceLocationCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldDeviceLocation]
	return ok
}

// ResetDeviceLocation resets all changes to the "device_location" field.
func (m *CaptureLogsMutation) ResetDeviceLocation() {
	m.device_location = nil
	delete(m.clearedFields, capturelogs.FieldDeviceLocation)
}

// SetContent sets the "content" field.
func (m *CaptureLogsMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CaptureLogsMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CaptureLogsMutation) ClearContent() {
	m.content = nil
	m.clearedFields[capturelogs.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CaptureLogsMutation) ContentCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CaptureLogsMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, capturelogs.FieldContent)
}

// SetCaptureImageURL sets the "capture_image_url" field.
func (m *CaptureLogsMutation) SetCaptureImageURL(s string) {
	m.capture_image_url = &s
}

// CaptureImageURL returns the value of the "capture_image_url" field in the mutation.
func (m *CaptureLogsMutation) CaptureImageURL() (r string, exists bool) {
	v := m.capture_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCaptureImageURL returns the old "capture_image_url" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldCaptureImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaptureImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaptureImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaptureImageURL: %w", err)
	}
	return oldValue.CaptureImageURL, nil
}

// ClearCaptureImageURL clears the value of the "capture_image_url" field.
func (m *CaptureLogsMutation) ClearCaptureImageURL() {
	m.capture_image_url = nil
	m.clearedFields[capturelogs.FieldCaptureImageURL] = struct{}{}
}

// CaptureImageURLCleared returns if the "capture_image_url" field was cleared in this mutation.
func (m *CaptureLogsMutation) CaptureImageURLCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldCaptureImageURL]
	return ok
}

// ResetCaptureImageURL resets all changes to the "capture_image_url" field.
func (m *CaptureLogsMutation) ResetCaptureImageURL() {
	m.capture_image_url = nil
	delete(m.clearedFields, capturelogs.FieldCaptureImageURL)
}

// SetCaptureTime sets the "capture_time" field.
func (m *CaptureLogsMutation) SetCaptureTime(t time.Time) {
	m.capture_time = &t
}

// CaptureTime returns the value of the "capture_time" field in the mutation.
func (m *CaptureLogsMutation) CaptureTime() (r time.Time, exists bool) {
	v := m.capture_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCaptureTime returns the old "capture_time" field's value of the CaptureLogs entity.
// If the CaptureLogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CaptureLogsMutation) OldCaptureTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaptureTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaptureTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaptureTime: %w", err)
	}
	return oldValue.CaptureTime, nil
}

// ClearCaptureTime clears the value of the "capture_time" field.
func (m *CaptureLogsMutation) ClearCaptureTime() {
	m.capture_time = nil
	m.clearedFields[capturelogs.FieldCaptureTime] = struct{}{}
}

// CaptureTimeCleared returns if the "capture_time" field was cleared in this mutation.
func (m *CaptureLogsMutation) CaptureTimeCleared() bool {
	_, ok := m.clearedFields[capturelogs.FieldCaptureTime]
	return ok
}

// ResetCaptureTime resets all changes to the "capture_time" field.
func (m *CaptureLogsMutation) ResetCaptureTime() {
	m.capture_time = nil
	delete(m.clearedFields, capturelogs.FieldCaptureTime)
}

// Where appends a list predicates to the CaptureLogsMutation builder.
func (m *CaptureLogsMutation) Where(ps ...predicate.CaptureLogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CaptureLogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CaptureLogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CaptureLogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CaptureLogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CaptureLogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CaptureLogs).
func (m *CaptureLogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CaptureLogsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant_id != nil {
		fields = append(fields, capturelogs.FieldTenantID)
	}
	if m.device_id != nil {
		fields = append(fields, capturelogs.FieldDeviceID)
	}
	if m.matched_profile_id != nil {
		fields = append(fields, capturelogs.FieldMatchedProfileID)
	}
	if m.func_type != nil {
		fields = append(fields, capturelogs.FieldFuncType)
	}
	if m.match_score != nil {
		fields = append(fields, capturelogs.FieldMatchScore)
	}
	if m.has_alert != nil {
		fields = append(fields, capturelogs.FieldHasAlert)
	}
	if m.device_name != nil {
		fields = append(fields, capturelogs.FieldDeviceName)
	}
	if m.device_location != nil {
		fields = append(fields, capturelogs.FieldDeviceLocation)
	}
	if m.content != nil {
		fields = append(fields, capturelogs.FieldContent)
	}
	if m.capture_image_url != nil {
		fields = append(fields, capturelogs.FieldCaptureImageURL)
	}
	if m.capture_time != nil {
		fields = append(fields, capturelogs.FieldCaptureTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CaptureLogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case capturelogs.FieldTenantID:
		return m.TenantID()
	case capturelogs.FieldDeviceID:
		return m.DeviceID()
	case capturelogs.FieldMatchedProfileID:
		return m.MatchedProfileID()
	case capturelogs.FieldFuncType:
		return m.FuncType()
	case capturelogs.FieldMatchScore:
		return m.MatchScore()
	case capturelogs.FieldHasAlert:
		return m.HasAlert()
	case capturelogs.FieldDeviceName:
		return m.DeviceName()
	case capturelogs.FieldDeviceLocation:
		return m.DeviceLocation()
	case capturelogs.FieldContent:
		return m.Content()
	case capturelogs.FieldCaptureImageURL:
		return m.CaptureImageURL()
	case capturelogs.FieldCaptureTime:
		return m.CaptureTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CaptureLogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case capturelogs.FieldTenantID:
		return m.OldTenantID(ctx)
	case capturelogs.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case capturelogs.FieldMatchedProfileID:
		return m.OldMatchedProfileID(ctx)
	case capturelogs.FieldFuncType:
		return m.OldFuncType(ctx)
	case capturelogs.FieldMatchScore:
		return m.OldMatchScore(ctx)
	case capturelogs.FieldHasAlert:
		return m.OldHasAlert(ctx)
	case capturelogs.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case capturelogs.FieldDeviceLocation:
		return m.OldDeviceLocation(ctx)
	case capturelogs.FieldContent:
		return m.OldContent(ctx)
	case capturelogs.FieldCaptureImageURL:
		return m.OldCaptureImageURL(ctx)
	case capturelogs.FieldCaptureTime:
		return m.OldCaptureTime(ctx)
	}
	return nil, fmt.Errorf("unknown CaptureLogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CaptureLogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case capturelogs.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case capturelogs.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case capturelogs.FieldMatchedProfileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchedProfileID(v)
		return nil
	case capturelogs.FieldFuncType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuncType(v)
		return nil
	case capturelogs.FieldMatchScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchScore(v)
		return nil
	case capturelogs.FieldHasAlert:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasAlert(v)
		return nil
	case capturelogs.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case capturelogs.FieldDeviceLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceLocation(v)
		return nil
	case capturelogs.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case capturelogs.FieldCaptureImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaptureImageURL(v)
		return nil
	case capturelogs.FieldCaptureTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaptureTime(v)
		return nil
	}
	return fmt.Errorf("unknown CaptureLogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CaptureLogsMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_id != nil {
		fields = append(fields, capturelogs.FieldDeviceID)
	}
	if m.addmatched_profile_id != nil {
		fields = append(fields, capturelogs.FieldMatchedProfileID)
	}
	if m.addfunc_type != nil {
		fields = append(fields, capturelogs.FieldFuncType)
	}
	if m.addmatch_score != nil {
		fields = append(fields, capturelogs.FieldMatchScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CaptureLogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case capturelogs.FieldDeviceID:
		return m.AddedDeviceID()
	case capturelogs.FieldMatchedProfileID:
		return m.AddedMatchedProfileID()
	case capturelogs.FieldFuncType:
		return m.AddedFuncType()
	case capturelogs.FieldMatchScore:
		return m.AddedMatchScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CaptureLogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case capturelogs.FieldDeviceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	case capturelogs.FieldMatchedProfileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMatchedProfileID(v)
		return nil
	case capturelogs.FieldFuncType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFuncType(v)
		return nil
	case capturelogs.FieldMatchScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMatchScore(v)
		return nil
	}
	return fmt.Errorf("unknown CaptureLogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CaptureLogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(capturelogs.FieldFuncType) {
		fields = append(fields, capturelogs.FieldFuncType)
	}
	if m.FieldCleared(capturelogs.FieldMatchScore) {
		fields = append(fields, capturelogs.FieldMatchScore)
	}
	if m.FieldCleared(capturelogs.FieldDeviceName) {
		fields = append(fields, capturelogs.FieldDeviceName)
	}
	if m.FieldCleared(capturelogs.FieldDeviceLocation) {
		fields = append(fields, capturelogs.FieldDeviceLocation)
	}
	if m.FieldCleared(capturelogs.FieldContent) {
		fields = append(fields, capturelogs.FieldContent)
	}
	if m.FieldCleared(capturelogs.FieldCaptureImageURL) {
		fields = append(fields, capturelogs.FieldCaptureImageURL)
	}
	if m.FieldCleared(capturelogs.FieldCaptureTime) {
		fields = append(fields, capturelogs.FieldCaptureTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CaptureLogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CaptureLogsMutation) ClearField(name string) error {
	switch name {
	case capturelogs.FieldFuncType:
		m.ClearFuncType()
		return nil
	case capturelogs.FieldMatchScore:
		m.ClearMatchScore()
		return nil
	case capturelogs.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case capturelogs.FieldDeviceLocation:
		m.ClearDeviceLocation()
		return nil
	case capturelogs.FieldContent:
		m.ClearContent()
		return nil
	case capturelogs.FieldCaptureImageURL:
		m.ClearCaptureImageURL()
		return nil
	case capturelogs.FieldCaptureTime:
		m.ClearCaptureTime()
		return nil
	}
	return fmt.Errorf("unknown CaptureLogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CaptureLogsMutation) ResetField(name string) error {
	switch name {
	case capturelogs.FieldTenantID:
		m.ResetTenantID()
		return nil
	case capturelogs.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case capturelogs.FieldMatchedProfileID:
		m.ResetMatchedProfileID()
		return nil
	case capturelogs.FieldFuncType:
		m.ResetFuncType()
		return nil
	case capturelogs.FieldMatchScore:
		m.ResetMatchScore()
		return nil
	case capturelogs.FieldHasAlert:
		m.ResetHasAlert()
		return nil
	case capturelogs.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case capturelogs.FieldDeviceLocation:
		m.ResetDeviceLocation()
		return nil
	case capturelogs.FieldContent:
		m.ResetContent()
		return nil
	case capturelogs.FieldCaptureImageURL:
		m.ResetCaptureImageURL()
		return nil
	case capturelogs.FieldCaptureTime:
		m.ResetCaptureTime()
		return nil
	}
	return fmt.Errorf("unknown CaptureLogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CaptureLogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CaptureLogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CaptureLogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CaptureLogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CaptureLogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CaptureLogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CaptureLogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CaptureLogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CaptureLogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CaptureLogs edge %s", name)
}

// DevicesMutation represents an operation that mutates the Devices nodes in the graph.
type DevicesMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	tenant_id             *uuid.UUID
	name                  *string
	url                   *string
	location              *string
	func_type             *int
	addfunc_type          *int
	display_width         *uint16
	adddisplay_width      *int16
	display_height        *uint16
	adddisplay_height     *int16
	roi_x                 *uint16
	addroi_x              *int16
	roi_y                 *uint16
	addroi_y              *int16
	roi_width             *uint16
	addroi_width          *int16
	roi_height            *uint16
	addroi_height         *int16
	roi_rotation_angle    *float64
	addroi_rotation_angle *float64
	roi_enabled           *bool
	enabled               *bool
	target_fps            *int64
	addtarget_fps         *int64
	dwell_duration        *int64
	adddwell_duration     *int64
	created_time          *time.Time
	updated_time          *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Devices, error)
	predicates            []predicate.Devices
}

var _ ent.Mutation = (*DevicesMutation)(nil)

// devicesOption allows management of the mutation configuration using functional options.
type devicesOption func(*DevicesMutation)

// newDevicesMutation creates new mutation for the Devices entity.
func newDevicesMutation(c config, op Op, opts ...devicesOption) *DevicesMutation {
	m := &DevicesMutation{
		config:        c,
		op:            op,
		typ:           TypeDevices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDevicesID sets the ID field of the mutation.
func withDevicesID(id int64) devicesOption {
	return func(m *DevicesMutation) {
		var (
			err   error
			once  sync.Once
			value *Devices
		)
		m.oldValue = func(ctx context.Context) (*Devices, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Devices.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevices sets the old Devices of the mutation.
func withDevices(node *Devices) devicesOption {
	return func(m *DevicesMutation) {
		m.oldValue = func(context.Context) (*Devices, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DevicesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DevicesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Devices entities.
func (m *DevicesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DevicesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DevicesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Devices.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DevicesMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DevicesMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DevicesMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetName sets the "name" field.
func (m *DevicesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DevicesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DevicesMutation) ClearName() {
	m.name = nil
	m.clearedFields[devices.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DevicesMutation) NameCleared() bool {
	_, ok := m.clearedFields[devices.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DevicesMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, devices.FieldName)
}

// SetURL sets the "url" field.
func (m *DevicesMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DevicesMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DevicesMutation) ResetURL() {
	m.url = nil
}

// SetLocation sets the "location" field.
func (m *DevicesMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *DevicesMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *DevicesMutation) ResetLocation() {
	m.location = nil
}

// SetFuncType sets the "func_type" field.
func (m *DevicesMutation) SetFuncType(i int) {
	m.func_type = &i
	m.addfunc_type = nil
}

// FuncType returns the value of the "func_type" field in the mutation.
func (m *DevicesMutation) FuncType() (r int, exists bool) {
	v := m.func_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFuncType returns the old "func_type" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldFuncType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuncType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuncType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuncType: %w", err)
	}
	return oldValue.FuncType, nil
}

// AddFuncType adds i to the "func_type" field.
func (m *DevicesMutation) AddFuncType(i int) {
	if m.addfunc_type != nil {
		*m.addfunc_type += i
	} else {
		m.addfunc_type = &i
	}
}

// AddedFuncType returns the value that was added to the "func_type" field in this mutation.
func (m *DevicesMutation) AddedFuncType() (r int, exists bool) {
	v := m.addfunc_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearFuncType clears the value of the "func_type" field.
func (m *DevicesMutation) ClearFuncType() {
	m.func_type = nil
	m.addfunc_type = nil
	m.clearedFields[devices.FieldFuncType] = struct{}{}
}

// FuncTypeCleared returns if the "func_type" field was cleared in this mutation.
func (m *DevicesMutation) FuncTypeCleared() bool {
	_, ok := m.clearedFields[devices.FieldFuncType]
	return ok
}

// ResetFuncType resets all changes to the "func_type" field.
func (m *DevicesMutation) ResetFuncType() {
	m.func_type = nil
	m.addfunc_type = nil
	delete(m.clearedFields, devices.FieldFuncType)
}

// SetDisplayWidth sets the "display_width" field.
func (m *DevicesMutation) SetDisplayWidth(u uint16) {
	m.display_width = &u
	m.adddisplay_width = nil
}

// DisplayWidth returns the value of the "display_width" field in the mutation.
func (m *DevicesMutation) DisplayWidth() (r uint16, exists bool) {
	v := m.display_width
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayWidth returns the old "display_width" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldDisplayWidth(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayWidth: %w", err)
	}
	return oldValue.DisplayWidth, nil
}

// AddDisplayWidth adds u to the "display_width" field.
func (m *DevicesMutation) AddDisplayWidth(u int16) {
	if m.adddisplay_width != nil {
		*m.adddisplay_width += u
	} else {
		m.adddisplay_width = &u
	}
}

// AddedDisplayWidth returns the value that was added to the "display_width" field in this mutation.
func (m *DevicesMutation) AddedDisplayWidth() (r int16, exists bool) {
	v := m.adddisplay_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayWidth clears the value of the "display_width" field.
func (m *DevicesMutation) ClearDisplayWidth() {
	m.display_width = nil
	m.adddisplay_width = nil
	m.clearedFields[devices.FieldDisplayWidth] = struct{}{}
}

// DisplayWidthCleared returns if the "display_width" field was cleared in this mutation.
func (m *DevicesMutation) DisplayWidthCleared() bool {
	_, ok := m.clearedFields[devices.FieldDisplayWidth]
	return ok
}

// ResetDisplayWidth resets all changes to the "display_width" field.
func (m *DevicesMutation) ResetDisplayWidth() {
	m.display_width = nil
	m.adddisplay_width = nil
	delete(m.clearedFields, devices.FieldDisplayWidth)
}

// SetDisplayHeight sets the "display_height" field.
func (m *DevicesMutation) SetDisplayHeight(u uint16) {
	m.display_height = &u
	m.adddisplay_height = nil
}

// DisplayHeight returns the value of the "display_height" field in the mutation.
func (m *DevicesMutation) DisplayHeight() (r uint16, exists bool) {
	v := m.display_height
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayHeight returns the old "display_height" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldDisplayHeight(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayHeight: %w", err)
	}
	return oldValue.DisplayHeight, nil
}

// AddDisplayHeight adds u to the "display_height" field.
func (m *DevicesMutation) AddDisplayHeight(u int16) {
	if m.adddisplay_height != nil {
		*m.adddisplay_height += u
	} else {
		m.adddisplay_height = &u
	}
}

// AddedDisplayHeight returns the value that was added to the "display_height" field in this mutation.
func (m *DevicesMutation) AddedDisplayHeight() (r int16, exists bool) {
	v := m.adddisplay_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayHeight clears the value of the "display_height" field.
func (m *DevicesMutation) ClearDisplayHeight() {
	m.display_height = nil
	m.adddisplay_height = nil
	m.clearedFields[devices.FieldDisplayHeight] = struct{}{}
}

// DisplayHeightCleared returns if the "display_height" field was cleared in this mutation.
func (m *DevicesMutation) DisplayHeightCleared() bool {
	_, ok := m.clearedFields[devices.FieldDisplayHeight]
	return ok
}

// ResetDisplayHeight resets all changes to the "display_height" field.
func (m *DevicesMutation) ResetDisplayHeight() {
	m.display_height = nil
	m.adddisplay_height = nil
	delete(m.clearedFields, devices.FieldDisplayHeight)
}

// SetRoiX sets the "roi_x" field.
func (m *DevicesMutation) SetRoiX(u uint16) {
	m.roi_x = &u
	m.addroi_x = nil
}

// RoiX returns the value of the "roi_x" field in the mutation.
func (m *DevicesMutation) RoiX() (r uint16, exists bool) {
	v := m.roi_x
	if v == nil {
		return
	}
	return *v, true
}

// OldRoiX returns the old "roi_x" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldRoiX(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoiX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoiX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoiX: %w", err)
	}
	return oldValue.RoiX, nil
}

// AddRoiX adds u to the "roi_x" field.
func (m *DevicesMutation) AddRoiX(u int16) {
	if m.addroi_x != nil {
		*m.addroi_x += u
	} else {
		m.addroi_x = &u
	}
}

// AddedRoiX returns the value that was added to the "roi_x" field in this mutation.
func (m *DevicesMutation) AddedRoiX() (r int16, exists bool) {
	v := m.addroi_x
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoiX clears the value of the "roi_x" field.
func (m *DevicesMutation) ClearRoiX() {
	m.roi_x = nil
	m.addroi_x = nil
	m.clearedFields[devices.FieldRoiX] = struct{}{}
}

// RoiXCleared returns if the "roi_x" field was cleared in this mutation.
func (m *DevicesMutation) RoiXCleared() bool {
	_, ok := m.clearedFields[devices.FieldRoiX]
	return ok
}

// ResetRoiX resets all changes to the "roi_x" field.
func (m *DevicesMutation) ResetRoiX() {
	m.roi_x = nil
	m.addroi_x = nil
	delete(m.clearedFields, devices.FieldRoiX)
}

// SetRoiY sets the "roi_y" field.
func (m *DevicesMutation) SetRoiY(u uint16) {
	m.roi_y = &u
	m.addroi_y = nil
}

// RoiY returns the value of the "roi_y" field in the mutation.
func (m *DevicesMutation) RoiY() (r uint16, exists bool) {
	v := m.roi_y
	if v == nil {
		return
	}
	return *v, true
}

// OldRoiY returns the old "roi_y" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldRoiY(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoiY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoiY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoiY: %w", err)
	}
	return oldValue.RoiY, nil
}

// AddRoiY adds u to the "roi_y" field.
func (m *DevicesMutation) AddRoiY(u int16) {
	if m.addroi_y != nil {
		*m.addroi_y += u
	} else {
		m.addroi_y = &u
	}
}

// AddedRoiY returns the value that was added to the "roi_y" field in this mutation.
func (m *DevicesMutation) AddedRoiY() (r int16, exists bool) {
	v := m.addroi_y
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoiY clears the value of the "roi_y" field.
func (m *DevicesMutation) ClearRoiY() {
	m.roi_y = nil
	m.addroi_y = nil
	m.clearedFields[devices.FieldRoiY] = struct{}{}
}

// RoiYCleared returns if the "roi_y" field was cleared in this mutation.
func (m *DevicesMutation) RoiYCleared() bool {
	_, ok := m.clearedFields[devices.FieldRoiY]
	return ok
}

// ResetRoiY resets all changes to the "roi_y" field.
func (m *DevicesMutation) ResetRoiY() {
	m.roi_y = nil
	m.addroi_y = nil
	delete(m.clearedFields, devices.FieldRoiY)
}

// SetRoiWidth sets the "roi_width" field.
func (m *DevicesMutation) SetRoiWidth(u uint16) {
	m.roi_width = &u
	m.addroi_width = nil
}

// RoiWidth returns the value of the "roi_width" field in the mutation.
func (m *DevicesMutation) RoiWidth() (r uint16, exists bool) {
	v := m.roi_width
	if v == nil {
		return
	}
	return *v, true
}

// OldRoiWidth returns the old "roi_width" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldRoiWidth(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoiWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoiWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoiWidth: %w", err)
	}
	return oldValue.RoiWidth, nil
}

// AddRoiWidth adds u to the "roi_width" field.
func (m *DevicesMutation) AddRoiWidth(u int16) {
	if m.addroi_width != nil {
		*m.addroi_width += u
	} else {
		m.addroi_width = &u
	}
}

// AddedRoiWidth returns the value that was added to the "roi_width" field in this mutation.
func (m *DevicesMutation) AddedRoiWidth() (r int16, exists bool) {
	v := m.addroi_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoiWidth clears the value of the "roi_width" field.
func (m *DevicesMutation) ClearRoiWidth() {
	m.roi_width = nil
	m.addroi_width = nil
	m.clearedFields[devices.FieldRoiWidth] = struct{}{}
}

// RoiWidthCleared returns if the "roi_width" field was cleared in this mutation.
func (m *DevicesMutation) RoiWidthCleared() bool {
	_, ok := m.clearedFields[devices.FieldRoiWidth]
	return ok
}

// ResetRoiWidth resets all changes to the "roi_width" field.
func (m *DevicesMutation) ResetRoiWidth() {
	m.roi_width = nil
	m.addroi_width = nil
	delete(m.clearedFields, devices.FieldRoiWidth)
}

// SetRoiHeight sets the "roi_height" field.
func (m *DevicesMutation) SetRoiHeight(u uint16) {
	m.roi_height = &u
	m.addroi_height = nil
}

// RoiHeight returns the value of the "roi_height" field in the mutation.
func (m *DevicesMutation) RoiHeight() (r uint16, exists bool) {
	v := m.roi_height
	if v == nil {
		return
	}
	return *v, true
}

// OldRoiHeight returns the old "roi_height" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldRoiHeight(ctx context.Context) (v *uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoiHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoiHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoiHeight: %w", err)
	}
	return oldValue.RoiHeight, nil
}

// AddRoiHeight adds u to the "roi_height" field.
func (m *DevicesMutation) AddRoiHeight(u int16) {
	if m.addroi_height != nil {
		*m.addroi_height += u
	} else {
		m.addroi_height = &u
	}
}

// AddedRoiHeight returns the value that was added to the "roi_height" field in this mutation.
func (m *DevicesMutation) AddedRoiHeight() (r int16, exists bool) {
	v := m.addroi_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoiHeight clears the value of the "roi_height" field.
func (m *DevicesMutation) ClearRoiHeight() {
	m.roi_height = nil
	m.addroi_height = nil
	m.clearedFields[devices.FieldRoiHeight] = struct{}{}
}

// RoiHeightCleared returns if the "roi_height" field was cleared in this mutation.
func (m *DevicesMutation) RoiHeightCleared() bool {
	_, ok := m.clearedFields[devices.FieldRoiHeight]
	return ok
}

// ResetRoiHeight resets all changes to the "roi_height" field.
func (m *DevicesMutation) ResetRoiHeight() {
	m.roi_height = nil
	m.addroi_height = nil
	delete(m.clearedFields, devices.FieldRoiHeight)
}

// SetRoiRotationAngle sets the "roi_rotation_angle" field.
func (m *DevicesMutation) SetRoiRotationAngle(f float64) {
	m.roi_rotation_angle = &f
	m.addroi_rotation_angle = nil
}

// RoiRotationAngle returns the value of the "roi_rotation_angle" field in the mutation.
func (m *DevicesMutation) RoiRotationAngle() (r float64, exists bool) {
	v := m.roi_rotation_angle
	if v == nil {
		return
	}
	return *v, true
}

// OldRoiRotationAngle returns the old "roi_rotation_angle" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldRoiRotationAngle(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoiRotationAngle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoiRotationAngle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoiRotationAngle: %w", err)
	}
	return oldValue.RoiRotationAngle, nil
}

// AddRoiRotationAngle adds f to the "roi_rotation_angle" field.
func (m *DevicesMutation) AddRoiRotationAngle(f float64) {
	if m.addroi_rotation_angle != nil {
		*m.addroi_rotation_angle += f
	} else {
		m.addroi_rotation_angle = &f
	}
}

// AddedRoiRotationAngle returns the value that was added to the "roi_rotation_angle" field in this mutation.
func (m *DevicesMutation) AddedRoiRotationAngle() (r float64, exists bool) {
	v := m.addroi_rotation_angle
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoiRotationAngle clears the value of the "roi_rotation_angle" field.
func (m *DevicesMutation) ClearRoiRotationAngle() {
	m.roi_rotation_angle = nil
	m.addroi_rotation_angle = nil
	m.clearedFields[devices.FieldRoiRotationAngle] = struct{}{}
}

// RoiRotationAngleCleared returns if the "roi_rotation_angle" field was cleared in this mutation.
func (m *DevicesMutation) RoiRotationAngleCleared() bool {
	_, ok := m.clearedFields[devices.FieldRoiRotationAngle]
	return ok
}

// ResetRoiRotationAngle resets all changes to the "roi_rotation_angle" field.
func (m *DevicesMutation) ResetRoiRotationAngle() {
	m.roi_rotation_angle = nil
	m.addroi_rotation_angle = nil
	delete(m.clearedFields, devices.FieldRoiRotationAngle)
}

// SetRoiEnabled sets the "roi_enabled" field.
func (m *DevicesMutation) SetRoiEnabled(b bool) {
	m.roi_enabled = &b
}

// RoiEnabled returns the value of the "roi_enabled" field in the mutation.
func (m *DevicesMutation) RoiEnabled() (r bool, exists bool) {
	v := m.roi_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldRoiEnabled returns the old "roi_enabled" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldRoiEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoiEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoiEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoiEnabled: %w", err)
	}
	return oldValue.RoiEnabled, nil
}

// ResetRoiEnabled resets all changes to the "roi_enabled" field.
func (m *DevicesMutation) ResetRoiEnabled() {
	m.roi_enabled = nil
}

// SetEnabled sets the "enabled" field.
func (m *DevicesMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *DevicesMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *DevicesMutation) ResetEnabled() {
	m.enabled = nil
}

// SetTargetFps sets the "target_fps" field.
func (m *DevicesMutation) SetTargetFps(i int64) {
	m.target_fps = &i
	m.addtarget_fps = nil
}

// TargetFps returns the value of the "target_fps" field in the mutation.
func (m *DevicesMutation) TargetFps() (r int64, exists bool) {
	v := m.target_fps
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetFps returns the old "target_fps" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldTargetFps(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetFps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetFps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetFps: %w", err)
	}
	return oldValue.TargetFps, nil
}

// AddTargetFps adds i to the "target_fps" field.
func (m *DevicesMutation) AddTargetFps(i int64) {
	if m.addtarget_fps != nil {
		*m.addtarget_fps += i
	} else {
		m.addtarget_fps = &i
	}
}

// AddedTargetFps returns the value that was added to the "target_fps" field in this mutation.
func (m *DevicesMutation) AddedTargetFps() (r int64, exists bool) {
	v := m.addtarget_fps
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetFps resets all changes to the "target_fps" field.
func (m *DevicesMutation) ResetTargetFps() {
	m.target_fps = nil
	m.addtarget_fps = nil
}

// SetDwellDuration sets the "dwell_duration" field.
func (m *DevicesMutation) SetDwellDuration(i int64) {
	m.dwell_duration = &i
	m.adddwell_duration = nil
}

// DwellDuration returns the value of the "dwell_duration" field in the mutation.
func (m *DevicesMutation) DwellDuration() (r int64, exists bool) {
	v := m.dwell_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDwellDuration returns the old "dwell_duration" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldDwellDuration(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDwellDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDwellDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDwellDuration: %w", err)
	}
	return oldValue.DwellDuration, nil
}

// AddDwellDuration adds i to the "dwell_duration" field.
func (m *DevicesMutation) AddDwellDuration(i int64) {
	if m.adddwell_duration != nil {
		*m.adddwell_duration += i
	} else {
		m.adddwell_duration = &i
	}
}

// AddedDwellDuration returns the value that was added to the "dwell_duration" field in this mutation.
func (m *DevicesMutation) AddedDwellDuration() (r int64, exists bool) {
	v := m.adddwell_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDwellDuration clears the value of the "dwell_duration" field.
func (m *DevicesMutation) ClearDwellDuration() {
	m.dwell_duration = nil
	m.adddwell_duration = nil
	m.clearedFields[devices.FieldDwellDuration] = struct{}{}
}

// DwellDurationCleared returns if the "dwell_duration" field was cleared in this mutation.
func (m *DevicesMutation) DwellDurationCleared() bool {
	_, ok := m.clearedFields[devices.FieldDwellDuration]
	return ok
}

// ResetDwellDuration resets all changes to the "dwell_duration" field.
func (m *DevicesMutation) ResetDwellDuration() {
	m.dwell_duration = nil
	m.adddwell_duration = nil
	delete(m.clearedFields, devices.FieldDwellDuration)
}

// SetCreatedTime sets the "created_time" field.
func (m *DevicesMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *DevicesMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *DevicesMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[devices.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *DevicesMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[devices.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *DevicesMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, devices.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *DevicesMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *DevicesMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Devices entity.
// If the Devices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicesMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *DevicesMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[devices.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *DevicesMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[devices.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *DevicesMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, devices.FieldUpdatedTime)
}

// Where appends a list predicates to the DevicesMutation builder.
func (m *DevicesMutation) Where(ps ...predicate.Devices) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DevicesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DevicesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Devices, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DevicesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DevicesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Devices).
func (m *DevicesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DevicesMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.tenant_id != nil {
		fields = append(fields, devices.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, devices.FieldName)
	}
	if m.url != nil {
		fields = append(fields, devices.FieldURL)
	}
	if m.location != nil {
		fields = append(fields, devices.FieldLocation)
	}
	if m.func_type != nil {
		fields = append(fields, devices.FieldFuncType)
	}
	if m.display_width != nil {
		fields = append(fields, devices.FieldDisplayWidth)
	}
	if m.display_height != nil {
		fields = append(fields, devices.FieldDisplayHeight)
	}
	if m.roi_x != nil {
		fields = append(fields, devices.FieldRoiX)
	}
	if m.roi_y != nil {
		fields = append(fields, devices.FieldRoiY)
	}
	if m.roi_width != nil {
		fields = append(fields, devices.FieldRoiWidth)
	}
	if m.roi_height != nil {
		fields = append(fields, devices.FieldRoiHeight)
	}
	if m.roi_rotation_angle != nil {
		fields = append(fields, devices.FieldRoiRotationAngle)
	}
	if m.roi_enabled != nil {
		fields = append(fields, devices.FieldRoiEnabled)
	}
	if m.enabled != nil {
		fields = append(fields, devices.FieldEnabled)
	}
	if m.target_fps != nil {
		fields = append(fields, devices.FieldTargetFps)
	}
	if m.dwell_duration != nil {
		fields = append(fields, devices.FieldDwellDuration)
	}
	if m.created_time != nil {
		fields = append(fields, devices.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, devices.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DevicesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devices.FieldTenantID:
		return m.TenantID()
	case devices.FieldName:
		return m.Name()
	case devices.FieldURL:
		return m.URL()
	case devices.FieldLocation:
		return m.Location()
	case devices.FieldFuncType:
		return m.FuncType()
	case devices.FieldDisplayWidth:
		return m.DisplayWidth()
	case devices.FieldDisplayHeight:
		return m.DisplayHeight()
	case devices.FieldRoiX:
		return m.RoiX()
	case devices.FieldRoiY:
		return m.RoiY()
	case devices.FieldRoiWidth:
		return m.RoiWidth()
	case devices.FieldRoiHeight:
		return m.RoiHeight()
	case devices.FieldRoiRotationAngle:
		return m.RoiRotationAngle()
	case devices.FieldRoiEnabled:
		return m.RoiEnabled()
	case devices.FieldEnabled:
		return m.Enabled()
	case devices.FieldTargetFps:
		return m.TargetFps()
	case devices.FieldDwellDuration:
		return m.DwellDuration()
	case devices.FieldCreatedTime:
		return m.CreatedTime()
	case devices.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DevicesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devices.FieldTenantID:
		return m.OldTenantID(ctx)
	case devices.FieldName:
		return m.OldName(ctx)
	case devices.FieldURL:
		return m.OldURL(ctx)
	case devices.FieldLocation:
		return m.OldLocation(ctx)
	case devices.FieldFuncType:
		return m.OldFuncType(ctx)
	case devices.FieldDisplayWidth:
		return m.OldDisplayWidth(ctx)
	case devices.FieldDisplayHeight:
		return m.OldDisplayHeight(ctx)
	case devices.FieldRoiX:
		return m.OldRoiX(ctx)
	case devices.FieldRoiY:
		return m.OldRoiY(ctx)
	case devices.FieldRoiWidth:
		return m.OldRoiWidth(ctx)
	case devices.FieldRoiHeight:
		return m.OldRoiHeight(ctx)
	case devices.FieldRoiRotationAngle:
		return m.OldRoiRotationAngle(ctx)
	case devices.FieldRoiEnabled:
		return m.OldRoiEnabled(ctx)
	case devices.FieldEnabled:
		return m.OldEnabled(ctx)
	case devices.FieldTargetFps:
		return m.OldTargetFps(ctx)
	case devices.FieldDwellDuration:
		return m.OldDwellDuration(ctx)
	case devices.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case devices.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Devices field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevicesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devices.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case devices.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case devices.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case devices.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case devices.FieldFuncType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuncType(v)
		return nil
	case devices.FieldDisplayWidth:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayWidth(v)
		return nil
	case devices.FieldDisplayHeight:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayHeight(v)
		return nil
	case devices.FieldRoiX:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoiX(v)
		return nil
	case devices.FieldRoiY:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoiY(v)
		return nil
	case devices.FieldRoiWidth:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoiWidth(v)
		return nil
	case devices.FieldRoiHeight:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoiHeight(v)
		return nil
	case devices.FieldRoiRotationAngle:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoiRotationAngle(v)
		return nil
	case devices.FieldRoiEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoiEnabled(v)
		return nil
	case devices.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case devices.FieldTargetFps:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetFps(v)
		return nil
	case devices.FieldDwellDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDwellDuration(v)
		return nil
	case devices.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case devices.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Devices field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DevicesMutation) AddedFields() []string {
	var fields []string
	if m.addfunc_type != nil {
		fields = append(fields, devices.FieldFuncType)
	}
	if m.adddisplay_width != nil {
		fields = append(fields, devices.FieldDisplayWidth)
	}
	if m.adddisplay_height != nil {
		fields = append(fields, devices.FieldDisplayHeight)
	}
	if m.addroi_x != nil {
		fields = append(fields, devices.FieldRoiX)
	}
	if m.addroi_y != nil {
		fields = append(fields, devices.FieldRoiY)
	}
	if m.addroi_width != nil {
		fields = append(fields, devices.FieldRoiWidth)
	}
	if m.addroi_height != nil {
		fields = append(fields, devices.FieldRoiHeight)
	}
	if m.addroi_rotation_angle != nil {
		fields = append(fields, devices.FieldRoiRotationAngle)
	}
	if m.addtarget_fps != nil {
		fields = append(fields, devices.FieldTargetFps)
	}
	if m.adddwell_duration != nil {
		fields = append(fields, devices.FieldDwellDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DevicesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devices.FieldFuncType:
		return m.AddedFuncType()
	case devices.FieldDisplayWidth:
		return m.AddedDisplayWidth()
	case devices.FieldDisplayHeight:
		return m.AddedDisplayHeight()
	case devices.FieldRoiX:
		return m.AddedRoiX()
	case devices.FieldRoiY:
		return m.AddedRoiY()
	case devices.FieldRoiWidth:
		return m.AddedRoiWidth()
	case devices.FieldRoiHeight:
		return m.AddedRoiHeight()
	case devices.FieldRoiRotationAngle:
		return m.AddedRoiRotationAngle()
	case devices.FieldTargetFps:
		return m.AddedTargetFps()
	case devices.FieldDwellDuration:
		return m.AddedDwellDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevicesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devices.FieldFuncType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFuncType(v)
		return nil
	case devices.FieldDisplayWidth:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayWidth(v)
		return nil
	case devices.FieldDisplayHeight:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayHeight(v)
		return nil
	case devices.FieldRoiX:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoiX(v)
		return nil
	case devices.FieldRoiY:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoiY(v)
		return nil
	case devices.FieldRoiWidth:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoiWidth(v)
		return nil
	case devices.FieldRoiHeight:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoiHeight(v)
		return nil
	case devices.FieldRoiRotationAngle:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoiRotationAngle(v)
		return nil
	case devices.FieldTargetFps:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetFps(v)
		return nil
	case devices.FieldDwellDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDwellDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Devices numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DevicesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devices.FieldName) {
		fields = append(fields, devices.FieldName)
	}
	if m.FieldCleared(devices.FieldFuncType) {
		fields = append(fields, devices.FieldFuncType)
	}
	if m.FieldCleared(devices.FieldDisplayWidth) {
		fields = append(fields, devices.FieldDisplayWidth)
	}
	if m.FieldCleared(devices.FieldDisplayHeight) {
		fields = append(fields, devices.FieldDisplayHeight)
	}
	if m.FieldCleared(devices.FieldRoiX) {
		fields = append(fields, devices.FieldRoiX)
	}
	if m.FieldCleared(devices.FieldRoiY) {
		fields = append(fields, devices.FieldRoiY)
	}
	if m.FieldCleared(devices.FieldRoiWidth) {
		fields = append(fields, devices.FieldRoiWidth)
	}
	if m.FieldCleared(devices.FieldRoiHeight) {
		fields = append(fields, devices.FieldRoiHeight)
	}
	if m.FieldCleared(devices.FieldRoiRotationAngle) {
		fields = append(fields, devices.FieldRoiRotationAngle)
	}
	if m.FieldCleared(devices.FieldDwellDuration) {
		fields = append(fields, devices.FieldDwellDuration)
	}
	if m.FieldCleared(devices.FieldCreatedTime) {
		fields = append(fields, devices.FieldCreatedTime)
	}
	if m.FieldCleared(devices.FieldUpdatedTime) {
		fields = append(fields, devices.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DevicesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DevicesMutation) ClearField(name string) error {
	switch name {
	case devices.FieldName:
		m.ClearName()
		return nil
	case devices.FieldFuncType:
		m.ClearFuncType()
		return nil
	case devices.FieldDisplayWidth:
		m.ClearDisplayWidth()
		return nil
	case devices.FieldDisplayHeight:
		m.ClearDisplayHeight()
		return nil
	case devices.FieldRoiX:
		m.ClearRoiX()
		return nil
	case devices.FieldRoiY:
		m.ClearRoiY()
		return nil
	case devices.FieldRoiWidth:
		m.ClearRoiWidth()
		return nil
	case devices.FieldRoiHeight:
		m.ClearRoiHeight()
		return nil
	case devices.FieldRoiRotationAngle:
		m.ClearRoiRotationAngle()
		return nil
	case devices.FieldDwellDuration:
		m.ClearDwellDuration()
		return nil
	case devices.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case devices.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Devices nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DevicesMutation) ResetField(name string) error {
	switch name {
	case devices.FieldTenantID:
		m.ResetTenantID()
		return nil
	case devices.FieldName:
		m.ResetName()
		return nil
	case devices.FieldURL:
		m.ResetURL()
		return nil
	case devices.FieldLocation:
		m.ResetLocation()
		return nil
	case devices.FieldFuncType:
		m.ResetFuncType()
		return nil
	case devices.FieldDisplayWidth:
		m.ResetDisplayWidth()
		return nil
	case devices.FieldDisplayHeight:
		m.ResetDisplayHeight()
		return nil
	case devices.FieldRoiX:
		m.ResetRoiX()
		return nil
	case devices.FieldRoiY:
		m.ResetRoiY()
		return nil
	case devices.FieldRoiWidth:
		m.ResetRoiWidth()
		return nil
	case devices.FieldRoiHeight:
		m.ResetRoiHeight()
		return nil
	case devices.FieldRoiRotationAngle:
		m.ResetRoiRotationAngle()
		return nil
	case devices.FieldRoiEnabled:
		m.ResetRoiEnabled()
		return nil
	case devices.FieldEnabled:
		m.ResetEnabled()
		return nil
	case devices.FieldTargetFps:
		m.ResetTargetFps()
		return nil
	case devices.FieldDwellDuration:
		m.ResetDwellDuration()
		return nil
	case devices.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case devices.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Devices field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DevicesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DevicesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DevicesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DevicesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DevicesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DevicesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DevicesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Devices unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DevicesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Devices edge %s", name)
}

// FMPMSApiMutation represents an operation that mutates the FMPMSApi nodes in the graph.
type FMPMSApiMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	pms_name      *string
	pms_api       *string
	enabled       *bool
	contact       *string
	phonenum      *string
	description   *string
	delete_flag   *string
	creator       *string
	created_time  *time.Time
	updated_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FMPMSApi, error)
	predicates    []predicate.FMPMSApi
}

var _ ent.Mutation = (*FMPMSApiMutation)(nil)

// fmpmsapiOption allows management of the mutation configuration using functional options.
type fmpmsapiOption func(*FMPMSApiMutation)

// newFMPMSApiMutation creates new mutation for the FMPMSApi entity.
func newFMPMSApiMutation(c config, op Op, opts ...fmpmsapiOption) *FMPMSApiMutation {
	m := &FMPMSApiMutation{
		config:        c,
		op:            op,
		typ:           TypeFMPMSApi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFMPMSApiID sets the ID field of the mutation.
func withFMPMSApiID(id int64) fmpmsapiOption {
	return func(m *FMPMSApiMutation) {
		var (
			err   error
			once  sync.Once
			value *FMPMSApi
		)
		m.oldValue = func(ctx context.Context) (*FMPMSApi, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FMPMSApi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFMPMSApi sets the old FMPMSApi of the mutation.
func withFMPMSApi(node *FMPMSApi) fmpmsapiOption {
	return func(m *FMPMSApiMutation) {
		m.oldValue = func(context.Context) (*FMPMSApi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FMPMSApiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FMPMSApiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FMPMSApi entities.
func (m *FMPMSApiMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FMPMSApiMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FMPMSApiMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FMPMSApi.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPmsName sets the "pms_name" field.
func (m *FMPMSApiMutation) SetPmsName(s string) {
	m.pms_name = &s
}

// PmsName returns the value of the "pms_name" field in the mutation.
func (m *FMPMSApiMutation) PmsName() (r string, exists bool) {
	v := m.pms_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPmsName returns the old "pms_name" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldPmsName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPmsName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPmsName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPmsName: %w", err)
	}
	return oldValue.PmsName, nil
}

// ResetPmsName resets all changes to the "pms_name" field.
func (m *FMPMSApiMutation) ResetPmsName() {
	m.pms_name = nil
}

// SetPmsAPI sets the "pms_api" field.
func (m *FMPMSApiMutation) SetPmsAPI(s string) {
	m.pms_api = &s
}

// PmsAPI returns the value of the "pms_api" field in the mutation.
func (m *FMPMSApiMutation) PmsAPI() (r string, exists bool) {
	v := m.pms_api
	if v == nil {
		return
	}
	return *v, true
}

// OldPmsAPI returns the old "pms_api" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldPmsAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPmsAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPmsAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPmsAPI: %w", err)
	}
	return oldValue.PmsAPI, nil
}

// ResetPmsAPI resets all changes to the "pms_api" field.
func (m *FMPMSApiMutation) ResetPmsAPI() {
	m.pms_api = nil
}

// SetEnabled sets the "enabled" field.
func (m *FMPMSApiMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FMPMSApiMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *FMPMSApiMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[fmpmsapi.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *FMPMSApiMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FMPMSApiMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, fmpmsapi.FieldEnabled)
}

// SetContact sets the "contact" field.
func (m *FMPMSApiMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *FMPMSApiMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ResetContact resets all changes to the "contact" field.
func (m *FMPMSApiMutation) ResetContact() {
	m.contact = nil
}

// SetPhonenum sets the "phonenum" field.
func (m *FMPMSApiMutation) SetPhonenum(s string) {
	m.phonenum = &s
}

// Phonenum returns the value of the "phonenum" field in the mutation.
func (m *FMPMSApiMutation) Phonenum() (r string, exists bool) {
	v := m.phonenum
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenum returns the old "phonenum" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldPhonenum(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhonenum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhonenum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenum: %w", err)
	}
	return oldValue.Phonenum, nil
}

// ClearPhonenum clears the value of the "phonenum" field.
func (m *FMPMSApiMutation) ClearPhonenum() {
	m.phonenum = nil
	m.clearedFields[fmpmsapi.FieldPhonenum] = struct{}{}
}

// PhonenumCleared returns if the "phonenum" field was cleared in this mutation.
func (m *FMPMSApiMutation) PhonenumCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldPhonenum]
	return ok
}

// ResetPhonenum resets all changes to the "phonenum" field.
func (m *FMPMSApiMutation) ResetPhonenum() {
	m.phonenum = nil
	delete(m.clearedFields, fmpmsapi.FieldPhonenum)
}

// SetDescription sets the "description" field.
func (m *FMPMSApiMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FMPMSApiMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FMPMSApiMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[fmpmsapi.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FMPMSApiMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FMPMSApiMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, fmpmsapi.FieldDescription)
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *FMPMSApiMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *FMPMSApiMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldDeleteFlag(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ClearDeleteFlag clears the value of the "delete_flag" field.
func (m *FMPMSApiMutation) ClearDeleteFlag() {
	m.delete_flag = nil
	m.clearedFields[fmpmsapi.FieldDeleteFlag] = struct{}{}
}

// DeleteFlagCleared returns if the "delete_flag" field was cleared in this mutation.
func (m *FMPMSApiMutation) DeleteFlagCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldDeleteFlag]
	return ok
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *FMPMSApiMutation) ResetDeleteFlag() {
	m.delete_flag = nil
	delete(m.clearedFields, fmpmsapi.FieldDeleteFlag)
}

// SetCreator sets the "creator" field.
func (m *FMPMSApiMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *FMPMSApiMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldCreator(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *FMPMSApiMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[fmpmsapi.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *FMPMSApiMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *FMPMSApiMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, fmpmsapi.FieldCreator)
}

// SetCreatedTime sets the "created_time" field.
func (m *FMPMSApiMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FMPMSApiMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FMPMSApiMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fmpmsapi.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FMPMSApiMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FMPMSApiMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fmpmsapi.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *FMPMSApiMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *FMPMSApiMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the FMPMSApi entity.
// If the FMPMSApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FMPMSApiMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *FMPMSApiMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[fmpmsapi.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *FMPMSApiMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[fmpmsapi.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *FMPMSApiMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, fmpmsapi.FieldUpdatedTime)
}

// Where appends a list predicates to the FMPMSApiMutation builder.
func (m *FMPMSApiMutation) Where(ps ...predicate.FMPMSApi) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FMPMSApiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FMPMSApiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FMPMSApi, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FMPMSApiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FMPMSApiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FMPMSApi).
func (m *FMPMSApiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FMPMSApiMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.pms_name != nil {
		fields = append(fields, fmpmsapi.FieldPmsName)
	}
	if m.pms_api != nil {
		fields = append(fields, fmpmsapi.FieldPmsAPI)
	}
	if m.enabled != nil {
		fields = append(fields, fmpmsapi.FieldEnabled)
	}
	if m.contact != nil {
		fields = append(fields, fmpmsapi.FieldContact)
	}
	if m.phonenum != nil {
		fields = append(fields, fmpmsapi.FieldPhonenum)
	}
	if m.description != nil {
		fields = append(fields, fmpmsapi.FieldDescription)
	}
	if m.delete_flag != nil {
		fields = append(fields, fmpmsapi.FieldDeleteFlag)
	}
	if m.creator != nil {
		fields = append(fields, fmpmsapi.FieldCreator)
	}
	if m.created_time != nil {
		fields = append(fields, fmpmsapi.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, fmpmsapi.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FMPMSApiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmpmsapi.FieldPmsName:
		return m.PmsName()
	case fmpmsapi.FieldPmsAPI:
		return m.PmsAPI()
	case fmpmsapi.FieldEnabled:
		return m.Enabled()
	case fmpmsapi.FieldContact:
		return m.Contact()
	case fmpmsapi.FieldPhonenum:
		return m.Phonenum()
	case fmpmsapi.FieldDescription:
		return m.Description()
	case fmpmsapi.FieldDeleteFlag:
		return m.DeleteFlag()
	case fmpmsapi.FieldCreator:
		return m.Creator()
	case fmpmsapi.FieldCreatedTime:
		return m.CreatedTime()
	case fmpmsapi.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FMPMSApiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmpmsapi.FieldPmsName:
		return m.OldPmsName(ctx)
	case fmpmsapi.FieldPmsAPI:
		return m.OldPmsAPI(ctx)
	case fmpmsapi.FieldEnabled:
		return m.OldEnabled(ctx)
	case fmpmsapi.FieldContact:
		return m.OldContact(ctx)
	case fmpmsapi.FieldPhonenum:
		return m.OldPhonenum(ctx)
	case fmpmsapi.FieldDescription:
		return m.OldDescription(ctx)
	case fmpmsapi.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case fmpmsapi.FieldCreator:
		return m.OldCreator(ctx)
	case fmpmsapi.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case fmpmsapi.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FMPMSApi field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FMPMSApiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmpmsapi.FieldPmsName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPmsName(v)
		return nil
	case fmpmsapi.FieldPmsAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPmsAPI(v)
		return nil
	case fmpmsapi.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case fmpmsapi.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case fmpmsapi.FieldPhonenum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenum(v)
		return nil
	case fmpmsapi.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fmpmsapi.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case fmpmsapi.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case fmpmsapi.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case fmpmsapi.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FMPMSApi field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FMPMSApiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FMPMSApiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FMPMSApiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FMPMSApi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FMPMSApiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmpmsapi.FieldEnabled) {
		fields = append(fields, fmpmsapi.FieldEnabled)
	}
	if m.FieldCleared(fmpmsapi.FieldPhonenum) {
		fields = append(fields, fmpmsapi.FieldPhonenum)
	}
	if m.FieldCleared(fmpmsapi.FieldDescription) {
		fields = append(fields, fmpmsapi.FieldDescription)
	}
	if m.FieldCleared(fmpmsapi.FieldDeleteFlag) {
		fields = append(fields, fmpmsapi.FieldDeleteFlag)
	}
	if m.FieldCleared(fmpmsapi.FieldCreator) {
		fields = append(fields, fmpmsapi.FieldCreator)
	}
	if m.FieldCleared(fmpmsapi.FieldCreatedTime) {
		fields = append(fields, fmpmsapi.FieldCreatedTime)
	}
	if m.FieldCleared(fmpmsapi.FieldUpdatedTime) {
		fields = append(fields, fmpmsapi.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FMPMSApiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FMPMSApiMutation) ClearField(name string) error {
	switch name {
	case fmpmsapi.FieldEnabled:
		m.ClearEnabled()
		return nil
	case fmpmsapi.FieldPhonenum:
		m.ClearPhonenum()
		return nil
	case fmpmsapi.FieldDescription:
		m.ClearDescription()
		return nil
	case fmpmsapi.FieldDeleteFlag:
		m.ClearDeleteFlag()
		return nil
	case fmpmsapi.FieldCreator:
		m.ClearCreator()
		return nil
	case fmpmsapi.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case fmpmsapi.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FMPMSApi nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FMPMSApiMutation) ResetField(name string) error {
	switch name {
	case fmpmsapi.FieldPmsName:
		m.ResetPmsName()
		return nil
	case fmpmsapi.FieldPmsAPI:
		m.ResetPmsAPI()
		return nil
	case fmpmsapi.FieldEnabled:
		m.ResetEnabled()
		return nil
	case fmpmsapi.FieldContact:
		m.ResetContact()
		return nil
	case fmpmsapi.FieldPhonenum:
		m.ResetPhonenum()
		return nil
	case fmpmsapi.FieldDescription:
		m.ResetDescription()
		return nil
	case fmpmsapi.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case fmpmsapi.FieldCreator:
		m.ResetCreator()
		return nil
	case fmpmsapi.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case fmpmsapi.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FMPMSApi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FMPMSApiMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FMPMSApiMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FMPMSApiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FMPMSApiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FMPMSApiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FMPMSApiMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FMPMSApiMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FMPMSApi unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FMPMSApiMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FMPMSApi edge %s", name)
}

// FacesMutation represents an operation that mutates the Faces nodes in the graph.
type FacesMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	tenant_id        *uuid.UUID
	profile_id       *int64
	addprofile_id    *int64
	face_embedding   *[]byte
	image_url        *string
	is_primary       *bool
	updated_location *string
	capture_count    *int
	addcapture_count *int
	expires_time     *time.Time
	created_time     *time.Time
	updated_time     *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Faces, error)
	predicates       []predicate.Faces
}

var _ ent.Mutation = (*FacesMutation)(nil)

// facesOption allows management of the mutation configuration using functional options.
type facesOption func(*FacesMutation)

// newFacesMutation creates new mutation for the Faces entity.
func newFacesMutation(c config, op Op, opts ...facesOption) *FacesMutation {
	m := &FacesMutation{
		config:        c,
		op:            op,
		typ:           TypeFaces,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacesID sets the ID field of the mutation.
func withFacesID(id int64) facesOption {
	return func(m *FacesMutation) {
		var (
			err   error
			once  sync.Once
			value *Faces
		)
		m.oldValue = func(ctx context.Context) (*Faces, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Faces.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaces sets the old Faces of the mutation.
func withFaces(node *Faces) facesOption {
	return func(m *FacesMutation) {
		m.oldValue = func(context.Context) (*Faces, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Faces entities.
func (m *FacesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FacesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Faces.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *FacesMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FacesMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FacesMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetProfileID sets the "profile_id" field.
func (m *FacesMutation) SetProfileID(i int64) {
	m.profile_id = &i
	m.addprofile_id = nil
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *FacesMutation) ProfileID() (r int64, exists bool) {
	v := m.profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldProfileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// AddProfileID adds i to the "profile_id" field.
func (m *FacesMutation) AddProfileID(i int64) {
	if m.addprofile_id != nil {
		*m.addprofile_id += i
	} else {
		m.addprofile_id = &i
	}
}

// AddedProfileID returns the value that was added to the "profile_id" field in this mutation.
func (m *FacesMutation) AddedProfileID() (r int64, exists bool) {
	v := m.addprofile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *FacesMutation) ResetProfileID() {
	m.profile_id = nil
	m.addprofile_id = nil
}

// SetFaceEmbedding sets the "face_embedding" field.
func (m *FacesMutation) SetFaceEmbedding(b []byte) {
	m.face_embedding = &b
}

// FaceEmbedding returns the value of the "face_embedding" field in the mutation.
func (m *FacesMutation) FaceEmbedding() (r []byte, exists bool) {
	v := m.face_embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceEmbedding returns the old "face_embedding" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldFaceEmbedding(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceEmbedding: %w", err)
	}
	return oldValue.FaceEmbedding, nil
}

// ResetFaceEmbedding resets all changes to the "face_embedding" field.
func (m *FacesMutation) ResetFaceEmbedding() {
	m.face_embedding = nil
}

// SetImageURL sets the "image_url" field.
func (m *FacesMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *FacesMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *FacesMutation) ResetImageURL() {
	m.image_url = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *FacesMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *FacesMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *FacesMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetUpdatedLocation sets the "updated_location" field.
func (m *FacesMutation) SetUpdatedLocation(s string) {
	m.updated_location = &s
}

// UpdatedLocation returns the value of the "updated_location" field in the mutation.
func (m *FacesMutation) UpdatedLocation() (r string, exists bool) {
	v := m.updated_location
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedLocation returns the old "updated_location" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldUpdatedLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedLocation: %w", err)
	}
	return oldValue.UpdatedLocation, nil
}

// ClearUpdatedLocation clears the value of the "updated_location" field.
func (m *FacesMutation) ClearUpdatedLocation() {
	m.updated_location = nil
	m.clearedFields[faces.FieldUpdatedLocation] = struct{}{}
}

// UpdatedLocationCleared returns if the "updated_location" field was cleared in this mutation.
func (m *FacesMutation) UpdatedLocationCleared() bool {
	_, ok := m.clearedFields[faces.FieldUpdatedLocation]
	return ok
}

// ResetUpdatedLocation resets all changes to the "updated_location" field.
func (m *FacesMutation) ResetUpdatedLocation() {
	m.updated_location = nil
	delete(m.clearedFields, faces.FieldUpdatedLocation)
}

// SetCaptureCount sets the "capture_count" field.
func (m *FacesMutation) SetCaptureCount(i int) {
	m.capture_count = &i
	m.addcapture_count = nil
}

// CaptureCount returns the value of the "capture_count" field in the mutation.
func (m *FacesMutation) CaptureCount() (r int, exists bool) {
	v := m.capture_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCaptureCount returns the old "capture_count" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldCaptureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaptureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaptureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaptureCount: %w", err)
	}
	return oldValue.CaptureCount, nil
}

// AddCaptureCount adds i to the "capture_count" field.
func (m *FacesMutation) AddCaptureCount(i int) {
	if m.addcapture_count != nil {
		*m.addcapture_count += i
	} else {
		m.addcapture_count = &i
	}
}

// AddedCaptureCount returns the value that was added to the "capture_count" field in this mutation.
func (m *FacesMutation) AddedCaptureCount() (r int, exists bool) {
	v := m.addcapture_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaptureCount resets all changes to the "capture_count" field.
func (m *FacesMutation) ResetCaptureCount() {
	m.capture_count = nil
	m.addcapture_count = nil
}

// SetExpiresTime sets the "expires_time" field.
func (m *FacesMutation) SetExpiresTime(t time.Time) {
	m.expires_time = &t
}

// ExpiresTime returns the value of the "expires_time" field in the mutation.
func (m *FacesMutation) ExpiresTime() (r time.Time, exists bool) {
	v := m.expires_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresTime returns the old "expires_time" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldExpiresTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresTime: %w", err)
	}
	return oldValue.ExpiresTime, nil
}

// ResetExpiresTime resets all changes to the "expires_time" field.
func (m *FacesMutation) ResetExpiresTime() {
	m.expires_time = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *FacesMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FacesMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FacesMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[faces.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FacesMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[faces.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FacesMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, faces.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *FacesMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *FacesMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Faces entity.
// If the Faces object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacesMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *FacesMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[faces.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *FacesMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[faces.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *FacesMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, faces.FieldUpdatedTime)
}

// Where appends a list predicates to the FacesMutation builder.
func (m *FacesMutation) Where(ps ...predicate.Faces) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FacesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FacesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Faces, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FacesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FacesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Faces).
func (m *FacesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.tenant_id != nil {
		fields = append(fields, faces.FieldTenantID)
	}
	if m.profile_id != nil {
		fields = append(fields, faces.FieldProfileID)
	}
	if m.face_embedding != nil {
		fields = append(fields, faces.FieldFaceEmbedding)
	}
	if m.image_url != nil {
		fields = append(fields, faces.FieldImageURL)
	}
	if m.is_primary != nil {
		fields = append(fields, faces.FieldIsPrimary)
	}
	if m.updated_location != nil {
		fields = append(fields, faces.FieldUpdatedLocation)
	}
	if m.capture_count != nil {
		fields = append(fields, faces.FieldCaptureCount)
	}
	if m.expires_time != nil {
		fields = append(fields, faces.FieldExpiresTime)
	}
	if m.created_time != nil {
		fields = append(fields, faces.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, faces.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faces.FieldTenantID:
		return m.TenantID()
	case faces.FieldProfileID:
		return m.ProfileID()
	case faces.FieldFaceEmbedding:
		return m.FaceEmbedding()
	case faces.FieldImageURL:
		return m.ImageURL()
	case faces.FieldIsPrimary:
		return m.IsPrimary()
	case faces.FieldUpdatedLocation:
		return m.UpdatedLocation()
	case faces.FieldCaptureCount:
		return m.CaptureCount()
	case faces.FieldExpiresTime:
		return m.ExpiresTime()
	case faces.FieldCreatedTime:
		return m.CreatedTime()
	case faces.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faces.FieldTenantID:
		return m.OldTenantID(ctx)
	case faces.FieldProfileID:
		return m.OldProfileID(ctx)
	case faces.FieldFaceEmbedding:
		return m.OldFaceEmbedding(ctx)
	case faces.FieldImageURL:
		return m.OldImageURL(ctx)
	case faces.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case faces.FieldUpdatedLocation:
		return m.OldUpdatedLocation(ctx)
	case faces.FieldCaptureCount:
		return m.OldCaptureCount(ctx)
	case faces.FieldExpiresTime:
		return m.OldExpiresTime(ctx)
	case faces.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case faces.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Faces field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faces.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case faces.FieldProfileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	case faces.FieldFaceEmbedding:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceEmbedding(v)
		return nil
	case faces.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case faces.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case faces.FieldUpdatedLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedLocation(v)
		return nil
	case faces.FieldCaptureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaptureCount(v)
		return nil
	case faces.FieldExpiresTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresTime(v)
		return nil
	case faces.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case faces.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Faces field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacesMutation) AddedFields() []string {
	var fields []string
	if m.addprofile_id != nil {
		fields = append(fields, faces.FieldProfileID)
	}
	if m.addcapture_count != nil {
		fields = append(fields, faces.FieldCaptureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case faces.FieldProfileID:
		return m.AddedProfileID()
	case faces.FieldCaptureCount:
		return m.AddedCaptureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case faces.FieldProfileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfileID(v)
		return nil
	case faces.FieldCaptureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaptureCount(v)
		return nil
	}
	return fmt.Errorf("unknown Faces numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(faces.FieldUpdatedLocation) {
		fields = append(fields, faces.FieldUpdatedLocation)
	}
	if m.FieldCleared(faces.FieldCreatedTime) {
		fields = append(fields, faces.FieldCreatedTime)
	}
	if m.FieldCleared(faces.FieldUpdatedTime) {
		fields = append(fields, faces.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacesMutation) ClearField(name string) error {
	switch name {
	case faces.FieldUpdatedLocation:
		m.ClearUpdatedLocation()
		return nil
	case faces.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case faces.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Faces nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacesMutation) ResetField(name string) error {
	switch name {
	case faces.FieldTenantID:
		m.ResetTenantID()
		return nil
	case faces.FieldProfileID:
		m.ResetProfileID()
		return nil
	case faces.FieldFaceEmbedding:
		m.ResetFaceEmbedding()
		return nil
	case faces.FieldImageURL:
		m.ResetImageURL()
		return nil
	case faces.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case faces.FieldUpdatedLocation:
		m.ResetUpdatedLocation()
		return nil
	case faces.FieldCaptureCount:
		m.ResetCaptureCount()
		return nil
	case faces.FieldExpiresTime:
		m.ResetExpiresTime()
		return nil
	case faces.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case faces.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Faces field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Faces unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Faces edge %s", name)
}

// FieldMetadataMutation represents an operation that mutates the FieldMetadata nodes in the graph.
type FieldMetadataMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	table_name    *string
	name          *string
	cname         *string
	data_type     *string
	is_visible    *bool
	is_searchable *bool
	is_editable   *bool
	is_required   *bool
	max_length    *int
	addmax_length *int
	default_value *string
	description   *string
	created_time  *time.Time
	updated_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FieldMetadata, error)
	predicates    []predicate.FieldMetadata
}

var _ ent.Mutation = (*FieldMetadataMutation)(nil)

// fieldmetadataOption allows management of the mutation configuration using functional options.
type fieldmetadataOption func(*FieldMetadataMutation)

// newFieldMetadataMutation creates new mutation for the FieldMetadata entity.
func newFieldMetadataMutation(c config, op Op, opts ...fieldmetadataOption) *FieldMetadataMutation {
	m := &FieldMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeFieldMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFieldMetadataID sets the ID field of the mutation.
func withFieldMetadataID(id int64) fieldmetadataOption {
	return func(m *FieldMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *FieldMetadata
		)
		m.oldValue = func(ctx context.Context) (*FieldMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FieldMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFieldMetadata sets the old FieldMetadata of the mutation.
func withFieldMetadata(node *FieldMetadata) fieldmetadataOption {
	return func(m *FieldMetadataMutation) {
		m.oldValue = func(context.Context) (*FieldMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FieldMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FieldMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FieldMetadata entities.
func (m *FieldMetadataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FieldMetadataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FieldMetadataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FieldMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTableName sets the "table_name" field.
func (m *FieldMetadataMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *FieldMetadataMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ResetTableName resets all changes to the "table_name" field.
func (m *FieldMetadataMutation) ResetTableName() {
	m.table_name = nil
}

// SetName sets the "name" field.
func (m *FieldMetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FieldMetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FieldMetadataMutation) ResetName() {
	m.name = nil
}

// SetCname sets the "cname" field.
func (m *FieldMetadataMutation) SetCname(s string) {
	m.cname = &s
}

// Cname returns the value of the "cname" field in the mutation.
func (m *FieldMetadataMutation) Cname() (r string, exists bool) {
	v := m.cname
	if v == nil {
		return
	}
	return *v, true
}

// OldCname returns the old "cname" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldCname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCname: %w", err)
	}
	return oldValue.Cname, nil
}

// ResetCname resets all changes to the "cname" field.
func (m *FieldMetadataMutation) ResetCname() {
	m.cname = nil
}

// SetDataType sets the "data_type" field.
func (m *FieldMetadataMutation) SetDataType(s string) {
	m.data_type = &s
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *FieldMetadataMutation) DataType() (r string, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ResetDataType resets all changes to the "data_type" field.
func (m *FieldMetadataMutation) ResetDataType() {
	m.data_type = nil
}

// SetIsVisible sets the "is_visible" field.
func (m *FieldMetadataMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *FieldMetadataMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *FieldMetadataMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetIsSearchable sets the "is_searchable" field.
func (m *FieldMetadataMutation) SetIsSearchable(b bool) {
	m.is_searchable = &b
}

// IsSearchable returns the value of the "is_searchable" field in the mutation.
func (m *FieldMetadataMutation) IsSearchable() (r bool, exists bool) {
	v := m.is_searchable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSearchable returns the old "is_searchable" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldIsSearchable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSearchable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSearchable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSearchable: %w", err)
	}
	return oldValue.IsSearchable, nil
}

// ResetIsSearchable resets all changes to the "is_searchable" field.
func (m *FieldMetadataMutation) ResetIsSearchable() {
	m.is_searchable = nil
}

// SetIsEditable sets the "is_editable" field.
func (m *FieldMetadataMutation) SetIsEditable(b bool) {
	m.is_editable = &b
}

// IsEditable returns the value of the "is_editable" field in the mutation.
func (m *FieldMetadataMutation) IsEditable() (r bool, exists bool) {
	v := m.is_editable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEditable returns the old "is_editable" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldIsEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEditable: %w", err)
	}
	return oldValue.IsEditable, nil
}

// ResetIsEditable resets all changes to the "is_editable" field.
func (m *FieldMetadataMutation) ResetIsEditable() {
	m.is_editable = nil
}

// SetIsRequired sets the "is_required" field.
func (m *FieldMetadataMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *FieldMetadataMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *FieldMetadataMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetMaxLength sets the "max_length" field.
func (m *FieldMetadataMutation) SetMaxLength(i int) {
	m.max_length = &i
	m.addmax_length = nil
}

// MaxLength returns the value of the "max_length" field in the mutation.
func (m *FieldMetadataMutation) MaxLength() (r int, exists bool) {
	v := m.max_length
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLength returns the old "max_length" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldMaxLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLength: %w", err)
	}
	return oldValue.MaxLength, nil
}

// AddMaxLength adds i to the "max_length" field.
func (m *FieldMetadataMutation) AddMaxLength(i int) {
	if m.addmax_length != nil {
		*m.addmax_length += i
	} else {
		m.addmax_length = &i
	}
}

// AddedMaxLength returns the value that was added to the "max_length" field in this mutation.
func (m *FieldMetadataMutation) AddedMaxLength() (r int, exists bool) {
	v := m.addmax_length
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLength resets all changes to the "max_length" field.
func (m *FieldMetadataMutation) ResetMaxLength() {
	m.max_length = nil
	m.addmax_length = nil
}

// SetDefaultValue sets the "default_value" field.
func (m *FieldMetadataMutation) SetDefaultValue(s string) {
	m.default_value = &s
}

// DefaultValue returns the value of the "default_value" field in the mutation.
func (m *FieldMetadataMutation) DefaultValue() (r string, exists bool) {
	v := m.default_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValue returns the old "default_value" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldDefaultValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValue: %w", err)
	}
	return oldValue.DefaultValue, nil
}

// ResetDefaultValue resets all changes to the "default_value" field.
func (m *FieldMetadataMutation) ResetDefaultValue() {
	m.default_value = nil
}

// SetDescription sets the "description" field.
func (m *FieldMetadataMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FieldMetadataMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FieldMetadataMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *FieldMetadataMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FieldMetadataMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FieldMetadataMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fieldmetadata.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FieldMetadataMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fieldmetadata.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FieldMetadataMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fieldmetadata.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *FieldMetadataMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *FieldMetadataMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the FieldMetadata entity.
// If the FieldMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FieldMetadataMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *FieldMetadataMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[fieldmetadata.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *FieldMetadataMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[fieldmetadata.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *FieldMetadataMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, fieldmetadata.FieldUpdatedTime)
}

// Where appends a list predicates to the FieldMetadataMutation builder.
func (m *FieldMetadataMutation) Where(ps ...predicate.FieldMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FieldMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FieldMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FieldMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FieldMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FieldMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FieldMetadata).
func (m *FieldMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FieldMetadataMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.table_name != nil {
		fields = append(fields, fieldmetadata.FieldTableName)
	}
	if m.name != nil {
		fields = append(fields, fieldmetadata.FieldName)
	}
	if m.cname != nil {
		fields = append(fields, fieldmetadata.FieldCname)
	}
	if m.data_type != nil {
		fields = append(fields, fieldmetadata.FieldDataType)
	}
	if m.is_visible != nil {
		fields = append(fields, fieldmetadata.FieldIsVisible)
	}
	if m.is_searchable != nil {
		fields = append(fields, fieldmetadata.FieldIsSearchable)
	}
	if m.is_editable != nil {
		fields = append(fields, fieldmetadata.FieldIsEditable)
	}
	if m.is_required != nil {
		fields = append(fields, fieldmetadata.FieldIsRequired)
	}
	if m.max_length != nil {
		fields = append(fields, fieldmetadata.FieldMaxLength)
	}
	if m.default_value != nil {
		fields = append(fields, fieldmetadata.FieldDefaultValue)
	}
	if m.description != nil {
		fields = append(fields, fieldmetadata.FieldDescription)
	}
	if m.created_time != nil {
		fields = append(fields, fieldmetadata.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, fieldmetadata.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FieldMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fieldmetadata.FieldTableName:
		return m.TableName()
	case fieldmetadata.FieldName:
		return m.Name()
	case fieldmetadata.FieldCname:
		return m.Cname()
	case fieldmetadata.FieldDataType:
		return m.DataType()
	case fieldmetadata.FieldIsVisible:
		return m.IsVisible()
	case fieldmetadata.FieldIsSearchable:
		return m.IsSearchable()
	case fieldmetadata.FieldIsEditable:
		return m.IsEditable()
	case fieldmetadata.FieldIsRequired:
		return m.IsRequired()
	case fieldmetadata.FieldMaxLength:
		return m.MaxLength()
	case fieldmetadata.FieldDefaultValue:
		return m.DefaultValue()
	case fieldmetadata.FieldDescription:
		return m.Description()
	case fieldmetadata.FieldCreatedTime:
		return m.CreatedTime()
	case fieldmetadata.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FieldMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fieldmetadata.FieldTableName:
		return m.OldTableName(ctx)
	case fieldmetadata.FieldName:
		return m.OldName(ctx)
	case fieldmetadata.FieldCname:
		return m.OldCname(ctx)
	case fieldmetadata.FieldDataType:
		return m.OldDataType(ctx)
	case fieldmetadata.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case fieldmetadata.FieldIsSearchable:
		return m.OldIsSearchable(ctx)
	case fieldmetadata.FieldIsEditable:
		return m.OldIsEditable(ctx)
	case fieldmetadata.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case fieldmetadata.FieldMaxLength:
		return m.OldMaxLength(ctx)
	case fieldmetadata.FieldDefaultValue:
		return m.OldDefaultValue(ctx)
	case fieldmetadata.FieldDescription:
		return m.OldDescription(ctx)
	case fieldmetadata.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case fieldmetadata.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FieldMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FieldMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fieldmetadata.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case fieldmetadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case fieldmetadata.FieldCname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCname(v)
		return nil
	case fieldmetadata.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case fieldmetadata.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case fieldmetadata.FieldIsSearchable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSearchable(v)
		return nil
	case fieldmetadata.FieldIsEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEditable(v)
		return nil
	case fieldmetadata.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case fieldmetadata.FieldMaxLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLength(v)
		return nil
	case fieldmetadata.FieldDefaultValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValue(v)
		return nil
	case fieldmetadata.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fieldmetadata.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case fieldmetadata.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FieldMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FieldMetadataMutation) AddedFields() []string {
	var fields []string
	if m.addmax_length != nil {
		fields = append(fields, fieldmetadata.FieldMaxLength)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FieldMetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fieldmetadata.FieldMaxLength:
		return m.AddedMaxLength()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FieldMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fieldmetadata.FieldMaxLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLength(v)
		return nil
	}
	return fmt.Errorf("unknown FieldMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FieldMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fieldmetadata.FieldCreatedTime) {
		fields = append(fields, fieldmetadata.FieldCreatedTime)
	}
	if m.FieldCleared(fieldmetadata.FieldUpdatedTime) {
		fields = append(fields, fieldmetadata.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FieldMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FieldMetadataMutation) ClearField(name string) error {
	switch name {
	case fieldmetadata.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case fieldmetadata.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FieldMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FieldMetadataMutation) ResetField(name string) error {
	switch name {
	case fieldmetadata.FieldTableName:
		m.ResetTableName()
		return nil
	case fieldmetadata.FieldName:
		m.ResetName()
		return nil
	case fieldmetadata.FieldCname:
		m.ResetCname()
		return nil
	case fieldmetadata.FieldDataType:
		m.ResetDataType()
		return nil
	case fieldmetadata.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case fieldmetadata.FieldIsSearchable:
		m.ResetIsSearchable()
		return nil
	case fieldmetadata.FieldIsEditable:
		m.ResetIsEditable()
		return nil
	case fieldmetadata.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case fieldmetadata.FieldMaxLength:
		m.ResetMaxLength()
		return nil
	case fieldmetadata.FieldDefaultValue:
		m.ResetDefaultValue()
		return nil
	case fieldmetadata.FieldDescription:
		m.ResetDescription()
		return nil
	case fieldmetadata.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case fieldmetadata.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FieldMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FieldMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FieldMetadataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FieldMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FieldMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FieldMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FieldMetadataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FieldMetadataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FieldMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FieldMetadataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FieldMetadata edge %s", name)
}

// FmAlertDefinitionMutation represents an operation that mutates the FmAlertDefinition nodes in the graph.
type FmAlertDefinitionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	alert_group_id     *int64
	addalert_group_id  *int64
	level              *int
	addlevel           *int
	profile_type_id    *int64
	addprofile_type_id *int64
	action             *string
	alarm_sound        *string
	created_time       *time.Time
	updated_time       *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*FmAlertDefinition, error)
	predicates         []predicate.FmAlertDefinition
}

var _ ent.Mutation = (*FmAlertDefinitionMutation)(nil)

// fmalertdefinitionOption allows management of the mutation configuration using functional options.
type fmalertdefinitionOption func(*FmAlertDefinitionMutation)

// newFmAlertDefinitionMutation creates new mutation for the FmAlertDefinition entity.
func newFmAlertDefinitionMutation(c config, op Op, opts ...fmalertdefinitionOption) *FmAlertDefinitionMutation {
	m := &FmAlertDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeFmAlertDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFmAlertDefinitionID sets the ID field of the mutation.
func withFmAlertDefinitionID(id int64) fmalertdefinitionOption {
	return func(m *FmAlertDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *FmAlertDefinition
		)
		m.oldValue = func(ctx context.Context) (*FmAlertDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FmAlertDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFmAlertDefinition sets the old FmAlertDefinition of the mutation.
func withFmAlertDefinition(node *FmAlertDefinition) fmalertdefinitionOption {
	return func(m *FmAlertDefinitionMutation) {
		m.oldValue = func(context.Context) (*FmAlertDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FmAlertDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FmAlertDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FmAlertDefinition entities.
func (m *FmAlertDefinitionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FmAlertDefinitionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FmAlertDefinitionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FmAlertDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertGroupID sets the "alert_group_id" field.
func (m *FmAlertDefinitionMutation) SetAlertGroupID(i int64) {
	m.alert_group_id = &i
	m.addalert_group_id = nil
}

// AlertGroupID returns the value of the "alert_group_id" field in the mutation.
func (m *FmAlertDefinitionMutation) AlertGroupID() (r int64, exists bool) {
	v := m.alert_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertGroupID returns the old "alert_group_id" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldAlertGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertGroupID: %w", err)
	}
	return oldValue.AlertGroupID, nil
}

// AddAlertGroupID adds i to the "alert_group_id" field.
func (m *FmAlertDefinitionMutation) AddAlertGroupID(i int64) {
	if m.addalert_group_id != nil {
		*m.addalert_group_id += i
	} else {
		m.addalert_group_id = &i
	}
}

// AddedAlertGroupID returns the value that was added to the "alert_group_id" field in this mutation.
func (m *FmAlertDefinitionMutation) AddedAlertGroupID() (r int64, exists bool) {
	v := m.addalert_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAlertGroupID clears the value of the "alert_group_id" field.
func (m *FmAlertDefinitionMutation) ClearAlertGroupID() {
	m.alert_group_id = nil
	m.addalert_group_id = nil
	m.clearedFields[fmalertdefinition.FieldAlertGroupID] = struct{}{}
}

// AlertGroupIDCleared returns if the "alert_group_id" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) AlertGroupIDCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldAlertGroupID]
	return ok
}

// ResetAlertGroupID resets all changes to the "alert_group_id" field.
func (m *FmAlertDefinitionMutation) ResetAlertGroupID() {
	m.alert_group_id = nil
	m.addalert_group_id = nil
	delete(m.clearedFields, fmalertdefinition.FieldAlertGroupID)
}

// SetLevel sets the "level" field.
func (m *FmAlertDefinitionMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *FmAlertDefinitionMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *FmAlertDefinitionMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *FmAlertDefinitionMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *FmAlertDefinitionMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[fmalertdefinition.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) LevelCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *FmAlertDefinitionMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, fmalertdefinition.FieldLevel)
}

// SetProfileTypeID sets the "profile_type_id" field.
func (m *FmAlertDefinitionMutation) SetProfileTypeID(i int64) {
	m.profile_type_id = &i
	m.addprofile_type_id = nil
}

// ProfileTypeID returns the value of the "profile_type_id" field in the mutation.
func (m *FmAlertDefinitionMutation) ProfileTypeID() (r int64, exists bool) {
	v := m.profile_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileTypeID returns the old "profile_type_id" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldProfileTypeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileTypeID: %w", err)
	}
	return oldValue.ProfileTypeID, nil
}

// AddProfileTypeID adds i to the "profile_type_id" field.
func (m *FmAlertDefinitionMutation) AddProfileTypeID(i int64) {
	if m.addprofile_type_id != nil {
		*m.addprofile_type_id += i
	} else {
		m.addprofile_type_id = &i
	}
}

// AddedProfileTypeID returns the value that was added to the "profile_type_id" field in this mutation.
func (m *FmAlertDefinitionMutation) AddedProfileTypeID() (r int64, exists bool) {
	v := m.addprofile_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfileTypeID clears the value of the "profile_type_id" field.
func (m *FmAlertDefinitionMutation) ClearProfileTypeID() {
	m.profile_type_id = nil
	m.addprofile_type_id = nil
	m.clearedFields[fmalertdefinition.FieldProfileTypeID] = struct{}{}
}

// ProfileTypeIDCleared returns if the "profile_type_id" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) ProfileTypeIDCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldProfileTypeID]
	return ok
}

// ResetProfileTypeID resets all changes to the "profile_type_id" field.
func (m *FmAlertDefinitionMutation) ResetProfileTypeID() {
	m.profile_type_id = nil
	m.addprofile_type_id = nil
	delete(m.clearedFields, fmalertdefinition.FieldProfileTypeID)
}

// SetAction sets the "action" field.
func (m *FmAlertDefinitionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *FmAlertDefinitionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *FmAlertDefinitionMutation) ClearAction() {
	m.action = nil
	m.clearedFields[fmalertdefinition.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) ActionCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *FmAlertDefinitionMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, fmalertdefinition.FieldAction)
}

// SetAlarmSound sets the "alarm_sound" field.
func (m *FmAlertDefinitionMutation) SetAlarmSound(s string) {
	m.alarm_sound = &s
}

// AlarmSound returns the value of the "alarm_sound" field in the mutation.
func (m *FmAlertDefinitionMutation) AlarmSound() (r string, exists bool) {
	v := m.alarm_sound
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmSound returns the old "alarm_sound" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldAlarmSound(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmSound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmSound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmSound: %w", err)
	}
	return oldValue.AlarmSound, nil
}

// ClearAlarmSound clears the value of the "alarm_sound" field.
func (m *FmAlertDefinitionMutation) ClearAlarmSound() {
	m.alarm_sound = nil
	m.clearedFields[fmalertdefinition.FieldAlarmSound] = struct{}{}
}

// AlarmSoundCleared returns if the "alarm_sound" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) AlarmSoundCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldAlarmSound]
	return ok
}

// ResetAlarmSound resets all changes to the "alarm_sound" field.
func (m *FmAlertDefinitionMutation) ResetAlarmSound() {
	m.alarm_sound = nil
	delete(m.clearedFields, fmalertdefinition.FieldAlarmSound)
}

// SetCreatedTime sets the "created_time" field.
func (m *FmAlertDefinitionMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FmAlertDefinitionMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FmAlertDefinitionMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fmalertdefinition.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FmAlertDefinitionMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fmalertdefinition.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *FmAlertDefinitionMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *FmAlertDefinitionMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the FmAlertDefinition entity.
// If the FmAlertDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertDefinitionMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *FmAlertDefinitionMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[fmalertdefinition.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *FmAlertDefinitionMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[fmalertdefinition.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *FmAlertDefinitionMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, fmalertdefinition.FieldUpdatedTime)
}

// Where appends a list predicates to the FmAlertDefinitionMutation builder.
func (m *FmAlertDefinitionMutation) Where(ps ...predicate.FmAlertDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FmAlertDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FmAlertDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FmAlertDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FmAlertDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FmAlertDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FmAlertDefinition).
func (m *FmAlertDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FmAlertDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.alert_group_id != nil {
		fields = append(fields, fmalertdefinition.FieldAlertGroupID)
	}
	if m.level != nil {
		fields = append(fields, fmalertdefinition.FieldLevel)
	}
	if m.profile_type_id != nil {
		fields = append(fields, fmalertdefinition.FieldProfileTypeID)
	}
	if m.action != nil {
		fields = append(fields, fmalertdefinition.FieldAction)
	}
	if m.alarm_sound != nil {
		fields = append(fields, fmalertdefinition.FieldAlarmSound)
	}
	if m.created_time != nil {
		fields = append(fields, fmalertdefinition.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, fmalertdefinition.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FmAlertDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		return m.AlertGroupID()
	case fmalertdefinition.FieldLevel:
		return m.Level()
	case fmalertdefinition.FieldProfileTypeID:
		return m.ProfileTypeID()
	case fmalertdefinition.FieldAction:
		return m.Action()
	case fmalertdefinition.FieldAlarmSound:
		return m.AlarmSound()
	case fmalertdefinition.FieldCreatedTime:
		return m.CreatedTime()
	case fmalertdefinition.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FmAlertDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		return m.OldAlertGroupID(ctx)
	case fmalertdefinition.FieldLevel:
		return m.OldLevel(ctx)
	case fmalertdefinition.FieldProfileTypeID:
		return m.OldProfileTypeID(ctx)
	case fmalertdefinition.FieldAction:
		return m.OldAction(ctx)
	case fmalertdefinition.FieldAlarmSound:
		return m.OldAlarmSound(ctx)
	case fmalertdefinition.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case fmalertdefinition.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FmAlertDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmAlertDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertGroupID(v)
		return nil
	case fmalertdefinition.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case fmalertdefinition.FieldProfileTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileTypeID(v)
		return nil
	case fmalertdefinition.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case fmalertdefinition.FieldAlarmSound:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmSound(v)
		return nil
	case fmalertdefinition.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case fmalertdefinition.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FmAlertDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FmAlertDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addalert_group_id != nil {
		fields = append(fields, fmalertdefinition.FieldAlertGroupID)
	}
	if m.addlevel != nil {
		fields = append(fields, fmalertdefinition.FieldLevel)
	}
	if m.addprofile_type_id != nil {
		fields = append(fields, fmalertdefinition.FieldProfileTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FmAlertDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		return m.AddedAlertGroupID()
	case fmalertdefinition.FieldLevel:
		return m.AddedLevel()
	case fmalertdefinition.FieldProfileTypeID:
		return m.AddedProfileTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmAlertDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlertGroupID(v)
		return nil
	case fmalertdefinition.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case fmalertdefinition.FieldProfileTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfileTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown FmAlertDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FmAlertDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmalertdefinition.FieldAlertGroupID) {
		fields = append(fields, fmalertdefinition.FieldAlertGroupID)
	}
	if m.FieldCleared(fmalertdefinition.FieldLevel) {
		fields = append(fields, fmalertdefinition.FieldLevel)
	}
	if m.FieldCleared(fmalertdefinition.FieldProfileTypeID) {
		fields = append(fields, fmalertdefinition.FieldProfileTypeID)
	}
	if m.FieldCleared(fmalertdefinition.FieldAction) {
		fields = append(fields, fmalertdefinition.FieldAction)
	}
	if m.FieldCleared(fmalertdefinition.FieldAlarmSound) {
		fields = append(fields, fmalertdefinition.FieldAlarmSound)
	}
	if m.FieldCleared(fmalertdefinition.FieldCreatedTime) {
		fields = append(fields, fmalertdefinition.FieldCreatedTime)
	}
	if m.FieldCleared(fmalertdefinition.FieldUpdatedTime) {
		fields = append(fields, fmalertdefinition.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FmAlertDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FmAlertDefinitionMutation) ClearField(name string) error {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		m.ClearAlertGroupID()
		return nil
	case fmalertdefinition.FieldLevel:
		m.ClearLevel()
		return nil
	case fmalertdefinition.FieldProfileTypeID:
		m.ClearProfileTypeID()
		return nil
	case fmalertdefinition.FieldAction:
		m.ClearAction()
		return nil
	case fmalertdefinition.FieldAlarmSound:
		m.ClearAlarmSound()
		return nil
	case fmalertdefinition.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case fmalertdefinition.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmAlertDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FmAlertDefinitionMutation) ResetField(name string) error {
	switch name {
	case fmalertdefinition.FieldAlertGroupID:
		m.ResetAlertGroupID()
		return nil
	case fmalertdefinition.FieldLevel:
		m.ResetLevel()
		return nil
	case fmalertdefinition.FieldProfileTypeID:
		m.ResetProfileTypeID()
		return nil
	case fmalertdefinition.FieldAction:
		m.ResetAction()
		return nil
	case fmalertdefinition.FieldAlarmSound:
		m.ResetAlarmSound()
		return nil
	case fmalertdefinition.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case fmalertdefinition.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmAlertDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FmAlertDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FmAlertDefinitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FmAlertDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FmAlertDefinitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FmAlertDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FmAlertDefinitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FmAlertDefinitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FmAlertDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FmAlertDefinitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FmAlertDefinition edge %s", name)
}

// FmAlertGroupMutation represents an operation that mutates the FmAlertGroup nodes in the graph.
type FmAlertGroupMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	group_name         *string
	tenant_id          *uuid.UUID
	group_type         *int8
	addgroup_type      *int8
	enabled            *bool
	customization      *string
	description        *string
	creator            *string
	uniq_enabled_group *string
	created_time       *time.Time
	updated_time       *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*FmAlertGroup, error)
	predicates         []predicate.FmAlertGroup
}

var _ ent.Mutation = (*FmAlertGroupMutation)(nil)

// fmalertgroupOption allows management of the mutation configuration using functional options.
type fmalertgroupOption func(*FmAlertGroupMutation)

// newFmAlertGroupMutation creates new mutation for the FmAlertGroup entity.
func newFmAlertGroupMutation(c config, op Op, opts ...fmalertgroupOption) *FmAlertGroupMutation {
	m := &FmAlertGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFmAlertGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFmAlertGroupID sets the ID field of the mutation.
func withFmAlertGroupID(id int64) fmalertgroupOption {
	return func(m *FmAlertGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FmAlertGroup
		)
		m.oldValue = func(ctx context.Context) (*FmAlertGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FmAlertGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFmAlertGroup sets the old FmAlertGroup of the mutation.
func withFmAlertGroup(node *FmAlertGroup) fmalertgroupOption {
	return func(m *FmAlertGroupMutation) {
		m.oldValue = func(context.Context) (*FmAlertGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FmAlertGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FmAlertGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FmAlertGroup entities.
func (m *FmAlertGroupMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FmAlertGroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FmAlertGroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FmAlertGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupName sets the "group_name" field.
func (m *FmAlertGroupMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *FmAlertGroupMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *FmAlertGroupMutation) ResetGroupName() {
	m.group_name = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *FmAlertGroupMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FmAlertGroupMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FmAlertGroupMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetGroupType sets the "group_type" field.
func (m *FmAlertGroupMutation) SetGroupType(i int8) {
	m.group_type = &i
	m.addgroup_type = nil
}

// GroupType returns the value of the "group_type" field in the mutation.
func (m *FmAlertGroupMutation) GroupType() (r int8, exists bool) {
	v := m.group_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupType returns the old "group_type" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldGroupType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupType: %w", err)
	}
	return oldValue.GroupType, nil
}

// AddGroupType adds i to the "group_type" field.
func (m *FmAlertGroupMutation) AddGroupType(i int8) {
	if m.addgroup_type != nil {
		*m.addgroup_type += i
	} else {
		m.addgroup_type = &i
	}
}

// AddedGroupType returns the value that was added to the "group_type" field in this mutation.
func (m *FmAlertGroupMutation) AddedGroupType() (r int8, exists bool) {
	v := m.addgroup_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupType clears the value of the "group_type" field.
func (m *FmAlertGroupMutation) ClearGroupType() {
	m.group_type = nil
	m.addgroup_type = nil
	m.clearedFields[fmalertgroup.FieldGroupType] = struct{}{}
}

// GroupTypeCleared returns if the "group_type" field was cleared in this mutation.
func (m *FmAlertGroupMutation) GroupTypeCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldGroupType]
	return ok
}

// ResetGroupType resets all changes to the "group_type" field.
func (m *FmAlertGroupMutation) ResetGroupType() {
	m.group_type = nil
	m.addgroup_type = nil
	delete(m.clearedFields, fmalertgroup.FieldGroupType)
}

// SetEnabled sets the "enabled" field.
func (m *FmAlertGroupMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FmAlertGroupMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *FmAlertGroupMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[fmalertgroup.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *FmAlertGroupMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FmAlertGroupMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, fmalertgroup.FieldEnabled)
}

// SetCustomization sets the "customization" field.
func (m *FmAlertGroupMutation) SetCustomization(s string) {
	m.customization = &s
}

// Customization returns the value of the "customization" field in the mutation.
func (m *FmAlertGroupMutation) Customization() (r string, exists bool) {
	v := m.customization
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomization returns the old "customization" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldCustomization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomization: %w", err)
	}
	return oldValue.Customization, nil
}

// ClearCustomization clears the value of the "customization" field.
func (m *FmAlertGroupMutation) ClearCustomization() {
	m.customization = nil
	m.clearedFields[fmalertgroup.FieldCustomization] = struct{}{}
}

// CustomizationCleared returns if the "customization" field was cleared in this mutation.
func (m *FmAlertGroupMutation) CustomizationCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldCustomization]
	return ok
}

// ResetCustomization resets all changes to the "customization" field.
func (m *FmAlertGroupMutation) ResetCustomization() {
	m.customization = nil
	delete(m.clearedFields, fmalertgroup.FieldCustomization)
}

// SetDescription sets the "description" field.
func (m *FmAlertGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FmAlertGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FmAlertGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[fmalertgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FmAlertGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FmAlertGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, fmalertgroup.FieldDescription)
}

// SetCreator sets the "creator" field.
func (m *FmAlertGroupMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *FmAlertGroupMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *FmAlertGroupMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[fmalertgroup.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *FmAlertGroupMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *FmAlertGroupMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, fmalertgroup.FieldCreator)
}

// SetUniqEnabledGroup sets the "uniq_enabled_group" field.
func (m *FmAlertGroupMutation) SetUniqEnabledGroup(s string) {
	m.uniq_enabled_group = &s
}

// UniqEnabledGroup returns the value of the "uniq_enabled_group" field in the mutation.
func (m *FmAlertGroupMutation) UniqEnabledGroup() (r string, exists bool) {
	v := m.uniq_enabled_group
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqEnabledGroup returns the old "uniq_enabled_group" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldUniqEnabledGroup(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqEnabledGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqEnabledGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqEnabledGroup: %w", err)
	}
	return oldValue.UniqEnabledGroup, nil
}

// ClearUniqEnabledGroup clears the value of the "uniq_enabled_group" field.
func (m *FmAlertGroupMutation) ClearUniqEnabledGroup() {
	m.uniq_enabled_group = nil
	m.clearedFields[fmalertgroup.FieldUniqEnabledGroup] = struct{}{}
}

// UniqEnabledGroupCleared returns if the "uniq_enabled_group" field was cleared in this mutation.
func (m *FmAlertGroupMutation) UniqEnabledGroupCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldUniqEnabledGroup]
	return ok
}

// ResetUniqEnabledGroup resets all changes to the "uniq_enabled_group" field.
func (m *FmAlertGroupMutation) ResetUniqEnabledGroup() {
	m.uniq_enabled_group = nil
	delete(m.clearedFields, fmalertgroup.FieldUniqEnabledGroup)
}

// SetCreatedTime sets the "created_time" field.
func (m *FmAlertGroupMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FmAlertGroupMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FmAlertGroupMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fmalertgroup.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FmAlertGroupMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FmAlertGroupMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fmalertgroup.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *FmAlertGroupMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *FmAlertGroupMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the FmAlertGroup entity.
// If the FmAlertGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmAlertGroupMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *FmAlertGroupMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[fmalertgroup.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *FmAlertGroupMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[fmalertgroup.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *FmAlertGroupMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, fmalertgroup.FieldUpdatedTime)
}

// Where appends a list predicates to the FmAlertGroupMutation builder.
func (m *FmAlertGroupMutation) Where(ps ...predicate.FmAlertGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FmAlertGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FmAlertGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FmAlertGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FmAlertGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FmAlertGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FmAlertGroup).
func (m *FmAlertGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FmAlertGroupMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.group_name != nil {
		fields = append(fields, fmalertgroup.FieldGroupName)
	}
	if m.tenant_id != nil {
		fields = append(fields, fmalertgroup.FieldTenantID)
	}
	if m.group_type != nil {
		fields = append(fields, fmalertgroup.FieldGroupType)
	}
	if m.enabled != nil {
		fields = append(fields, fmalertgroup.FieldEnabled)
	}
	if m.customization != nil {
		fields = append(fields, fmalertgroup.FieldCustomization)
	}
	if m.description != nil {
		fields = append(fields, fmalertgroup.FieldDescription)
	}
	if m.creator != nil {
		fields = append(fields, fmalertgroup.FieldCreator)
	}
	if m.uniq_enabled_group != nil {
		fields = append(fields, fmalertgroup.FieldUniqEnabledGroup)
	}
	if m.created_time != nil {
		fields = append(fields, fmalertgroup.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, fmalertgroup.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FmAlertGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmalertgroup.FieldGroupName:
		return m.GroupName()
	case fmalertgroup.FieldTenantID:
		return m.TenantID()
	case fmalertgroup.FieldGroupType:
		return m.GroupType()
	case fmalertgroup.FieldEnabled:
		return m.Enabled()
	case fmalertgroup.FieldCustomization:
		return m.Customization()
	case fmalertgroup.FieldDescription:
		return m.Description()
	case fmalertgroup.FieldCreator:
		return m.Creator()
	case fmalertgroup.FieldUniqEnabledGroup:
		return m.UniqEnabledGroup()
	case fmalertgroup.FieldCreatedTime:
		return m.CreatedTime()
	case fmalertgroup.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FmAlertGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmalertgroup.FieldGroupName:
		return m.OldGroupName(ctx)
	case fmalertgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case fmalertgroup.FieldGroupType:
		return m.OldGroupType(ctx)
	case fmalertgroup.FieldEnabled:
		return m.OldEnabled(ctx)
	case fmalertgroup.FieldCustomization:
		return m.OldCustomization(ctx)
	case fmalertgroup.FieldDescription:
		return m.OldDescription(ctx)
	case fmalertgroup.FieldCreator:
		return m.OldCreator(ctx)
	case fmalertgroup.FieldUniqEnabledGroup:
		return m.OldUniqEnabledGroup(ctx)
	case fmalertgroup.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case fmalertgroup.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FmAlertGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmAlertGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmalertgroup.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case fmalertgroup.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case fmalertgroup.FieldGroupType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupType(v)
		return nil
	case fmalertgroup.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case fmalertgroup.FieldCustomization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomization(v)
		return nil
	case fmalertgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fmalertgroup.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case fmalertgroup.FieldUniqEnabledGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqEnabledGroup(v)
		return nil
	case fmalertgroup.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case fmalertgroup.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FmAlertGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FmAlertGroupMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_type != nil {
		fields = append(fields, fmalertgroup.FieldGroupType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FmAlertGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fmalertgroup.FieldGroupType:
		return m.AddedGroupType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmAlertGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fmalertgroup.FieldGroupType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupType(v)
		return nil
	}
	return fmt.Errorf("unknown FmAlertGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FmAlertGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmalertgroup.FieldGroupType) {
		fields = append(fields, fmalertgroup.FieldGroupType)
	}
	if m.FieldCleared(fmalertgroup.FieldEnabled) {
		fields = append(fields, fmalertgroup.FieldEnabled)
	}
	if m.FieldCleared(fmalertgroup.FieldCustomization) {
		fields = append(fields, fmalertgroup.FieldCustomization)
	}
	if m.FieldCleared(fmalertgroup.FieldDescription) {
		fields = append(fields, fmalertgroup.FieldDescription)
	}
	if m.FieldCleared(fmalertgroup.FieldCreator) {
		fields = append(fields, fmalertgroup.FieldCreator)
	}
	if m.FieldCleared(fmalertgroup.FieldUniqEnabledGroup) {
		fields = append(fields, fmalertgroup.FieldUniqEnabledGroup)
	}
	if m.FieldCleared(fmalertgroup.FieldCreatedTime) {
		fields = append(fields, fmalertgroup.FieldCreatedTime)
	}
	if m.FieldCleared(fmalertgroup.FieldUpdatedTime) {
		fields = append(fields, fmalertgroup.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FmAlertGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FmAlertGroupMutation) ClearField(name string) error {
	switch name {
	case fmalertgroup.FieldGroupType:
		m.ClearGroupType()
		return nil
	case fmalertgroup.FieldEnabled:
		m.ClearEnabled()
		return nil
	case fmalertgroup.FieldCustomization:
		m.ClearCustomization()
		return nil
	case fmalertgroup.FieldDescription:
		m.ClearDescription()
		return nil
	case fmalertgroup.FieldCreator:
		m.ClearCreator()
		return nil
	case fmalertgroup.FieldUniqEnabledGroup:
		m.ClearUniqEnabledGroup()
		return nil
	case fmalertgroup.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case fmalertgroup.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmAlertGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FmAlertGroupMutation) ResetField(name string) error {
	switch name {
	case fmalertgroup.FieldGroupName:
		m.ResetGroupName()
		return nil
	case fmalertgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case fmalertgroup.FieldGroupType:
		m.ResetGroupType()
		return nil
	case fmalertgroup.FieldEnabled:
		m.ResetEnabled()
		return nil
	case fmalertgroup.FieldCustomization:
		m.ResetCustomization()
		return nil
	case fmalertgroup.FieldDescription:
		m.ResetDescription()
		return nil
	case fmalertgroup.FieldCreator:
		m.ResetCreator()
		return nil
	case fmalertgroup.FieldUniqEnabledGroup:
		m.ResetUniqEnabledGroup()
		return nil
	case fmalertgroup.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case fmalertgroup.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmAlertGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FmAlertGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FmAlertGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FmAlertGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FmAlertGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FmAlertGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FmAlertGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FmAlertGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FmAlertGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FmAlertGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FmAlertGroup edge %s", name)
}

// FmDedicatedServicesMutation represents an operation that mutates the FmDedicatedServices nodes in the graph.
type FmDedicatedServicesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	work_id       *int64
	addwork_id    *int64
	contacts      *string
	supplier      *string
	phonenum      *string
	email         *string
	fax           *string
	description   *string
	creator       *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FmDedicatedServices, error)
	predicates    []predicate.FmDedicatedServices
}

var _ ent.Mutation = (*FmDedicatedServicesMutation)(nil)

// fmdedicatedservicesOption allows management of the mutation configuration using functional options.
type fmdedicatedservicesOption func(*FmDedicatedServicesMutation)

// newFmDedicatedServicesMutation creates new mutation for the FmDedicatedServices entity.
func newFmDedicatedServicesMutation(c config, op Op, opts ...fmdedicatedservicesOption) *FmDedicatedServicesMutation {
	m := &FmDedicatedServicesMutation{
		config:        c,
		op:            op,
		typ:           TypeFmDedicatedServices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFmDedicatedServicesID sets the ID field of the mutation.
func withFmDedicatedServicesID(id int64) fmdedicatedservicesOption {
	return func(m *FmDedicatedServicesMutation) {
		var (
			err   error
			once  sync.Once
			value *FmDedicatedServices
		)
		m.oldValue = func(ctx context.Context) (*FmDedicatedServices, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FmDedicatedServices.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFmDedicatedServices sets the old FmDedicatedServices of the mutation.
func withFmDedicatedServices(node *FmDedicatedServices) fmdedicatedservicesOption {
	return func(m *FmDedicatedServicesMutation) {
		m.oldValue = func(context.Context) (*FmDedicatedServices, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FmDedicatedServicesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FmDedicatedServicesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FmDedicatedServices entities.
func (m *FmDedicatedServicesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FmDedicatedServicesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FmDedicatedServicesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FmDedicatedServices.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkID sets the "work_id" field.
func (m *FmDedicatedServicesMutation) SetWorkID(i int64) {
	m.work_id = &i
	m.addwork_id = nil
}

// WorkID returns the value of the "work_id" field in the mutation.
func (m *FmDedicatedServicesMutation) WorkID() (r int64, exists bool) {
	v := m.work_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkID returns the old "work_id" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldWorkID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkID: %w", err)
	}
	return oldValue.WorkID, nil
}

// AddWorkID adds i to the "work_id" field.
func (m *FmDedicatedServicesMutation) AddWorkID(i int64) {
	if m.addwork_id != nil {
		*m.addwork_id += i
	} else {
		m.addwork_id = &i
	}
}

// AddedWorkID returns the value that was added to the "work_id" field in this mutation.
func (m *FmDedicatedServicesMutation) AddedWorkID() (r int64, exists bool) {
	v := m.addwork_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkID clears the value of the "work_id" field.
func (m *FmDedicatedServicesMutation) ClearWorkID() {
	m.work_id = nil
	m.addwork_id = nil
	m.clearedFields[fmdedicatedservices.FieldWorkID] = struct{}{}
}

// WorkIDCleared returns if the "work_id" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) WorkIDCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldWorkID]
	return ok
}

// ResetWorkID resets all changes to the "work_id" field.
func (m *FmDedicatedServicesMutation) ResetWorkID() {
	m.work_id = nil
	m.addwork_id = nil
	delete(m.clearedFields, fmdedicatedservices.FieldWorkID)
}

// SetContacts sets the "contacts" field.
func (m *FmDedicatedServicesMutation) SetContacts(s string) {
	m.contacts = &s
}

// Contacts returns the value of the "contacts" field in the mutation.
func (m *FmDedicatedServicesMutation) Contacts() (r string, exists bool) {
	v := m.contacts
	if v == nil {
		return
	}
	return *v, true
}

// OldContacts returns the old "contacts" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldContacts(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContacts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContacts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContacts: %w", err)
	}
	return oldValue.Contacts, nil
}

// ClearContacts clears the value of the "contacts" field.
func (m *FmDedicatedServicesMutation) ClearContacts() {
	m.contacts = nil
	m.clearedFields[fmdedicatedservices.FieldContacts] = struct{}{}
}

// ContactsCleared returns if the "contacts" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) ContactsCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldContacts]
	return ok
}

// ResetContacts resets all changes to the "contacts" field.
func (m *FmDedicatedServicesMutation) ResetContacts() {
	m.contacts = nil
	delete(m.clearedFields, fmdedicatedservices.FieldContacts)
}

// SetSupplier sets the "supplier" field.
func (m *FmDedicatedServicesMutation) SetSupplier(s string) {
	m.supplier = &s
}

// Supplier returns the value of the "supplier" field in the mutation.
func (m *FmDedicatedServicesMutation) Supplier() (r string, exists bool) {
	v := m.supplier
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplier returns the old "supplier" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldSupplier(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplier: %w", err)
	}
	return oldValue.Supplier, nil
}

// ClearSupplier clears the value of the "supplier" field.
func (m *FmDedicatedServicesMutation) ClearSupplier() {
	m.supplier = nil
	m.clearedFields[fmdedicatedservices.FieldSupplier] = struct{}{}
}

// SupplierCleared returns if the "supplier" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) SupplierCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldSupplier]
	return ok
}

// ResetSupplier resets all changes to the "supplier" field.
func (m *FmDedicatedServicesMutation) ResetSupplier() {
	m.supplier = nil
	delete(m.clearedFields, fmdedicatedservices.FieldSupplier)
}

// SetPhonenum sets the "phonenum" field.
func (m *FmDedicatedServicesMutation) SetPhonenum(s string) {
	m.phonenum = &s
}

// Phonenum returns the value of the "phonenum" field in the mutation.
func (m *FmDedicatedServicesMutation) Phonenum() (r string, exists bool) {
	v := m.phonenum
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenum returns the old "phonenum" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldPhonenum(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhonenum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhonenum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenum: %w", err)
	}
	return oldValue.Phonenum, nil
}

// ClearPhonenum clears the value of the "phonenum" field.
func (m *FmDedicatedServicesMutation) ClearPhonenum() {
	m.phonenum = nil
	m.clearedFields[fmdedicatedservices.FieldPhonenum] = struct{}{}
}

// PhonenumCleared returns if the "phonenum" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) PhonenumCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldPhonenum]
	return ok
}

// ResetPhonenum resets all changes to the "phonenum" field.
func (m *FmDedicatedServicesMutation) ResetPhonenum() {
	m.phonenum = nil
	delete(m.clearedFields, fmdedicatedservices.FieldPhonenum)
}

// SetEmail sets the "email" field.
func (m *FmDedicatedServicesMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *FmDedicatedServicesMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *FmDedicatedServicesMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[fmdedicatedservices.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) EmailCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *FmDedicatedServicesMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, fmdedicatedservices.FieldEmail)
}

// SetFax sets the "fax" field.
func (m *FmDedicatedServicesMutation) SetFax(s string) {
	m.fax = &s
}

// Fax returns the value of the "fax" field in the mutation.
func (m *FmDedicatedServicesMutation) Fax() (r string, exists bool) {
	v := m.fax
	if v == nil {
		return
	}
	return *v, true
}

// OldFax returns the old "fax" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldFax(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFax: %w", err)
	}
	return oldValue.Fax, nil
}

// ClearFax clears the value of the "fax" field.
func (m *FmDedicatedServicesMutation) ClearFax() {
	m.fax = nil
	m.clearedFields[fmdedicatedservices.FieldFax] = struct{}{}
}

// FaxCleared returns if the "fax" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) FaxCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldFax]
	return ok
}

// ResetFax resets all changes to the "fax" field.
func (m *FmDedicatedServicesMutation) ResetFax() {
	m.fax = nil
	delete(m.clearedFields, fmdedicatedservices.FieldFax)
}

// SetDescription sets the "description" field.
func (m *FmDedicatedServicesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FmDedicatedServicesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FmDedicatedServicesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[fmdedicatedservices.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FmDedicatedServicesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, fmdedicatedservices.FieldDescription)
}

// SetCreator sets the "creator" field.
func (m *FmDedicatedServicesMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *FmDedicatedServicesMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldCreator(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *FmDedicatedServicesMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[fmdedicatedservices.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *FmDedicatedServicesMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, fmdedicatedservices.FieldCreator)
}

// SetCreatedTime sets the "created_time" field.
func (m *FmDedicatedServicesMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FmDedicatedServicesMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FmDedicatedServices entity.
// If the FmDedicatedServices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDedicatedServicesMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FmDedicatedServicesMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fmdedicatedservices.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FmDedicatedServicesMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fmdedicatedservices.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FmDedicatedServicesMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fmdedicatedservices.FieldCreatedTime)
}

// Where appends a list predicates to the FmDedicatedServicesMutation builder.
func (m *FmDedicatedServicesMutation) Where(ps ...predicate.FmDedicatedServices) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FmDedicatedServicesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FmDedicatedServicesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FmDedicatedServices, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FmDedicatedServicesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FmDedicatedServicesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FmDedicatedServices).
func (m *FmDedicatedServicesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FmDedicatedServicesMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.work_id != nil {
		fields = append(fields, fmdedicatedservices.FieldWorkID)
	}
	if m.contacts != nil {
		fields = append(fields, fmdedicatedservices.FieldContacts)
	}
	if m.supplier != nil {
		fields = append(fields, fmdedicatedservices.FieldSupplier)
	}
	if m.phonenum != nil {
		fields = append(fields, fmdedicatedservices.FieldPhonenum)
	}
	if m.email != nil {
		fields = append(fields, fmdedicatedservices.FieldEmail)
	}
	if m.fax != nil {
		fields = append(fields, fmdedicatedservices.FieldFax)
	}
	if m.description != nil {
		fields = append(fields, fmdedicatedservices.FieldDescription)
	}
	if m.creator != nil {
		fields = append(fields, fmdedicatedservices.FieldCreator)
	}
	if m.created_time != nil {
		fields = append(fields, fmdedicatedservices.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FmDedicatedServicesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		return m.WorkID()
	case fmdedicatedservices.FieldContacts:
		return m.Contacts()
	case fmdedicatedservices.FieldSupplier:
		return m.Supplier()
	case fmdedicatedservices.FieldPhonenum:
		return m.Phonenum()
	case fmdedicatedservices.FieldEmail:
		return m.Email()
	case fmdedicatedservices.FieldFax:
		return m.Fax()
	case fmdedicatedservices.FieldDescription:
		return m.Description()
	case fmdedicatedservices.FieldCreator:
		return m.Creator()
	case fmdedicatedservices.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FmDedicatedServicesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		return m.OldWorkID(ctx)
	case fmdedicatedservices.FieldContacts:
		return m.OldContacts(ctx)
	case fmdedicatedservices.FieldSupplier:
		return m.OldSupplier(ctx)
	case fmdedicatedservices.FieldPhonenum:
		return m.OldPhonenum(ctx)
	case fmdedicatedservices.FieldEmail:
		return m.OldEmail(ctx)
	case fmdedicatedservices.FieldFax:
		return m.OldFax(ctx)
	case fmdedicatedservices.FieldDescription:
		return m.OldDescription(ctx)
	case fmdedicatedservices.FieldCreator:
		return m.OldCreator(ctx)
	case fmdedicatedservices.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FmDedicatedServices field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmDedicatedServicesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkID(v)
		return nil
	case fmdedicatedservices.FieldContacts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContacts(v)
		return nil
	case fmdedicatedservices.FieldSupplier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplier(v)
		return nil
	case fmdedicatedservices.FieldPhonenum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenum(v)
		return nil
	case fmdedicatedservices.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case fmdedicatedservices.FieldFax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFax(v)
		return nil
	case fmdedicatedservices.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fmdedicatedservices.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case fmdedicatedservices.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FmDedicatedServices field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FmDedicatedServicesMutation) AddedFields() []string {
	var fields []string
	if m.addwork_id != nil {
		fields = append(fields, fmdedicatedservices.FieldWorkID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FmDedicatedServicesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		return m.AddedWorkID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmDedicatedServicesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkID(v)
		return nil
	}
	return fmt.Errorf("unknown FmDedicatedServices numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FmDedicatedServicesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmdedicatedservices.FieldWorkID) {
		fields = append(fields, fmdedicatedservices.FieldWorkID)
	}
	if m.FieldCleared(fmdedicatedservices.FieldContacts) {
		fields = append(fields, fmdedicatedservices.FieldContacts)
	}
	if m.FieldCleared(fmdedicatedservices.FieldSupplier) {
		fields = append(fields, fmdedicatedservices.FieldSupplier)
	}
	if m.FieldCleared(fmdedicatedservices.FieldPhonenum) {
		fields = append(fields, fmdedicatedservices.FieldPhonenum)
	}
	if m.FieldCleared(fmdedicatedservices.FieldEmail) {
		fields = append(fields, fmdedicatedservices.FieldEmail)
	}
	if m.FieldCleared(fmdedicatedservices.FieldFax) {
		fields = append(fields, fmdedicatedservices.FieldFax)
	}
	if m.FieldCleared(fmdedicatedservices.FieldDescription) {
		fields = append(fields, fmdedicatedservices.FieldDescription)
	}
	if m.FieldCleared(fmdedicatedservices.FieldCreator) {
		fields = append(fields, fmdedicatedservices.FieldCreator)
	}
	if m.FieldCleared(fmdedicatedservices.FieldCreatedTime) {
		fields = append(fields, fmdedicatedservices.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FmDedicatedServicesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FmDedicatedServicesMutation) ClearField(name string) error {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		m.ClearWorkID()
		return nil
	case fmdedicatedservices.FieldContacts:
		m.ClearContacts()
		return nil
	case fmdedicatedservices.FieldSupplier:
		m.ClearSupplier()
		return nil
	case fmdedicatedservices.FieldPhonenum:
		m.ClearPhonenum()
		return nil
	case fmdedicatedservices.FieldEmail:
		m.ClearEmail()
		return nil
	case fmdedicatedservices.FieldFax:
		m.ClearFax()
		return nil
	case fmdedicatedservices.FieldDescription:
		m.ClearDescription()
		return nil
	case fmdedicatedservices.FieldCreator:
		m.ClearCreator()
		return nil
	case fmdedicatedservices.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmDedicatedServices nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FmDedicatedServicesMutation) ResetField(name string) error {
	switch name {
	case fmdedicatedservices.FieldWorkID:
		m.ResetWorkID()
		return nil
	case fmdedicatedservices.FieldContacts:
		m.ResetContacts()
		return nil
	case fmdedicatedservices.FieldSupplier:
		m.ResetSupplier()
		return nil
	case fmdedicatedservices.FieldPhonenum:
		m.ResetPhonenum()
		return nil
	case fmdedicatedservices.FieldEmail:
		m.ResetEmail()
		return nil
	case fmdedicatedservices.FieldFax:
		m.ResetFax()
		return nil
	case fmdedicatedservices.FieldDescription:
		m.ResetDescription()
		return nil
	case fmdedicatedservices.FieldCreator:
		m.ResetCreator()
		return nil
	case fmdedicatedservices.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmDedicatedServices field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FmDedicatedServicesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FmDedicatedServicesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FmDedicatedServicesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FmDedicatedServicesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FmDedicatedServicesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FmDedicatedServicesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FmDedicatedServicesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FmDedicatedServices unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FmDedicatedServicesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FmDedicatedServices edge %s", name)
}

// FmDemandsMutation represents an operation that mutates the FmDemands nodes in the graph.
type FmDemandsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	supplier      *string
	username      *string
	phonenum      *string
	email         *string
	province      *string
	city          *string
	area          *string
	street        *string
	message       *string
	creator       *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FmDemands, error)
	predicates    []predicate.FmDemands
}

var _ ent.Mutation = (*FmDemandsMutation)(nil)

// fmdemandsOption allows management of the mutation configuration using functional options.
type fmdemandsOption func(*FmDemandsMutation)

// newFmDemandsMutation creates new mutation for the FmDemands entity.
func newFmDemandsMutation(c config, op Op, opts ...fmdemandsOption) *FmDemandsMutation {
	m := &FmDemandsMutation{
		config:        c,
		op:            op,
		typ:           TypeFmDemands,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFmDemandsID sets the ID field of the mutation.
func withFmDemandsID(id int64) fmdemandsOption {
	return func(m *FmDemandsMutation) {
		var (
			err   error
			once  sync.Once
			value *FmDemands
		)
		m.oldValue = func(ctx context.Context) (*FmDemands, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FmDemands.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFmDemands sets the old FmDemands of the mutation.
func withFmDemands(node *FmDemands) fmdemandsOption {
	return func(m *FmDemandsMutation) {
		m.oldValue = func(context.Context) (*FmDemands, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FmDemandsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FmDemandsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FmDemands entities.
func (m *FmDemandsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FmDemandsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FmDemandsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FmDemands.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSupplier sets the "supplier" field.
func (m *FmDemandsMutation) SetSupplier(s string) {
	m.supplier = &s
}

// Supplier returns the value of the "supplier" field in the mutation.
func (m *FmDemandsMutation) Supplier() (r string, exists bool) {
	v := m.supplier
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplier returns the old "supplier" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldSupplier(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplier: %w", err)
	}
	return oldValue.Supplier, nil
}

// ClearSupplier clears the value of the "supplier" field.
func (m *FmDemandsMutation) ClearSupplier() {
	m.supplier = nil
	m.clearedFields[fmdemands.FieldSupplier] = struct{}{}
}

// SupplierCleared returns if the "supplier" field was cleared in this mutation.
func (m *FmDemandsMutation) SupplierCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldSupplier]
	return ok
}

// ResetSupplier resets all changes to the "supplier" field.
func (m *FmDemandsMutation) ResetSupplier() {
	m.supplier = nil
	delete(m.clearedFields, fmdemands.FieldSupplier)
}

// SetUsername sets the "username" field.
func (m *FmDemandsMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *FmDemandsMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *FmDemandsMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[fmdemands.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *FmDemandsMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *FmDemandsMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, fmdemands.FieldUsername)
}

// SetPhonenum sets the "phonenum" field.
func (m *FmDemandsMutation) SetPhonenum(s string) {
	m.phonenum = &s
}

// Phonenum returns the value of the "phonenum" field in the mutation.
func (m *FmDemandsMutation) Phonenum() (r string, exists bool) {
	v := m.phonenum
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenum returns the old "phonenum" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldPhonenum(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhonenum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhonenum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenum: %w", err)
	}
	return oldValue.Phonenum, nil
}

// ClearPhonenum clears the value of the "phonenum" field.
func (m *FmDemandsMutation) ClearPhonenum() {
	m.phonenum = nil
	m.clearedFields[fmdemands.FieldPhonenum] = struct{}{}
}

// PhonenumCleared returns if the "phonenum" field was cleared in this mutation.
func (m *FmDemandsMutation) PhonenumCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldPhonenum]
	return ok
}

// ResetPhonenum resets all changes to the "phonenum" field.
func (m *FmDemandsMutation) ResetPhonenum() {
	m.phonenum = nil
	delete(m.clearedFields, fmdemands.FieldPhonenum)
}

// SetEmail sets the "email" field.
func (m *FmDemandsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *FmDemandsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *FmDemandsMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[fmdemands.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *FmDemandsMutation) EmailCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *FmDemandsMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, fmdemands.FieldEmail)
}

// SetProvince sets the "province" field.
func (m *FmDemandsMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *FmDemandsMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldProvince(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *FmDemandsMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[fmdemands.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *FmDemandsMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *FmDemandsMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, fmdemands.FieldProvince)
}

// SetCity sets the "city" field.
func (m *FmDemandsMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *FmDemandsMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *FmDemandsMutation) ClearCity() {
	m.city = nil
	m.clearedFields[fmdemands.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *FmDemandsMutation) CityCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *FmDemandsMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, fmdemands.FieldCity)
}

// SetArea sets the "area" field.
func (m *FmDemandsMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *FmDemandsMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldArea(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ClearArea clears the value of the "area" field.
func (m *FmDemandsMutation) ClearArea() {
	m.area = nil
	m.clearedFields[fmdemands.FieldArea] = struct{}{}
}

// AreaCleared returns if the "area" field was cleared in this mutation.
func (m *FmDemandsMutation) AreaCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldArea]
	return ok
}

// ResetArea resets all changes to the "area" field.
func (m *FmDemandsMutation) ResetArea() {
	m.area = nil
	delete(m.clearedFields, fmdemands.FieldArea)
}

// SetStreet sets the "street" field.
func (m *FmDemandsMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *FmDemandsMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldStreet(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "street" field.
func (m *FmDemandsMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[fmdemands.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "street" field was cleared in this mutation.
func (m *FmDemandsMutation) StreetCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "street" field.
func (m *FmDemandsMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, fmdemands.FieldStreet)
}

// SetMessage sets the "message" field.
func (m *FmDemandsMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *FmDemandsMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *FmDemandsMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[fmdemands.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *FmDemandsMutation) MessageCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *FmDemandsMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, fmdemands.FieldMessage)
}

// SetCreator sets the "creator" field.
func (m *FmDemandsMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *FmDemandsMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldCreator(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *FmDemandsMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[fmdemands.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *FmDemandsMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *FmDemandsMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, fmdemands.FieldCreator)
}

// SetCreatedTime sets the "created_time" field.
func (m *FmDemandsMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FmDemandsMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FmDemands entity.
// If the FmDemands object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmDemandsMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FmDemandsMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fmdemands.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FmDemandsMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fmdemands.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FmDemandsMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fmdemands.FieldCreatedTime)
}

// Where appends a list predicates to the FmDemandsMutation builder.
func (m *FmDemandsMutation) Where(ps ...predicate.FmDemands) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FmDemandsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FmDemandsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FmDemands, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FmDemandsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FmDemandsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FmDemands).
func (m *FmDemandsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FmDemandsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.supplier != nil {
		fields = append(fields, fmdemands.FieldSupplier)
	}
	if m.username != nil {
		fields = append(fields, fmdemands.FieldUsername)
	}
	if m.phonenum != nil {
		fields = append(fields, fmdemands.FieldPhonenum)
	}
	if m.email != nil {
		fields = append(fields, fmdemands.FieldEmail)
	}
	if m.province != nil {
		fields = append(fields, fmdemands.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, fmdemands.FieldCity)
	}
	if m.area != nil {
		fields = append(fields, fmdemands.FieldArea)
	}
	if m.street != nil {
		fields = append(fields, fmdemands.FieldStreet)
	}
	if m.message != nil {
		fields = append(fields, fmdemands.FieldMessage)
	}
	if m.creator != nil {
		fields = append(fields, fmdemands.FieldCreator)
	}
	if m.created_time != nil {
		fields = append(fields, fmdemands.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FmDemandsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmdemands.FieldSupplier:
		return m.Supplier()
	case fmdemands.FieldUsername:
		return m.Username()
	case fmdemands.FieldPhonenum:
		return m.Phonenum()
	case fmdemands.FieldEmail:
		return m.Email()
	case fmdemands.FieldProvince:
		return m.Province()
	case fmdemands.FieldCity:
		return m.City()
	case fmdemands.FieldArea:
		return m.Area()
	case fmdemands.FieldStreet:
		return m.Street()
	case fmdemands.FieldMessage:
		return m.Message()
	case fmdemands.FieldCreator:
		return m.Creator()
	case fmdemands.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FmDemandsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmdemands.FieldSupplier:
		return m.OldSupplier(ctx)
	case fmdemands.FieldUsername:
		return m.OldUsername(ctx)
	case fmdemands.FieldPhonenum:
		return m.OldPhonenum(ctx)
	case fmdemands.FieldEmail:
		return m.OldEmail(ctx)
	case fmdemands.FieldProvince:
		return m.OldProvince(ctx)
	case fmdemands.FieldCity:
		return m.OldCity(ctx)
	case fmdemands.FieldArea:
		return m.OldArea(ctx)
	case fmdemands.FieldStreet:
		return m.OldStreet(ctx)
	case fmdemands.FieldMessage:
		return m.OldMessage(ctx)
	case fmdemands.FieldCreator:
		return m.OldCreator(ctx)
	case fmdemands.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FmDemands field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmDemandsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmdemands.FieldSupplier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplier(v)
		return nil
	case fmdemands.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case fmdemands.FieldPhonenum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenum(v)
		return nil
	case fmdemands.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case fmdemands.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case fmdemands.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case fmdemands.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case fmdemands.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case fmdemands.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case fmdemands.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case fmdemands.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FmDemands field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FmDemandsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FmDemandsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmDemandsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FmDemands numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FmDemandsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmdemands.FieldSupplier) {
		fields = append(fields, fmdemands.FieldSupplier)
	}
	if m.FieldCleared(fmdemands.FieldUsername) {
		fields = append(fields, fmdemands.FieldUsername)
	}
	if m.FieldCleared(fmdemands.FieldPhonenum) {
		fields = append(fields, fmdemands.FieldPhonenum)
	}
	if m.FieldCleared(fmdemands.FieldEmail) {
		fields = append(fields, fmdemands.FieldEmail)
	}
	if m.FieldCleared(fmdemands.FieldProvince) {
		fields = append(fields, fmdemands.FieldProvince)
	}
	if m.FieldCleared(fmdemands.FieldCity) {
		fields = append(fields, fmdemands.FieldCity)
	}
	if m.FieldCleared(fmdemands.FieldArea) {
		fields = append(fields, fmdemands.FieldArea)
	}
	if m.FieldCleared(fmdemands.FieldStreet) {
		fields = append(fields, fmdemands.FieldStreet)
	}
	if m.FieldCleared(fmdemands.FieldMessage) {
		fields = append(fields, fmdemands.FieldMessage)
	}
	if m.FieldCleared(fmdemands.FieldCreator) {
		fields = append(fields, fmdemands.FieldCreator)
	}
	if m.FieldCleared(fmdemands.FieldCreatedTime) {
		fields = append(fields, fmdemands.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FmDemandsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FmDemandsMutation) ClearField(name string) error {
	switch name {
	case fmdemands.FieldSupplier:
		m.ClearSupplier()
		return nil
	case fmdemands.FieldUsername:
		m.ClearUsername()
		return nil
	case fmdemands.FieldPhonenum:
		m.ClearPhonenum()
		return nil
	case fmdemands.FieldEmail:
		m.ClearEmail()
		return nil
	case fmdemands.FieldProvince:
		m.ClearProvince()
		return nil
	case fmdemands.FieldCity:
		m.ClearCity()
		return nil
	case fmdemands.FieldArea:
		m.ClearArea()
		return nil
	case fmdemands.FieldStreet:
		m.ClearStreet()
		return nil
	case fmdemands.FieldMessage:
		m.ClearMessage()
		return nil
	case fmdemands.FieldCreator:
		m.ClearCreator()
		return nil
	case fmdemands.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmDemands nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FmDemandsMutation) ResetField(name string) error {
	switch name {
	case fmdemands.FieldSupplier:
		m.ResetSupplier()
		return nil
	case fmdemands.FieldUsername:
		m.ResetUsername()
		return nil
	case fmdemands.FieldPhonenum:
		m.ResetPhonenum()
		return nil
	case fmdemands.FieldEmail:
		m.ResetEmail()
		return nil
	case fmdemands.FieldProvince:
		m.ResetProvince()
		return nil
	case fmdemands.FieldCity:
		m.ResetCity()
		return nil
	case fmdemands.FieldArea:
		m.ResetArea()
		return nil
	case fmdemands.FieldStreet:
		m.ResetStreet()
		return nil
	case fmdemands.FieldMessage:
		m.ResetMessage()
		return nil
	case fmdemands.FieldCreator:
		m.ResetCreator()
		return nil
	case fmdemands.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown FmDemands field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FmDemandsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FmDemandsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FmDemandsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FmDemandsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FmDemandsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FmDemandsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FmDemandsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FmDemands unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FmDemandsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FmDemands edge %s", name)
}

// FmUserAccountMutation represents an operation that mutates the FmUserAccount nodes in the graph.
type FmUserAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	username      *string
	login_name    *string
	password      *string
	leader_flag   *string
	position      *string
	department    *string
	email         *string
	phonenum      *string
	description   *string
	ethnicity     *string
	gender        *string
	local         *string
	localhost     *string
	m2_localhost  *string
	ismanager     *string
	isystem       *string
	enabled       *bool
	is_sms        *bool
	member_id     *string
	leader_id     *string
	device_time   *string
	tenant_id     *uuid.UUID
	delete_flag   *string
	created_time  *time.Time
	updated_time  *time.Time
	deleted_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FmUserAccount, error)
	predicates    []predicate.FmUserAccount
}

var _ ent.Mutation = (*FmUserAccountMutation)(nil)

// fmuseraccountOption allows management of the mutation configuration using functional options.
type fmuseraccountOption func(*FmUserAccountMutation)

// newFmUserAccountMutation creates new mutation for the FmUserAccount entity.
func newFmUserAccountMutation(c config, op Op, opts ...fmuseraccountOption) *FmUserAccountMutation {
	m := &FmUserAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeFmUserAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFmUserAccountID sets the ID field of the mutation.
func withFmUserAccountID(id int64) fmuseraccountOption {
	return func(m *FmUserAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *FmUserAccount
		)
		m.oldValue = func(ctx context.Context) (*FmUserAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FmUserAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFmUserAccount sets the old FmUserAccount of the mutation.
func withFmUserAccount(node *FmUserAccount) fmuseraccountOption {
	return func(m *FmUserAccountMutation) {
		m.oldValue = func(context.Context) (*FmUserAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FmUserAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FmUserAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FmUserAccount entities.
func (m *FmUserAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FmUserAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FmUserAccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FmUserAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *FmUserAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *FmUserAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *FmUserAccountMutation) ResetUsername() {
	m.username = nil
}

// SetLoginName sets the "login_name" field.
func (m *FmUserAccountMutation) SetLoginName(s string) {
	m.login_name = &s
}

// LoginName returns the value of the "login_name" field in the mutation.
func (m *FmUserAccountMutation) LoginName() (r string, exists bool) {
	v := m.login_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginName returns the old "login_name" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldLoginName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginName: %w", err)
	}
	return oldValue.LoginName, nil
}

// ResetLoginName resets all changes to the "login_name" field.
func (m *FmUserAccountMutation) ResetLoginName() {
	m.login_name = nil
}

// SetPassword sets the "password" field.
func (m *FmUserAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *FmUserAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *FmUserAccountMutation) ResetPassword() {
	m.password = nil
}

// SetLeaderFlag sets the "leader_flag" field.
func (m *FmUserAccountMutation) SetLeaderFlag(s string) {
	m.leader_flag = &s
}

// LeaderFlag returns the value of the "leader_flag" field in the mutation.
func (m *FmUserAccountMutation) LeaderFlag() (r string, exists bool) {
	v := m.leader_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderFlag returns the old "leader_flag" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldLeaderFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderFlag: %w", err)
	}
	return oldValue.LeaderFlag, nil
}

// ClearLeaderFlag clears the value of the "leader_flag" field.
func (m *FmUserAccountMutation) ClearLeaderFlag() {
	m.leader_flag = nil
	m.clearedFields[fmuseraccount.FieldLeaderFlag] = struct{}{}
}

// LeaderFlagCleared returns if the "leader_flag" field was cleared in this mutation.
func (m *FmUserAccountMutation) LeaderFlagCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldLeaderFlag]
	return ok
}

// ResetLeaderFlag resets all changes to the "leader_flag" field.
func (m *FmUserAccountMutation) ResetLeaderFlag() {
	m.leader_flag = nil
	delete(m.clearedFields, fmuseraccount.FieldLeaderFlag)
}

// SetPosition sets the "position" field.
func (m *FmUserAccountMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *FmUserAccountMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *FmUserAccountMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[fmuseraccount.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *FmUserAccountMutation) PositionCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *FmUserAccountMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, fmuseraccount.FieldPosition)
}

// SetDepartment sets the "department" field.
func (m *FmUserAccountMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *FmUserAccountMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *FmUserAccountMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[fmuseraccount.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *FmUserAccountMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *FmUserAccountMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, fmuseraccount.FieldDepartment)
}

// SetEmail sets the "email" field.
func (m *FmUserAccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *FmUserAccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *FmUserAccountMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[fmuseraccount.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *FmUserAccountMutation) EmailCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *FmUserAccountMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, fmuseraccount.FieldEmail)
}

// SetPhonenum sets the "phonenum" field.
func (m *FmUserAccountMutation) SetPhonenum(s string) {
	m.phonenum = &s
}

// Phonenum returns the value of the "phonenum" field in the mutation.
func (m *FmUserAccountMutation) Phonenum() (r string, exists bool) {
	v := m.phonenum
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonenum returns the old "phonenum" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldPhonenum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhonenum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhonenum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonenum: %w", err)
	}
	return oldValue.Phonenum, nil
}

// ClearPhonenum clears the value of the "phonenum" field.
func (m *FmUserAccountMutation) ClearPhonenum() {
	m.phonenum = nil
	m.clearedFields[fmuseraccount.FieldPhonenum] = struct{}{}
}

// PhonenumCleared returns if the "phonenum" field was cleared in this mutation.
func (m *FmUserAccountMutation) PhonenumCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldPhonenum]
	return ok
}

// ResetPhonenum resets all changes to the "phonenum" field.
func (m *FmUserAccountMutation) ResetPhonenum() {
	m.phonenum = nil
	delete(m.clearedFields, fmuseraccount.FieldPhonenum)
}

// SetDescription sets the "description" field.
func (m *FmUserAccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FmUserAccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FmUserAccountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[fmuseraccount.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FmUserAccountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FmUserAccountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, fmuseraccount.FieldDescription)
}

// SetEthnicity sets the "ethnicity" field.
func (m *FmUserAccountMutation) SetEthnicity(s string) {
	m.ethnicity = &s
}

// Ethnicity returns the value of the "ethnicity" field in the mutation.
func (m *FmUserAccountMutation) Ethnicity() (r string, exists bool) {
	v := m.ethnicity
	if v == nil {
		return
	}
	return *v, true
}

// OldEthnicity returns the old "ethnicity" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldEthnicity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEthnicity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEthnicity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEthnicity: %w", err)
	}
	return oldValue.Ethnicity, nil
}

// ClearEthnicity clears the value of the "ethnicity" field.
func (m *FmUserAccountMutation) ClearEthnicity() {
	m.ethnicity = nil
	m.clearedFields[fmuseraccount.FieldEthnicity] = struct{}{}
}

// EthnicityCleared returns if the "ethnicity" field was cleared in this mutation.
func (m *FmUserAccountMutation) EthnicityCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldEthnicity]
	return ok
}

// ResetEthnicity resets all changes to the "ethnicity" field.
func (m *FmUserAccountMutation) ResetEthnicity() {
	m.ethnicity = nil
	delete(m.clearedFields, fmuseraccount.FieldEthnicity)
}

// SetGender sets the "gender" field.
func (m *FmUserAccountMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *FmUserAccountMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *FmUserAccountMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[fmuseraccount.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *FmUserAccountMutation) GenderCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *FmUserAccountMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, fmuseraccount.FieldGender)
}

// SetLocal sets the "local" field.
func (m *FmUserAccountMutation) SetLocal(s string) {
	m.local = &s
}

// Local returns the value of the "local" field in the mutation.
func (m *FmUserAccountMutation) Local() (r string, exists bool) {
	v := m.local
	if v == nil {
		return
	}
	return *v, true
}

// OldLocal returns the old "local" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldLocal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocal: %w", err)
	}
	return oldValue.Local, nil
}

// ClearLocal clears the value of the "local" field.
func (m *FmUserAccountMutation) ClearLocal() {
	m.local = nil
	m.clearedFields[fmuseraccount.FieldLocal] = struct{}{}
}

// LocalCleared returns if the "local" field was cleared in this mutation.
func (m *FmUserAccountMutation) LocalCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldLocal]
	return ok
}

// ResetLocal resets all changes to the "local" field.
func (m *FmUserAccountMutation) ResetLocal() {
	m.local = nil
	delete(m.clearedFields, fmuseraccount.FieldLocal)
}

// SetLocalhost sets the "localhost" field.
func (m *FmUserAccountMutation) SetLocalhost(s string) {
	m.localhost = &s
}

// Localhost returns the value of the "localhost" field in the mutation.
func (m *FmUserAccountMutation) Localhost() (r string, exists bool) {
	v := m.localhost
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalhost returns the old "localhost" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldLocalhost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalhost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalhost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalhost: %w", err)
	}
	return oldValue.Localhost, nil
}

// ClearLocalhost clears the value of the "localhost" field.
func (m *FmUserAccountMutation) ClearLocalhost() {
	m.localhost = nil
	m.clearedFields[fmuseraccount.FieldLocalhost] = struct{}{}
}

// LocalhostCleared returns if the "localhost" field was cleared in this mutation.
func (m *FmUserAccountMutation) LocalhostCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldLocalhost]
	return ok
}

// ResetLocalhost resets all changes to the "localhost" field.
func (m *FmUserAccountMutation) ResetLocalhost() {
	m.localhost = nil
	delete(m.clearedFields, fmuseraccount.FieldLocalhost)
}

// SetM2Localhost sets the "m2_localhost" field.
func (m *FmUserAccountMutation) SetM2Localhost(s string) {
	m.m2_localhost = &s
}

// M2Localhost returns the value of the "m2_localhost" field in the mutation.
func (m *FmUserAccountMutation) M2Localhost() (r string, exists bool) {
	v := m.m2_localhost
	if v == nil {
		return
	}
	return *v, true
}

// OldM2Localhost returns the old "m2_localhost" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldM2Localhost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldM2Localhost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldM2Localhost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldM2Localhost: %w", err)
	}
	return oldValue.M2Localhost, nil
}

// ClearM2Localhost clears the value of the "m2_localhost" field.
func (m *FmUserAccountMutation) ClearM2Localhost() {
	m.m2_localhost = nil
	m.clearedFields[fmuseraccount.FieldM2Localhost] = struct{}{}
}

// M2LocalhostCleared returns if the "m2_localhost" field was cleared in this mutation.
func (m *FmUserAccountMutation) M2LocalhostCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldM2Localhost]
	return ok
}

// ResetM2Localhost resets all changes to the "m2_localhost" field.
func (m *FmUserAccountMutation) ResetM2Localhost() {
	m.m2_localhost = nil
	delete(m.clearedFields, fmuseraccount.FieldM2Localhost)
}

// SetIsmanager sets the "ismanager" field.
func (m *FmUserAccountMutation) SetIsmanager(s string) {
	m.ismanager = &s
}

// Ismanager returns the value of the "ismanager" field in the mutation.
func (m *FmUserAccountMutation) Ismanager() (r string, exists bool) {
	v := m.ismanager
	if v == nil {
		return
	}
	return *v, true
}

// OldIsmanager returns the old "ismanager" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldIsmanager(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsmanager is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsmanager requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsmanager: %w", err)
	}
	return oldValue.Ismanager, nil
}

// ClearIsmanager clears the value of the "ismanager" field.
func (m *FmUserAccountMutation) ClearIsmanager() {
	m.ismanager = nil
	m.clearedFields[fmuseraccount.FieldIsmanager] = struct{}{}
}

// IsmanagerCleared returns if the "ismanager" field was cleared in this mutation.
func (m *FmUserAccountMutation) IsmanagerCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldIsmanager]
	return ok
}

// ResetIsmanager resets all changes to the "ismanager" field.
func (m *FmUserAccountMutation) ResetIsmanager() {
	m.ismanager = nil
	delete(m.clearedFields, fmuseraccount.FieldIsmanager)
}

// SetIsystem sets the "isystem" field.
func (m *FmUserAccountMutation) SetIsystem(s string) {
	m.isystem = &s
}

// Isystem returns the value of the "isystem" field in the mutation.
func (m *FmUserAccountMutation) Isystem() (r string, exists bool) {
	v := m.isystem
	if v == nil {
		return
	}
	return *v, true
}

// OldIsystem returns the old "isystem" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldIsystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsystem: %w", err)
	}
	return oldValue.Isystem, nil
}

// ClearIsystem clears the value of the "isystem" field.
func (m *FmUserAccountMutation) ClearIsystem() {
	m.isystem = nil
	m.clearedFields[fmuseraccount.FieldIsystem] = struct{}{}
}

// IsystemCleared returns if the "isystem" field was cleared in this mutation.
func (m *FmUserAccountMutation) IsystemCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldIsystem]
	return ok
}

// ResetIsystem resets all changes to the "isystem" field.
func (m *FmUserAccountMutation) ResetIsystem() {
	m.isystem = nil
	delete(m.clearedFields, fmuseraccount.FieldIsystem)
}

// SetEnabled sets the "enabled" field.
func (m *FmUserAccountMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FmUserAccountMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *FmUserAccountMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[fmuseraccount.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *FmUserAccountMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FmUserAccountMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, fmuseraccount.FieldEnabled)
}

// SetIsSms sets the "is_sms" field.
func (m *FmUserAccountMutation) SetIsSms(b bool) {
	m.is_sms = &b
}

// IsSms returns the value of the "is_sms" field in the mutation.
func (m *FmUserAccountMutation) IsSms() (r bool, exists bool) {
	v := m.is_sms
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSms returns the old "is_sms" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldIsSms(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSms: %w", err)
	}
	return oldValue.IsSms, nil
}

// ClearIsSms clears the value of the "is_sms" field.
func (m *FmUserAccountMutation) ClearIsSms() {
	m.is_sms = nil
	m.clearedFields[fmuseraccount.FieldIsSms] = struct{}{}
}

// IsSmsCleared returns if the "is_sms" field was cleared in this mutation.
func (m *FmUserAccountMutation) IsSmsCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldIsSms]
	return ok
}

// ResetIsSms resets all changes to the "is_sms" field.
func (m *FmUserAccountMutation) ResetIsSms() {
	m.is_sms = nil
	delete(m.clearedFields, fmuseraccount.FieldIsSms)
}

// SetMemberID sets the "member_id" field.
func (m *FmUserAccountMutation) SetMemberID(s string) {
	m.member_id = &s
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *FmUserAccountMutation) MemberID() (r string, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldMemberID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *FmUserAccountMutation) ClearMemberID() {
	m.member_id = nil
	m.clearedFields[fmuseraccount.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *FmUserAccountMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *FmUserAccountMutation) ResetMemberID() {
	m.member_id = nil
	delete(m.clearedFields, fmuseraccount.FieldMemberID)
}

// SetLeaderID sets the "leader_id" field.
func (m *FmUserAccountMutation) SetLeaderID(s string) {
	m.leader_id = &s
}

// LeaderID returns the value of the "leader_id" field in the mutation.
func (m *FmUserAccountMutation) LeaderID() (r string, exists bool) {
	v := m.leader_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderID returns the old "leader_id" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldLeaderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderID: %w", err)
	}
	return oldValue.LeaderID, nil
}

// ClearLeaderID clears the value of the "leader_id" field.
func (m *FmUserAccountMutation) ClearLeaderID() {
	m.leader_id = nil
	m.clearedFields[fmuseraccount.FieldLeaderID] = struct{}{}
}

// LeaderIDCleared returns if the "leader_id" field was cleared in this mutation.
func (m *FmUserAccountMutation) LeaderIDCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldLeaderID]
	return ok
}

// ResetLeaderID resets all changes to the "leader_id" field.
func (m *FmUserAccountMutation) ResetLeaderID() {
	m.leader_id = nil
	delete(m.clearedFields, fmuseraccount.FieldLeaderID)
}

// SetDeviceTime sets the "device_time" field.
func (m *FmUserAccountMutation) SetDeviceTime(s string) {
	m.device_time = &s
}

// DeviceTime returns the value of the "device_time" field in the mutation.
func (m *FmUserAccountMutation) DeviceTime() (r string, exists bool) {
	v := m.device_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceTime returns the old "device_time" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldDeviceTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceTime: %w", err)
	}
	return oldValue.DeviceTime, nil
}

// ClearDeviceTime clears the value of the "device_time" field.
func (m *FmUserAccountMutation) ClearDeviceTime() {
	m.device_time = nil
	m.clearedFields[fmuseraccount.FieldDeviceTime] = struct{}{}
}

// DeviceTimeCleared returns if the "device_time" field was cleared in this mutation.
func (m *FmUserAccountMutation) DeviceTimeCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldDeviceTime]
	return ok
}

// ResetDeviceTime resets all changes to the "device_time" field.
func (m *FmUserAccountMutation) ResetDeviceTime() {
	m.device_time = nil
	delete(m.clearedFields, fmuseraccount.FieldDeviceTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *FmUserAccountMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FmUserAccountMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *FmUserAccountMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[fmuseraccount.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *FmUserAccountMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FmUserAccountMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, fmuseraccount.FieldTenantID)
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *FmUserAccountMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *FmUserAccountMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldDeleteFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ClearDeleteFlag clears the value of the "delete_flag" field.
func (m *FmUserAccountMutation) ClearDeleteFlag() {
	m.delete_flag = nil
	m.clearedFields[fmuseraccount.FieldDeleteFlag] = struct{}{}
}

// DeleteFlagCleared returns if the "delete_flag" field was cleared in this mutation.
func (m *FmUserAccountMutation) DeleteFlagCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldDeleteFlag]
	return ok
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *FmUserAccountMutation) ResetDeleteFlag() {
	m.delete_flag = nil
	delete(m.clearedFields, fmuseraccount.FieldDeleteFlag)
}

// SetCreatedTime sets the "created_time" field.
func (m *FmUserAccountMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *FmUserAccountMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *FmUserAccountMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[fmuseraccount.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *FmUserAccountMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *FmUserAccountMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, fmuseraccount.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *FmUserAccountMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *FmUserAccountMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *FmUserAccountMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[fmuseraccount.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *FmUserAccountMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *FmUserAccountMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, fmuseraccount.FieldUpdatedTime)
}

// SetDeletedTime sets the "deleted_time" field.
func (m *FmUserAccountMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *FmUserAccountMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the FmUserAccount entity.
// If the FmUserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmUserAccountMutation) OldDeletedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *FmUserAccountMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[fmuseraccount.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *FmUserAccountMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[fmuseraccount.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *FmUserAccountMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, fmuseraccount.FieldDeletedTime)
}

// Where appends a list predicates to the FmUserAccountMutation builder.
func (m *FmUserAccountMutation) Where(ps ...predicate.FmUserAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FmUserAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FmUserAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FmUserAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FmUserAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FmUserAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FmUserAccount).
func (m *FmUserAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FmUserAccountMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.username != nil {
		fields = append(fields, fmuseraccount.FieldUsername)
	}
	if m.login_name != nil {
		fields = append(fields, fmuseraccount.FieldLoginName)
	}
	if m.password != nil {
		fields = append(fields, fmuseraccount.FieldPassword)
	}
	if m.leader_flag != nil {
		fields = append(fields, fmuseraccount.FieldLeaderFlag)
	}
	if m.position != nil {
		fields = append(fields, fmuseraccount.FieldPosition)
	}
	if m.department != nil {
		fields = append(fields, fmuseraccount.FieldDepartment)
	}
	if m.email != nil {
		fields = append(fields, fmuseraccount.FieldEmail)
	}
	if m.phonenum != nil {
		fields = append(fields, fmuseraccount.FieldPhonenum)
	}
	if m.description != nil {
		fields = append(fields, fmuseraccount.FieldDescription)
	}
	if m.ethnicity != nil {
		fields = append(fields, fmuseraccount.FieldEthnicity)
	}
	if m.gender != nil {
		fields = append(fields, fmuseraccount.FieldGender)
	}
	if m.local != nil {
		fields = append(fields, fmuseraccount.FieldLocal)
	}
	if m.localhost != nil {
		fields = append(fields, fmuseraccount.FieldLocalhost)
	}
	if m.m2_localhost != nil {
		fields = append(fields, fmuseraccount.FieldM2Localhost)
	}
	if m.ismanager != nil {
		fields = append(fields, fmuseraccount.FieldIsmanager)
	}
	if m.isystem != nil {
		fields = append(fields, fmuseraccount.FieldIsystem)
	}
	if m.enabled != nil {
		fields = append(fields, fmuseraccount.FieldEnabled)
	}
	if m.is_sms != nil {
		fields = append(fields, fmuseraccount.FieldIsSms)
	}
	if m.member_id != nil {
		fields = append(fields, fmuseraccount.FieldMemberID)
	}
	if m.leader_id != nil {
		fields = append(fields, fmuseraccount.FieldLeaderID)
	}
	if m.device_time != nil {
		fields = append(fields, fmuseraccount.FieldDeviceTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, fmuseraccount.FieldTenantID)
	}
	if m.delete_flag != nil {
		fields = append(fields, fmuseraccount.FieldDeleteFlag)
	}
	if m.created_time != nil {
		fields = append(fields, fmuseraccount.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, fmuseraccount.FieldUpdatedTime)
	}
	if m.deleted_time != nil {
		fields = append(fields, fmuseraccount.FieldDeletedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FmUserAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmuseraccount.FieldUsername:
		return m.Username()
	case fmuseraccount.FieldLoginName:
		return m.LoginName()
	case fmuseraccount.FieldPassword:
		return m.Password()
	case fmuseraccount.FieldLeaderFlag:
		return m.LeaderFlag()
	case fmuseraccount.FieldPosition:
		return m.Position()
	case fmuseraccount.FieldDepartment:
		return m.Department()
	case fmuseraccount.FieldEmail:
		return m.Email()
	case fmuseraccount.FieldPhonenum:
		return m.Phonenum()
	case fmuseraccount.FieldDescription:
		return m.Description()
	case fmuseraccount.FieldEthnicity:
		return m.Ethnicity()
	case fmuseraccount.FieldGender:
		return m.Gender()
	case fmuseraccount.FieldLocal:
		return m.Local()
	case fmuseraccount.FieldLocalhost:
		return m.Localhost()
	case fmuseraccount.FieldM2Localhost:
		return m.M2Localhost()
	case fmuseraccount.FieldIsmanager:
		return m.Ismanager()
	case fmuseraccount.FieldIsystem:
		return m.Isystem()
	case fmuseraccount.FieldEnabled:
		return m.Enabled()
	case fmuseraccount.FieldIsSms:
		return m.IsSms()
	case fmuseraccount.FieldMemberID:
		return m.MemberID()
	case fmuseraccount.FieldLeaderID:
		return m.LeaderID()
	case fmuseraccount.FieldDeviceTime:
		return m.DeviceTime()
	case fmuseraccount.FieldTenantID:
		return m.TenantID()
	case fmuseraccount.FieldDeleteFlag:
		return m.DeleteFlag()
	case fmuseraccount.FieldCreatedTime:
		return m.CreatedTime()
	case fmuseraccount.FieldUpdatedTime:
		return m.UpdatedTime()
	case fmuseraccount.FieldDeletedTime:
		return m.DeletedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FmUserAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmuseraccount.FieldUsername:
		return m.OldUsername(ctx)
	case fmuseraccount.FieldLoginName:
		return m.OldLoginName(ctx)
	case fmuseraccount.FieldPassword:
		return m.OldPassword(ctx)
	case fmuseraccount.FieldLeaderFlag:
		return m.OldLeaderFlag(ctx)
	case fmuseraccount.FieldPosition:
		return m.OldPosition(ctx)
	case fmuseraccount.FieldDepartment:
		return m.OldDepartment(ctx)
	case fmuseraccount.FieldEmail:
		return m.OldEmail(ctx)
	case fmuseraccount.FieldPhonenum:
		return m.OldPhonenum(ctx)
	case fmuseraccount.FieldDescription:
		return m.OldDescription(ctx)
	case fmuseraccount.FieldEthnicity:
		return m.OldEthnicity(ctx)
	case fmuseraccount.FieldGender:
		return m.OldGender(ctx)
	case fmuseraccount.FieldLocal:
		return m.OldLocal(ctx)
	case fmuseraccount.FieldLocalhost:
		return m.OldLocalhost(ctx)
	case fmuseraccount.FieldM2Localhost:
		return m.OldM2Localhost(ctx)
	case fmuseraccount.FieldIsmanager:
		return m.OldIsmanager(ctx)
	case fmuseraccount.FieldIsystem:
		return m.OldIsystem(ctx)
	case fmuseraccount.FieldEnabled:
		return m.OldEnabled(ctx)
	case fmuseraccount.FieldIsSms:
		return m.OldIsSms(ctx)
	case fmuseraccount.FieldMemberID:
		return m.OldMemberID(ctx)
	case fmuseraccount.FieldLeaderID:
		return m.OldLeaderID(ctx)
	case fmuseraccount.FieldDeviceTime:
		return m.OldDeviceTime(ctx)
	case fmuseraccount.FieldTenantID:
		return m.OldTenantID(ctx)
	case fmuseraccount.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case fmuseraccount.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case fmuseraccount.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case fmuseraccount.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	}
	return nil, fmt.Errorf("unknown FmUserAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmUserAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmuseraccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case fmuseraccount.FieldLoginName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginName(v)
		return nil
	case fmuseraccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case fmuseraccount.FieldLeaderFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderFlag(v)
		return nil
	case fmuseraccount.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case fmuseraccount.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case fmuseraccount.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case fmuseraccount.FieldPhonenum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonenum(v)
		return nil
	case fmuseraccount.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fmuseraccount.FieldEthnicity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEthnicity(v)
		return nil
	case fmuseraccount.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case fmuseraccount.FieldLocal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocal(v)
		return nil
	case fmuseraccount.FieldLocalhost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalhost(v)
		return nil
	case fmuseraccount.FieldM2Localhost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetM2Localhost(v)
		return nil
	case fmuseraccount.FieldIsmanager:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsmanager(v)
		return nil
	case fmuseraccount.FieldIsystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsystem(v)
		return nil
	case fmuseraccount.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case fmuseraccount.FieldIsSms:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSms(v)
		return nil
	case fmuseraccount.FieldMemberID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case fmuseraccount.FieldLeaderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderID(v)
		return nil
	case fmuseraccount.FieldDeviceTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceTime(v)
		return nil
	case fmuseraccount.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case fmuseraccount.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case fmuseraccount.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case fmuseraccount.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case fmuseraccount.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	}
	return fmt.Errorf("unknown FmUserAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FmUserAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FmUserAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmUserAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FmUserAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FmUserAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmuseraccount.FieldLeaderFlag) {
		fields = append(fields, fmuseraccount.FieldLeaderFlag)
	}
	if m.FieldCleared(fmuseraccount.FieldPosition) {
		fields = append(fields, fmuseraccount.FieldPosition)
	}
	if m.FieldCleared(fmuseraccount.FieldDepartment) {
		fields = append(fields, fmuseraccount.FieldDepartment)
	}
	if m.FieldCleared(fmuseraccount.FieldEmail) {
		fields = append(fields, fmuseraccount.FieldEmail)
	}
	if m.FieldCleared(fmuseraccount.FieldPhonenum) {
		fields = append(fields, fmuseraccount.FieldPhonenum)
	}
	if m.FieldCleared(fmuseraccount.FieldDescription) {
		fields = append(fields, fmuseraccount.FieldDescription)
	}
	if m.FieldCleared(fmuseraccount.FieldEthnicity) {
		fields = append(fields, fmuseraccount.FieldEthnicity)
	}
	if m.FieldCleared(fmuseraccount.FieldGender) {
		fields = append(fields, fmuseraccount.FieldGender)
	}
	if m.FieldCleared(fmuseraccount.FieldLocal) {
		fields = append(fields, fmuseraccount.FieldLocal)
	}
	if m.FieldCleared(fmuseraccount.FieldLocalhost) {
		fields = append(fields, fmuseraccount.FieldLocalhost)
	}
	if m.FieldCleared(fmuseraccount.FieldM2Localhost) {
		fields = append(fields, fmuseraccount.FieldM2Localhost)
	}
	if m.FieldCleared(fmuseraccount.FieldIsmanager) {
		fields = append(fields, fmuseraccount.FieldIsmanager)
	}
	if m.FieldCleared(fmuseraccount.FieldIsystem) {
		fields = append(fields, fmuseraccount.FieldIsystem)
	}
	if m.FieldCleared(fmuseraccount.FieldEnabled) {
		fields = append(fields, fmuseraccount.FieldEnabled)
	}
	if m.FieldCleared(fmuseraccount.FieldIsSms) {
		fields = append(fields, fmuseraccount.FieldIsSms)
	}
	if m.FieldCleared(fmuseraccount.FieldMemberID) {
		fields = append(fields, fmuseraccount.FieldMemberID)
	}
	if m.FieldCleared(fmuseraccount.FieldLeaderID) {
		fields = append(fields, fmuseraccount.FieldLeaderID)
	}
	if m.FieldCleared(fmuseraccount.FieldDeviceTime) {
		fields = append(fields, fmuseraccount.FieldDeviceTime)
	}
	if m.FieldCleared(fmuseraccount.FieldTenantID) {
		fields = append(fields, fmuseraccount.FieldTenantID)
	}
	if m.FieldCleared(fmuseraccount.FieldDeleteFlag) {
		fields = append(fields, fmuseraccount.FieldDeleteFlag)
	}
	if m.FieldCleared(fmuseraccount.FieldCreatedTime) {
		fields = append(fields, fmuseraccount.FieldCreatedTime)
	}
	if m.FieldCleared(fmuseraccount.FieldUpdatedTime) {
		fields = append(fields, fmuseraccount.FieldUpdatedTime)
	}
	if m.FieldCleared(fmuseraccount.FieldDeletedTime) {
		fields = append(fields, fmuseraccount.FieldDeletedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FmUserAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FmUserAccountMutation) ClearField(name string) error {
	switch name {
	case fmuseraccount.FieldLeaderFlag:
		m.ClearLeaderFlag()
		return nil
	case fmuseraccount.FieldPosition:
		m.ClearPosition()
		return nil
	case fmuseraccount.FieldDepartment:
		m.ClearDepartment()
		return nil
	case fmuseraccount.FieldEmail:
		m.ClearEmail()
		return nil
	case fmuseraccount.FieldPhonenum:
		m.ClearPhonenum()
		return nil
	case fmuseraccount.FieldDescription:
		m.ClearDescription()
		return nil
	case fmuseraccount.FieldEthnicity:
		m.ClearEthnicity()
		return nil
	case fmuseraccount.FieldGender:
		m.ClearGender()
		return nil
	case fmuseraccount.FieldLocal:
		m.ClearLocal()
		return nil
	case fmuseraccount.FieldLocalhost:
		m.ClearLocalhost()
		return nil
	case fmuseraccount.FieldM2Localhost:
		m.ClearM2Localhost()
		return nil
	case fmuseraccount.FieldIsmanager:
		m.ClearIsmanager()
		return nil
	case fmuseraccount.FieldIsystem:
		m.ClearIsystem()
		return nil
	case fmuseraccount.FieldEnabled:
		m.ClearEnabled()
		return nil
	case fmuseraccount.FieldIsSms:
		m.ClearIsSms()
		return nil
	case fmuseraccount.FieldMemberID:
		m.ClearMemberID()
		return nil
	case fmuseraccount.FieldLeaderID:
		m.ClearLeaderID()
		return nil
	case fmuseraccount.FieldDeviceTime:
		m.ClearDeviceTime()
		return nil
	case fmuseraccount.FieldTenantID:
		m.ClearTenantID()
		return nil
	case fmuseraccount.FieldDeleteFlag:
		m.ClearDeleteFlag()
		return nil
	case fmuseraccount.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case fmuseraccount.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	case fmuseraccount.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	}
	return fmt.Errorf("unknown FmUserAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FmUserAccountMutation) ResetField(name string) error {
	switch name {
	case fmuseraccount.FieldUsername:
		m.ResetUsername()
		return nil
	case fmuseraccount.FieldLoginName:
		m.ResetLoginName()
		return nil
	case fmuseraccount.FieldPassword:
		m.ResetPassword()
		return nil
	case fmuseraccount.FieldLeaderFlag:
		m.ResetLeaderFlag()
		return nil
	case fmuseraccount.FieldPosition:
		m.ResetPosition()
		return nil
	case fmuseraccount.FieldDepartment:
		m.ResetDepartment()
		return nil
	case fmuseraccount.FieldEmail:
		m.ResetEmail()
		return nil
	case fmuseraccount.FieldPhonenum:
		m.ResetPhonenum()
		return nil
	case fmuseraccount.FieldDescription:
		m.ResetDescription()
		return nil
	case fmuseraccount.FieldEthnicity:
		m.ResetEthnicity()
		return nil
	case fmuseraccount.FieldGender:
		m.ResetGender()
		return nil
	case fmuseraccount.FieldLocal:
		m.ResetLocal()
		return nil
	case fmuseraccount.FieldLocalhost:
		m.ResetLocalhost()
		return nil
	case fmuseraccount.FieldM2Localhost:
		m.ResetM2Localhost()
		return nil
	case fmuseraccount.FieldIsmanager:
		m.ResetIsmanager()
		return nil
	case fmuseraccount.FieldIsystem:
		m.ResetIsystem()
		return nil
	case fmuseraccount.FieldEnabled:
		m.ResetEnabled()
		return nil
	case fmuseraccount.FieldIsSms:
		m.ResetIsSms()
		return nil
	case fmuseraccount.FieldMemberID:
		m.ResetMemberID()
		return nil
	case fmuseraccount.FieldLeaderID:
		m.ResetLeaderID()
		return nil
	case fmuseraccount.FieldDeviceTime:
		m.ResetDeviceTime()
		return nil
	case fmuseraccount.FieldTenantID:
		m.ResetTenantID()
		return nil
	case fmuseraccount.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case fmuseraccount.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case fmuseraccount.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case fmuseraccount.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	}
	return fmt.Errorf("unknown FmUserAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FmUserAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FmUserAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FmUserAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FmUserAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FmUserAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FmUserAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FmUserAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FmUserAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FmUserAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FmUserAccount edge %s", name)
}

// GovAreaMutation represents an operation that mutates the GovArea nodes in the graph.
type GovAreaMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	code          *string
	name          *string
	province_code *string
	city_code     *string
	creator       *string
	delete_flag   *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GovArea, error)
	predicates    []predicate.GovArea
}

var _ ent.Mutation = (*GovAreaMutation)(nil)

// govareaOption allows management of the mutation configuration using functional options.
type govareaOption func(*GovAreaMutation)

// newGovAreaMutation creates new mutation for the GovArea entity.
func newGovAreaMutation(c config, op Op, opts ...govareaOption) *GovAreaMutation {
	m := &GovAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeGovArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGovAreaID sets the ID field of the mutation.
func withGovAreaID(id int64) govareaOption {
	return func(m *GovAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *GovArea
		)
		m.oldValue = func(ctx context.Context) (*GovArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GovArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGovArea sets the old GovArea of the mutation.
func withGovArea(node *GovArea) govareaOption {
	return func(m *GovAreaMutation) {
		m.oldValue = func(context.Context) (*GovArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GovAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GovAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GovArea entities.
func (m *GovAreaMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GovAreaMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GovAreaMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GovArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *GovAreaMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *GovAreaMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *GovAreaMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *GovAreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GovAreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GovAreaMutation) ResetName() {
	m.name = nil
}

// SetProvinceCode sets the "province_code" field.
func (m *GovAreaMutation) SetProvinceCode(s string) {
	m.province_code = &s
}

// ProvinceCode returns the value of the "province_code" field in the mutation.
func (m *GovAreaMutation) ProvinceCode() (r string, exists bool) {
	v := m.province_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceCode returns the old "province_code" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldProvinceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceCode: %w", err)
	}
	return oldValue.ProvinceCode, nil
}

// ResetProvinceCode resets all changes to the "province_code" field.
func (m *GovAreaMutation) ResetProvinceCode() {
	m.province_code = nil
}

// SetCityCode sets the "city_code" field.
func (m *GovAreaMutation) SetCityCode(s string) {
	m.city_code = &s
}

// CityCode returns the value of the "city_code" field in the mutation.
func (m *GovAreaMutation) CityCode() (r string, exists bool) {
	v := m.city_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCityCode returns the old "city_code" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldCityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityCode: %w", err)
	}
	return oldValue.CityCode, nil
}

// ResetCityCode resets all changes to the "city_code" field.
func (m *GovAreaMutation) ResetCityCode() {
	m.city_code = nil
}

// SetCreator sets the "creator" field.
func (m *GovAreaMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *GovAreaMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *GovAreaMutation) ResetCreator() {
	m.creator = nil
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *GovAreaMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *GovAreaMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldDeleteFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *GovAreaMutation) ResetDeleteFlag() {
	m.delete_flag = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *GovAreaMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *GovAreaMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the GovArea entity.
// If the GovArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovAreaMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *GovAreaMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[govarea.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *GovAreaMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[govarea.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *GovAreaMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, govarea.FieldCreatedTime)
}

// Where appends a list predicates to the GovAreaMutation builder.
func (m *GovAreaMutation) Where(ps ...predicate.GovArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GovAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GovAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GovArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GovAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GovAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GovArea).
func (m *GovAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GovAreaMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.code != nil {
		fields = append(fields, govarea.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, govarea.FieldName)
	}
	if m.province_code != nil {
		fields = append(fields, govarea.FieldProvinceCode)
	}
	if m.city_code != nil {
		fields = append(fields, govarea.FieldCityCode)
	}
	if m.creator != nil {
		fields = append(fields, govarea.FieldCreator)
	}
	if m.delete_flag != nil {
		fields = append(fields, govarea.FieldDeleteFlag)
	}
	if m.created_time != nil {
		fields = append(fields, govarea.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GovAreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case govarea.FieldCode:
		return m.Code()
	case govarea.FieldName:
		return m.Name()
	case govarea.FieldProvinceCode:
		return m.ProvinceCode()
	case govarea.FieldCityCode:
		return m.CityCode()
	case govarea.FieldCreator:
		return m.Creator()
	case govarea.FieldDeleteFlag:
		return m.DeleteFlag()
	case govarea.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GovAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case govarea.FieldCode:
		return m.OldCode(ctx)
	case govarea.FieldName:
		return m.OldName(ctx)
	case govarea.FieldProvinceCode:
		return m.OldProvinceCode(ctx)
	case govarea.FieldCityCode:
		return m.OldCityCode(ctx)
	case govarea.FieldCreator:
		return m.OldCreator(ctx)
	case govarea.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case govarea.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown GovArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GovAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case govarea.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case govarea.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case govarea.FieldProvinceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceCode(v)
		return nil
	case govarea.FieldCityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityCode(v)
		return nil
	case govarea.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case govarea.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case govarea.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown GovArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GovAreaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GovAreaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GovAreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GovArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GovAreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(govarea.FieldCreatedTime) {
		fields = append(fields, govarea.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GovAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GovAreaMutation) ClearField(name string) error {
	switch name {
	case govarea.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GovArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GovAreaMutation) ResetField(name string) error {
	switch name {
	case govarea.FieldCode:
		m.ResetCode()
		return nil
	case govarea.FieldName:
		m.ResetName()
		return nil
	case govarea.FieldProvinceCode:
		m.ResetProvinceCode()
		return nil
	case govarea.FieldCityCode:
		m.ResetCityCode()
		return nil
	case govarea.FieldCreator:
		m.ResetCreator()
		return nil
	case govarea.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case govarea.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GovArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GovAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GovAreaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GovAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GovAreaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GovAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GovAreaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GovAreaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GovArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GovAreaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GovArea edge %s", name)
}

// GovCityMutation represents an operation that mutates the GovCity nodes in the graph.
type GovCityMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	code          *string
	name          *string
	province_code *string
	creator       *string
	delete_flag   *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GovCity, error)
	predicates    []predicate.GovCity
}

var _ ent.Mutation = (*GovCityMutation)(nil)

// govcityOption allows management of the mutation configuration using functional options.
type govcityOption func(*GovCityMutation)

// newGovCityMutation creates new mutation for the GovCity entity.
func newGovCityMutation(c config, op Op, opts ...govcityOption) *GovCityMutation {
	m := &GovCityMutation{
		config:        c,
		op:            op,
		typ:           TypeGovCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGovCityID sets the ID field of the mutation.
func withGovCityID(id int64) govcityOption {
	return func(m *GovCityMutation) {
		var (
			err   error
			once  sync.Once
			value *GovCity
		)
		m.oldValue = func(ctx context.Context) (*GovCity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GovCity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGovCity sets the old GovCity of the mutation.
func withGovCity(node *GovCity) govcityOption {
	return func(m *GovCityMutation) {
		m.oldValue = func(context.Context) (*GovCity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GovCityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GovCityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GovCity entities.
func (m *GovCityMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GovCityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GovCityMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GovCity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *GovCityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *GovCityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the GovCity entity.
// If the GovCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovCityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *GovCityMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *GovCityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GovCityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GovCity entity.
// If the GovCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovCityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GovCityMutation) ResetName() {
	m.name = nil
}

// SetProvinceCode sets the "province_code" field.
func (m *GovCityMutation) SetProvinceCode(s string) {
	m.province_code = &s
}

// ProvinceCode returns the value of the "province_code" field in the mutation.
func (m *GovCityMutation) ProvinceCode() (r string, exists bool) {
	v := m.province_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceCode returns the old "province_code" field's value of the GovCity entity.
// If the GovCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovCityMutation) OldProvinceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceCode: %w", err)
	}
	return oldValue.ProvinceCode, nil
}

// ResetProvinceCode resets all changes to the "province_code" field.
func (m *GovCityMutation) ResetProvinceCode() {
	m.province_code = nil
}

// SetCreator sets the "creator" field.
func (m *GovCityMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *GovCityMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the GovCity entity.
// If the GovCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovCityMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *GovCityMutation) ResetCreator() {
	m.creator = nil
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *GovCityMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *GovCityMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the GovCity entity.
// If the GovCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovCityMutation) OldDeleteFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *GovCityMutation) ResetDeleteFlag() {
	m.delete_flag = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *GovCityMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *GovCityMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the GovCity entity.
// If the GovCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovCityMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *GovCityMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[govcity.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *GovCityMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[govcity.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *GovCityMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, govcity.FieldCreatedTime)
}

// Where appends a list predicates to the GovCityMutation builder.
func (m *GovCityMutation) Where(ps ...predicate.GovCity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GovCityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GovCityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GovCity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GovCityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GovCityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GovCity).
func (m *GovCityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GovCityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.code != nil {
		fields = append(fields, govcity.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, govcity.FieldName)
	}
	if m.province_code != nil {
		fields = append(fields, govcity.FieldProvinceCode)
	}
	if m.creator != nil {
		fields = append(fields, govcity.FieldCreator)
	}
	if m.delete_flag != nil {
		fields = append(fields, govcity.FieldDeleteFlag)
	}
	if m.created_time != nil {
		fields = append(fields, govcity.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GovCityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case govcity.FieldCode:
		return m.Code()
	case govcity.FieldName:
		return m.Name()
	case govcity.FieldProvinceCode:
		return m.ProvinceCode()
	case govcity.FieldCreator:
		return m.Creator()
	case govcity.FieldDeleteFlag:
		return m.DeleteFlag()
	case govcity.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GovCityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case govcity.FieldCode:
		return m.OldCode(ctx)
	case govcity.FieldName:
		return m.OldName(ctx)
	case govcity.FieldProvinceCode:
		return m.OldProvinceCode(ctx)
	case govcity.FieldCreator:
		return m.OldCreator(ctx)
	case govcity.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case govcity.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown GovCity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GovCityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case govcity.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case govcity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case govcity.FieldProvinceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceCode(v)
		return nil
	case govcity.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case govcity.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case govcity.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown GovCity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GovCityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GovCityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GovCityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GovCity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GovCityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(govcity.FieldCreatedTime) {
		fields = append(fields, govcity.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GovCityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GovCityMutation) ClearField(name string) error {
	switch name {
	case govcity.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GovCity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GovCityMutation) ResetField(name string) error {
	switch name {
	case govcity.FieldCode:
		m.ResetCode()
		return nil
	case govcity.FieldName:
		m.ResetName()
		return nil
	case govcity.FieldProvinceCode:
		m.ResetProvinceCode()
		return nil
	case govcity.FieldCreator:
		m.ResetCreator()
		return nil
	case govcity.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case govcity.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GovCity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GovCityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GovCityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GovCityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GovCityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GovCityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GovCityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GovCityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GovCity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GovCityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GovCity edge %s", name)
}

// GovStreetMutation represents an operation that mutates the GovStreet nodes in the graph.
type GovStreetMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	code          *string
	name          *string
	province_code *string
	city_code     *string
	area_code     *string
	creator       *string
	delete_flag   *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GovStreet, error)
	predicates    []predicate.GovStreet
}

var _ ent.Mutation = (*GovStreetMutation)(nil)

// govstreetOption allows management of the mutation configuration using functional options.
type govstreetOption func(*GovStreetMutation)

// newGovStreetMutation creates new mutation for the GovStreet entity.
func newGovStreetMutation(c config, op Op, opts ...govstreetOption) *GovStreetMutation {
	m := &GovStreetMutation{
		config:        c,
		op:            op,
		typ:           TypeGovStreet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGovStreetID sets the ID field of the mutation.
func withGovStreetID(id int64) govstreetOption {
	return func(m *GovStreetMutation) {
		var (
			err   error
			once  sync.Once
			value *GovStreet
		)
		m.oldValue = func(ctx context.Context) (*GovStreet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GovStreet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGovStreet sets the old GovStreet of the mutation.
func withGovStreet(node *GovStreet) govstreetOption {
	return func(m *GovStreetMutation) {
		m.oldValue = func(context.Context) (*GovStreet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GovStreetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GovStreetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GovStreet entities.
func (m *GovStreetMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GovStreetMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GovStreetMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GovStreet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *GovStreetMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *GovStreetMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *GovStreetMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *GovStreetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GovStreetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GovStreetMutation) ResetName() {
	m.name = nil
}

// SetProvinceCode sets the "province_code" field.
func (m *GovStreetMutation) SetProvinceCode(s string) {
	m.province_code = &s
}

// ProvinceCode returns the value of the "province_code" field in the mutation.
func (m *GovStreetMutation) ProvinceCode() (r string, exists bool) {
	v := m.province_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceCode returns the old "province_code" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldProvinceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceCode: %w", err)
	}
	return oldValue.ProvinceCode, nil
}

// ResetProvinceCode resets all changes to the "province_code" field.
func (m *GovStreetMutation) ResetProvinceCode() {
	m.province_code = nil
}

// SetCityCode sets the "city_code" field.
func (m *GovStreetMutation) SetCityCode(s string) {
	m.city_code = &s
}

// CityCode returns the value of the "city_code" field in the mutation.
func (m *GovStreetMutation) CityCode() (r string, exists bool) {
	v := m.city_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCityCode returns the old "city_code" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldCityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityCode: %w", err)
	}
	return oldValue.CityCode, nil
}

// ResetCityCode resets all changes to the "city_code" field.
func (m *GovStreetMutation) ResetCityCode() {
	m.city_code = nil
}

// SetAreaCode sets the "area_code" field.
func (m *GovStreetMutation) SetAreaCode(s string) {
	m.area_code = &s
}

// AreaCode returns the value of the "area_code" field in the mutation.
func (m *GovStreetMutation) AreaCode() (r string, exists bool) {
	v := m.area_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaCode returns the old "area_code" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldAreaCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaCode: %w", err)
	}
	return oldValue.AreaCode, nil
}

// ResetAreaCode resets all changes to the "area_code" field.
func (m *GovStreetMutation) ResetAreaCode() {
	m.area_code = nil
}

// SetCreator sets the "creator" field.
func (m *GovStreetMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *GovStreetMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *GovStreetMutation) ResetCreator() {
	m.creator = nil
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *GovStreetMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *GovStreetMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldDeleteFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *GovStreetMutation) ResetDeleteFlag() {
	m.delete_flag = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *GovStreetMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *GovStreetMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the GovStreet entity.
// If the GovStreet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GovStreetMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *GovStreetMutation) ResetCreatedTime() {
	m.created_time = nil
}

// Where appends a list predicates to the GovStreetMutation builder.
func (m *GovStreetMutation) Where(ps ...predicate.GovStreet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GovStreetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GovStreetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GovStreet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GovStreetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GovStreetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GovStreet).
func (m *GovStreetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GovStreetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.code != nil {
		fields = append(fields, govstreet.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, govstreet.FieldName)
	}
	if m.province_code != nil {
		fields = append(fields, govstreet.FieldProvinceCode)
	}
	if m.city_code != nil {
		fields = append(fields, govstreet.FieldCityCode)
	}
	if m.area_code != nil {
		fields = append(fields, govstreet.FieldAreaCode)
	}
	if m.creator != nil {
		fields = append(fields, govstreet.FieldCreator)
	}
	if m.delete_flag != nil {
		fields = append(fields, govstreet.FieldDeleteFlag)
	}
	if m.created_time != nil {
		fields = append(fields, govstreet.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GovStreetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case govstreet.FieldCode:
		return m.Code()
	case govstreet.FieldName:
		return m.Name()
	case govstreet.FieldProvinceCode:
		return m.ProvinceCode()
	case govstreet.FieldCityCode:
		return m.CityCode()
	case govstreet.FieldAreaCode:
		return m.AreaCode()
	case govstreet.FieldCreator:
		return m.Creator()
	case govstreet.FieldDeleteFlag:
		return m.DeleteFlag()
	case govstreet.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GovStreetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case govstreet.FieldCode:
		return m.OldCode(ctx)
	case govstreet.FieldName:
		return m.OldName(ctx)
	case govstreet.FieldProvinceCode:
		return m.OldProvinceCode(ctx)
	case govstreet.FieldCityCode:
		return m.OldCityCode(ctx)
	case govstreet.FieldAreaCode:
		return m.OldAreaCode(ctx)
	case govstreet.FieldCreator:
		return m.OldCreator(ctx)
	case govstreet.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case govstreet.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown GovStreet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GovStreetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case govstreet.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case govstreet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case govstreet.FieldProvinceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceCode(v)
		return nil
	case govstreet.FieldCityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityCode(v)
		return nil
	case govstreet.FieldAreaCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaCode(v)
		return nil
	case govstreet.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case govstreet.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case govstreet.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown GovStreet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GovStreetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GovStreetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GovStreetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GovStreet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GovStreetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GovStreetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GovStreetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GovStreet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GovStreetMutation) ResetField(name string) error {
	switch name {
	case govstreet.FieldCode:
		m.ResetCode()
		return nil
	case govstreet.FieldName:
		m.ResetName()
		return nil
	case govstreet.FieldProvinceCode:
		m.ResetProvinceCode()
		return nil
	case govstreet.FieldCityCode:
		m.ResetCityCode()
		return nil
	case govstreet.FieldAreaCode:
		m.ResetAreaCode()
		return nil
	case govstreet.FieldCreator:
		m.ResetCreator()
		return nil
	case govstreet.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case govstreet.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GovStreet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GovStreetMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GovStreetMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GovStreetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GovStreetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GovStreetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GovStreetMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GovStreetMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GovStreet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GovStreetMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GovStreet edge %s", name)
}

// GrouProfileTypeMappingMutation represents an operation that mutates the GrouProfileTypeMapping nodes in the graph.
type GrouProfileTypeMappingMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	group_id           *int64
	addgroup_id        *int64
	profile_type_id    *int64
	addprofile_type_id *int64
	creator            *string
	created_time       *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*GrouProfileTypeMapping, error)
	predicates         []predicate.GrouProfileTypeMapping
}

var _ ent.Mutation = (*GrouProfileTypeMappingMutation)(nil)

// grouprofiletypemappingOption allows management of the mutation configuration using functional options.
type grouprofiletypemappingOption func(*GrouProfileTypeMappingMutation)

// newGrouProfileTypeMappingMutation creates new mutation for the GrouProfileTypeMapping entity.
func newGrouProfileTypeMappingMutation(c config, op Op, opts ...grouprofiletypemappingOption) *GrouProfileTypeMappingMutation {
	m := &GrouProfileTypeMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeGrouProfileTypeMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrouProfileTypeMappingID sets the ID field of the mutation.
func withGrouProfileTypeMappingID(id int64) grouprofiletypemappingOption {
	return func(m *GrouProfileTypeMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *GrouProfileTypeMapping
		)
		m.oldValue = func(ctx context.Context) (*GrouProfileTypeMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GrouProfileTypeMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrouProfileTypeMapping sets the old GrouProfileTypeMapping of the mutation.
func withGrouProfileTypeMapping(node *GrouProfileTypeMapping) grouprofiletypemappingOption {
	return func(m *GrouProfileTypeMappingMutation) {
		m.oldValue = func(context.Context) (*GrouProfileTypeMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrouProfileTypeMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrouProfileTypeMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GrouProfileTypeMapping entities.
func (m *GrouProfileTypeMappingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrouProfileTypeMappingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrouProfileTypeMappingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GrouProfileTypeMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupID sets the "group_id" field.
func (m *GrouProfileTypeMappingMutation) SetGroupID(i int64) {
	m.group_id = &i
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GrouProfileTypeMappingMutation) GroupID() (r int64, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GrouProfileTypeMapping entity.
// If the GrouProfileTypeMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrouProfileTypeMappingMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds i to the "group_id" field.
func (m *GrouProfileTypeMappingMutation) AddGroupID(i int64) {
	if m.addgroup_id != nil {
		*m.addgroup_id += i
	} else {
		m.addgroup_id = &i
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *GrouProfileTypeMappingMutation) AddedGroupID() (r int64, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GrouProfileTypeMappingMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
}

// SetProfileTypeID sets the "profile_type_id" field.
func (m *GrouProfileTypeMappingMutation) SetProfileTypeID(i int64) {
	m.profile_type_id = &i
	m.addprofile_type_id = nil
}

// ProfileTypeID returns the value of the "profile_type_id" field in the mutation.
func (m *GrouProfileTypeMappingMutation) ProfileTypeID() (r int64, exists bool) {
	v := m.profile_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileTypeID returns the old "profile_type_id" field's value of the GrouProfileTypeMapping entity.
// If the GrouProfileTypeMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrouProfileTypeMappingMutation) OldProfileTypeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileTypeID: %w", err)
	}
	return oldValue.ProfileTypeID, nil
}

// AddProfileTypeID adds i to the "profile_type_id" field.
func (m *GrouProfileTypeMappingMutation) AddProfileTypeID(i int64) {
	if m.addprofile_type_id != nil {
		*m.addprofile_type_id += i
	} else {
		m.addprofile_type_id = &i
	}
}

// AddedProfileTypeID returns the value that was added to the "profile_type_id" field in this mutation.
func (m *GrouProfileTypeMappingMutation) AddedProfileTypeID() (r int64, exists bool) {
	v := m.addprofile_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProfileTypeID resets all changes to the "profile_type_id" field.
func (m *GrouProfileTypeMappingMutation) ResetProfileTypeID() {
	m.profile_type_id = nil
	m.addprofile_type_id = nil
}

// SetCreator sets the "creator" field.
func (m *GrouProfileTypeMappingMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *GrouProfileTypeMappingMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the GrouProfileTypeMapping entity.
// If the GrouProfileTypeMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrouProfileTypeMappingMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *GrouProfileTypeMappingMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *GrouProfileTypeMappingMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *GrouProfileTypeMappingMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the GrouProfileTypeMapping entity.
// If the GrouProfileTypeMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrouProfileTypeMappingMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *GrouProfileTypeMappingMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[grouprofiletypemapping.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *GrouProfileTypeMappingMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[grouprofiletypemapping.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *GrouProfileTypeMappingMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, grouprofiletypemapping.FieldCreatedTime)
}

// Where appends a list predicates to the GrouProfileTypeMappingMutation builder.
func (m *GrouProfileTypeMappingMutation) Where(ps ...predicate.GrouProfileTypeMapping) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrouProfileTypeMappingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrouProfileTypeMappingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GrouProfileTypeMapping, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrouProfileTypeMappingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrouProfileTypeMappingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GrouProfileTypeMapping).
func (m *GrouProfileTypeMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrouProfileTypeMappingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.group_id != nil {
		fields = append(fields, grouprofiletypemapping.FieldGroupID)
	}
	if m.profile_type_id != nil {
		fields = append(fields, grouprofiletypemapping.FieldProfileTypeID)
	}
	if m.creator != nil {
		fields = append(fields, grouprofiletypemapping.FieldCreator)
	}
	if m.created_time != nil {
		fields = append(fields, grouprofiletypemapping.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrouProfileTypeMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grouprofiletypemapping.FieldGroupID:
		return m.GroupID()
	case grouprofiletypemapping.FieldProfileTypeID:
		return m.ProfileTypeID()
	case grouprofiletypemapping.FieldCreator:
		return m.Creator()
	case grouprofiletypemapping.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrouProfileTypeMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grouprofiletypemapping.FieldGroupID:
		return m.OldGroupID(ctx)
	case grouprofiletypemapping.FieldProfileTypeID:
		return m.OldProfileTypeID(ctx)
	case grouprofiletypemapping.FieldCreator:
		return m.OldCreator(ctx)
	case grouprofiletypemapping.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown GrouProfileTypeMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrouProfileTypeMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grouprofiletypemapping.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case grouprofiletypemapping.FieldProfileTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileTypeID(v)
		return nil
	case grouprofiletypemapping.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case grouprofiletypemapping.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown GrouProfileTypeMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrouProfileTypeMappingMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_id != nil {
		fields = append(fields, grouprofiletypemapping.FieldGroupID)
	}
	if m.addprofile_type_id != nil {
		fields = append(fields, grouprofiletypemapping.FieldProfileTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrouProfileTypeMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grouprofiletypemapping.FieldGroupID:
		return m.AddedGroupID()
	case grouprofiletypemapping.FieldProfileTypeID:
		return m.AddedProfileTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrouProfileTypeMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grouprofiletypemapping.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	case grouprofiletypemapping.FieldProfileTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfileTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown GrouProfileTypeMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrouProfileTypeMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grouprofiletypemapping.FieldCreatedTime) {
		fields = append(fields, grouprofiletypemapping.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrouProfileTypeMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrouProfileTypeMappingMutation) ClearField(name string) error {
	switch name {
	case grouprofiletypemapping.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GrouProfileTypeMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrouProfileTypeMappingMutation) ResetField(name string) error {
	switch name {
	case grouprofiletypemapping.FieldGroupID:
		m.ResetGroupID()
		return nil
	case grouprofiletypemapping.FieldProfileTypeID:
		m.ResetProfileTypeID()
		return nil
	case grouprofiletypemapping.FieldCreator:
		m.ResetCreator()
		return nil
	case grouprofiletypemapping.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown GrouProfileTypeMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrouProfileTypeMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrouProfileTypeMappingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrouProfileTypeMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrouProfileTypeMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrouProfileTypeMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrouProfileTypeMappingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrouProfileTypeMappingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GrouProfileTypeMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrouProfileTypeMappingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GrouProfileTypeMapping edge %s", name)
}

// ProfileTypeMutation represents an operation that mutates the ProfileType nodes in the graph.
type ProfileTypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	type_name              *string
	warning_level          *int
	addwarning_level       *int
	warning_enabled        *bool
	tenant_id              *uuid.UUID
	description            *string
	deleteable             *bool
	enabled                *bool
	type_code              *string
	face_validity_hours    *int
	addface_validity_hours *int
	created_time           *time.Time
	updated_time           *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProfileType, error)
	predicates             []predicate.ProfileType
}

var _ ent.Mutation = (*ProfileTypeMutation)(nil)

// profiletypeOption allows management of the mutation configuration using functional options.
type profiletypeOption func(*ProfileTypeMutation)

// newProfileTypeMutation creates new mutation for the ProfileType entity.
func newProfileTypeMutation(c config, op Op, opts ...profiletypeOption) *ProfileTypeMutation {
	m := &ProfileTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProfileType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileTypeID sets the ID field of the mutation.
func withProfileTypeID(id int64) profiletypeOption {
	return func(m *ProfileTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfileType
		)
		m.oldValue = func(ctx context.Context) (*ProfileType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfileType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfileType sets the old ProfileType of the mutation.
func withProfileType(node *ProfileType) profiletypeOption {
	return func(m *ProfileTypeMutation) {
		m.oldValue = func(context.Context) (*ProfileType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfileType entities.
func (m *ProfileTypeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileTypeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfileType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTypeName sets the "type_name" field.
func (m *ProfileTypeMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *ProfileTypeMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *ProfileTypeMutation) ResetTypeName() {
	m.type_name = nil
}

// SetWarningLevel sets the "warning_level" field.
func (m *ProfileTypeMutation) SetWarningLevel(i int) {
	m.warning_level = &i
	m.addwarning_level = nil
}

// WarningLevel returns the value of the "warning_level" field in the mutation.
func (m *ProfileTypeMutation) WarningLevel() (r int, exists bool) {
	v := m.warning_level
	if v == nil {
		return
	}
	return *v, true
}

// OldWarningLevel returns the old "warning_level" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldWarningLevel(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarningLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarningLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarningLevel: %w", err)
	}
	return oldValue.WarningLevel, nil
}

// AddWarningLevel adds i to the "warning_level" field.
func (m *ProfileTypeMutation) AddWarningLevel(i int) {
	if m.addwarning_level != nil {
		*m.addwarning_level += i
	} else {
		m.addwarning_level = &i
	}
}

// AddedWarningLevel returns the value that was added to the "warning_level" field in this mutation.
func (m *ProfileTypeMutation) AddedWarningLevel() (r int, exists bool) {
	v := m.addwarning_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearWarningLevel clears the value of the "warning_level" field.
func (m *ProfileTypeMutation) ClearWarningLevel() {
	m.warning_level = nil
	m.addwarning_level = nil
	m.clearedFields[profiletype.FieldWarningLevel] = struct{}{}
}

// WarningLevelCleared returns if the "warning_level" field was cleared in this mutation.
func (m *ProfileTypeMutation) WarningLevelCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldWarningLevel]
	return ok
}

// ResetWarningLevel resets all changes to the "warning_level" field.
func (m *ProfileTypeMutation) ResetWarningLevel() {
	m.warning_level = nil
	m.addwarning_level = nil
	delete(m.clearedFields, profiletype.FieldWarningLevel)
}

// SetWarningEnabled sets the "warning_enabled" field.
func (m *ProfileTypeMutation) SetWarningEnabled(b bool) {
	m.warning_enabled = &b
}

// WarningEnabled returns the value of the "warning_enabled" field in the mutation.
func (m *ProfileTypeMutation) WarningEnabled() (r bool, exists bool) {
	v := m.warning_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldWarningEnabled returns the old "warning_enabled" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldWarningEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarningEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarningEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarningEnabled: %w", err)
	}
	return oldValue.WarningEnabled, nil
}

// ClearWarningEnabled clears the value of the "warning_enabled" field.
func (m *ProfileTypeMutation) ClearWarningEnabled() {
	m.warning_enabled = nil
	m.clearedFields[profiletype.FieldWarningEnabled] = struct{}{}
}

// WarningEnabledCleared returns if the "warning_enabled" field was cleared in this mutation.
func (m *ProfileTypeMutation) WarningEnabledCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldWarningEnabled]
	return ok
}

// ResetWarningEnabled resets all changes to the "warning_enabled" field.
func (m *ProfileTypeMutation) ResetWarningEnabled() {
	m.warning_enabled = nil
	delete(m.clearedFields, profiletype.FieldWarningEnabled)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProfileTypeMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProfileTypeMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ProfileTypeMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[profiletype.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ProfileTypeMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProfileTypeMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, profiletype.FieldTenantID)
}

// SetDescription sets the "description" field.
func (m *ProfileTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProfileTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProfileTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[profiletype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProfileTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProfileTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, profiletype.FieldDescription)
}

// SetDeleteable sets the "deleteable" field.
func (m *ProfileTypeMutation) SetDeleteable(b bool) {
	m.deleteable = &b
}

// Deleteable returns the value of the "deleteable" field in the mutation.
func (m *ProfileTypeMutation) Deleteable() (r bool, exists bool) {
	v := m.deleteable
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteable returns the old "deleteable" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldDeleteable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteable: %w", err)
	}
	return oldValue.Deleteable, nil
}

// ClearDeleteable clears the value of the "deleteable" field.
func (m *ProfileTypeMutation) ClearDeleteable() {
	m.deleteable = nil
	m.clearedFields[profiletype.FieldDeleteable] = struct{}{}
}

// DeleteableCleared returns if the "deleteable" field was cleared in this mutation.
func (m *ProfileTypeMutation) DeleteableCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldDeleteable]
	return ok
}

// ResetDeleteable resets all changes to the "deleteable" field.
func (m *ProfileTypeMutation) ResetDeleteable() {
	m.deleteable = nil
	delete(m.clearedFields, profiletype.FieldDeleteable)
}

// SetEnabled sets the "enabled" field.
func (m *ProfileTypeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ProfileTypeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *ProfileTypeMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[profiletype.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *ProfileTypeMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ProfileTypeMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, profiletype.FieldEnabled)
}

// SetTypeCode sets the "type_code" field.
func (m *ProfileTypeMutation) SetTypeCode(s string) {
	m.type_code = &s
}

// TypeCode returns the value of the "type_code" field in the mutation.
func (m *ProfileTypeMutation) TypeCode() (r string, exists bool) {
	v := m.type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "type_code" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldTypeCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ClearTypeCode clears the value of the "type_code" field.
func (m *ProfileTypeMutation) ClearTypeCode() {
	m.type_code = nil
	m.clearedFields[profiletype.FieldTypeCode] = struct{}{}
}

// TypeCodeCleared returns if the "type_code" field was cleared in this mutation.
func (m *ProfileTypeMutation) TypeCodeCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldTypeCode]
	return ok
}

// ResetTypeCode resets all changes to the "type_code" field.
func (m *ProfileTypeMutation) ResetTypeCode() {
	m.type_code = nil
	delete(m.clearedFields, profiletype.FieldTypeCode)
}

// SetFaceValidityHours sets the "face_validity_hours" field.
func (m *ProfileTypeMutation) SetFaceValidityHours(i int) {
	m.face_validity_hours = &i
	m.addface_validity_hours = nil
}

// FaceValidityHours returns the value of the "face_validity_hours" field in the mutation.
func (m *ProfileTypeMutation) FaceValidityHours() (r int, exists bool) {
	v := m.face_validity_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceValidityHours returns the old "face_validity_hours" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldFaceValidityHours(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceValidityHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceValidityHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceValidityHours: %w", err)
	}
	return oldValue.FaceValidityHours, nil
}

// AddFaceValidityHours adds i to the "face_validity_hours" field.
func (m *ProfileTypeMutation) AddFaceValidityHours(i int) {
	if m.addface_validity_hours != nil {
		*m.addface_validity_hours += i
	} else {
		m.addface_validity_hours = &i
	}
}

// AddedFaceValidityHours returns the value that was added to the "face_validity_hours" field in this mutation.
func (m *ProfileTypeMutation) AddedFaceValidityHours() (r int, exists bool) {
	v := m.addface_validity_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearFaceValidityHours clears the value of the "face_validity_hours" field.
func (m *ProfileTypeMutation) ClearFaceValidityHours() {
	m.face_validity_hours = nil
	m.addface_validity_hours = nil
	m.clearedFields[profiletype.FieldFaceValidityHours] = struct{}{}
}

// FaceValidityHoursCleared returns if the "face_validity_hours" field was cleared in this mutation.
func (m *ProfileTypeMutation) FaceValidityHoursCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldFaceValidityHours]
	return ok
}

// ResetFaceValidityHours resets all changes to the "face_validity_hours" field.
func (m *ProfileTypeMutation) ResetFaceValidityHours() {
	m.face_validity_hours = nil
	m.addface_validity_hours = nil
	delete(m.clearedFields, profiletype.FieldFaceValidityHours)
}

// SetCreatedTime sets the "created_time" field.
func (m *ProfileTypeMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProfileTypeMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *ProfileTypeMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[profiletype.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *ProfileTypeMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProfileTypeMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, profiletype.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *ProfileTypeMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *ProfileTypeMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the ProfileType entity.
// If the ProfileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileTypeMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *ProfileTypeMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[profiletype.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *ProfileTypeMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[profiletype.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *ProfileTypeMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, profiletype.FieldUpdatedTime)
}

// Where appends a list predicates to the ProfileTypeMutation builder.
func (m *ProfileTypeMutation) Where(ps ...predicate.ProfileType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfileType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfileType).
func (m *ProfileTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileTypeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.type_name != nil {
		fields = append(fields, profiletype.FieldTypeName)
	}
	if m.warning_level != nil {
		fields = append(fields, profiletype.FieldWarningLevel)
	}
	if m.warning_enabled != nil {
		fields = append(fields, profiletype.FieldWarningEnabled)
	}
	if m.tenant_id != nil {
		fields = append(fields, profiletype.FieldTenantID)
	}
	if m.description != nil {
		fields = append(fields, profiletype.FieldDescription)
	}
	if m.deleteable != nil {
		fields = append(fields, profiletype.FieldDeleteable)
	}
	if m.enabled != nil {
		fields = append(fields, profiletype.FieldEnabled)
	}
	if m.type_code != nil {
		fields = append(fields, profiletype.FieldTypeCode)
	}
	if m.face_validity_hours != nil {
		fields = append(fields, profiletype.FieldFaceValidityHours)
	}
	if m.created_time != nil {
		fields = append(fields, profiletype.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, profiletype.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profiletype.FieldTypeName:
		return m.TypeName()
	case profiletype.FieldWarningLevel:
		return m.WarningLevel()
	case profiletype.FieldWarningEnabled:
		return m.WarningEnabled()
	case profiletype.FieldTenantID:
		return m.TenantID()
	case profiletype.FieldDescription:
		return m.Description()
	case profiletype.FieldDeleteable:
		return m.Deleteable()
	case profiletype.FieldEnabled:
		return m.Enabled()
	case profiletype.FieldTypeCode:
		return m.TypeCode()
	case profiletype.FieldFaceValidityHours:
		return m.FaceValidityHours()
	case profiletype.FieldCreatedTime:
		return m.CreatedTime()
	case profiletype.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profiletype.FieldTypeName:
		return m.OldTypeName(ctx)
	case profiletype.FieldWarningLevel:
		return m.OldWarningLevel(ctx)
	case profiletype.FieldWarningEnabled:
		return m.OldWarningEnabled(ctx)
	case profiletype.FieldTenantID:
		return m.OldTenantID(ctx)
	case profiletype.FieldDescription:
		return m.OldDescription(ctx)
	case profiletype.FieldDeleteable:
		return m.OldDeleteable(ctx)
	case profiletype.FieldEnabled:
		return m.OldEnabled(ctx)
	case profiletype.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case profiletype.FieldFaceValidityHours:
		return m.OldFaceValidityHours(ctx)
	case profiletype.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case profiletype.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown ProfileType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profiletype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case profiletype.FieldWarningLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarningLevel(v)
		return nil
	case profiletype.FieldWarningEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarningEnabled(v)
		return nil
	case profiletype.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case profiletype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case profiletype.FieldDeleteable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteable(v)
		return nil
	case profiletype.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case profiletype.FieldTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case profiletype.FieldFaceValidityHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceValidityHours(v)
		return nil
	case profiletype.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case profiletype.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProfileType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileTypeMutation) AddedFields() []string {
	var fields []string
	if m.addwarning_level != nil {
		fields = append(fields, profiletype.FieldWarningLevel)
	}
	if m.addface_validity_hours != nil {
		fields = append(fields, profiletype.FieldFaceValidityHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profiletype.FieldWarningLevel:
		return m.AddedWarningLevel()
	case profiletype.FieldFaceValidityHours:
		return m.AddedFaceValidityHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profiletype.FieldWarningLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarningLevel(v)
		return nil
	case profiletype.FieldFaceValidityHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFaceValidityHours(v)
		return nil
	}
	return fmt.Errorf("unknown ProfileType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profiletype.FieldWarningLevel) {
		fields = append(fields, profiletype.FieldWarningLevel)
	}
	if m.FieldCleared(profiletype.FieldWarningEnabled) {
		fields = append(fields, profiletype.FieldWarningEnabled)
	}
	if m.FieldCleared(profiletype.FieldTenantID) {
		fields = append(fields, profiletype.FieldTenantID)
	}
	if m.FieldCleared(profiletype.FieldDescription) {
		fields = append(fields, profiletype.FieldDescription)
	}
	if m.FieldCleared(profiletype.FieldDeleteable) {
		fields = append(fields, profiletype.FieldDeleteable)
	}
	if m.FieldCleared(profiletype.FieldEnabled) {
		fields = append(fields, profiletype.FieldEnabled)
	}
	if m.FieldCleared(profiletype.FieldTypeCode) {
		fields = append(fields, profiletype.FieldTypeCode)
	}
	if m.FieldCleared(profiletype.FieldFaceValidityHours) {
		fields = append(fields, profiletype.FieldFaceValidityHours)
	}
	if m.FieldCleared(profiletype.FieldCreatedTime) {
		fields = append(fields, profiletype.FieldCreatedTime)
	}
	if m.FieldCleared(profiletype.FieldUpdatedTime) {
		fields = append(fields, profiletype.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileTypeMutation) ClearField(name string) error {
	switch name {
	case profiletype.FieldWarningLevel:
		m.ClearWarningLevel()
		return nil
	case profiletype.FieldWarningEnabled:
		m.ClearWarningEnabled()
		return nil
	case profiletype.FieldTenantID:
		m.ClearTenantID()
		return nil
	case profiletype.FieldDescription:
		m.ClearDescription()
		return nil
	case profiletype.FieldDeleteable:
		m.ClearDeleteable()
		return nil
	case profiletype.FieldEnabled:
		m.ClearEnabled()
		return nil
	case profiletype.FieldTypeCode:
		m.ClearTypeCode()
		return nil
	case profiletype.FieldFaceValidityHours:
		m.ClearFaceValidityHours()
		return nil
	case profiletype.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case profiletype.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown ProfileType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileTypeMutation) ResetField(name string) error {
	switch name {
	case profiletype.FieldTypeName:
		m.ResetTypeName()
		return nil
	case profiletype.FieldWarningLevel:
		m.ResetWarningLevel()
		return nil
	case profiletype.FieldWarningEnabled:
		m.ResetWarningEnabled()
		return nil
	case profiletype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case profiletype.FieldDescription:
		m.ResetDescription()
		return nil
	case profiletype.FieldDeleteable:
		m.ResetDeleteable()
		return nil
	case profiletype.FieldEnabled:
		m.ResetEnabled()
		return nil
	case profiletype.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case profiletype.FieldFaceValidityHours:
		m.ResetFaceValidityHours()
		return nil
	case profiletype.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case profiletype.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown ProfileType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProfileType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProfileType edge %s", name)
}

// ProfilesMutation represents an operation that mutates the Profiles nodes in the graph.
type ProfilesMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	type_id        *int64
	addtype_id     *int64
	name           *string
	tenant_id      *uuid.UUID
	id_card_number *string
	phone_number   *string
	enabled        *bool
	room_id        *string
	tmp_url        *string
	created_time   *time.Time
	updated_time   *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Profiles, error)
	predicates     []predicate.Profiles
}

var _ ent.Mutation = (*ProfilesMutation)(nil)

// profilesOption allows management of the mutation configuration using functional options.
type profilesOption func(*ProfilesMutation)

// newProfilesMutation creates new mutation for the Profiles entity.
func newProfilesMutation(c config, op Op, opts ...profilesOption) *ProfilesMutation {
	m := &ProfilesMutation{
		config:        c,
		op:            op,
		typ:           TypeProfiles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfilesID sets the ID field of the mutation.
func withProfilesID(id int64) profilesOption {
	return func(m *ProfilesMutation) {
		var (
			err   error
			once  sync.Once
			value *Profiles
		)
		m.oldValue = func(ctx context.Context) (*Profiles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profiles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfiles sets the old Profiles of the mutation.
func withProfiles(node *Profiles) profilesOption {
	return func(m *ProfilesMutation) {
		m.oldValue = func(context.Context) (*Profiles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfilesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfilesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profiles entities.
func (m *ProfilesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfilesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfilesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profiles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTypeID sets the "type_id" field.
func (m *ProfilesMutation) SetTypeID(i int64) {
	m.type_id = &i
	m.addtype_id = nil
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *ProfilesMutation) TypeID() (r int64, exists bool) {
	v := m.type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldTypeID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// AddTypeID adds i to the "type_id" field.
func (m *ProfilesMutation) AddTypeID(i int64) {
	if m.addtype_id != nil {
		*m.addtype_id += i
	} else {
		m.addtype_id = &i
	}
}

// AddedTypeID returns the value that was added to the "type_id" field in this mutation.
func (m *ProfilesMutation) AddedTypeID() (r int64, exists bool) {
	v := m.addtype_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTypeID clears the value of the "type_id" field.
func (m *ProfilesMutation) ClearTypeID() {
	m.type_id = nil
	m.addtype_id = nil
	m.clearedFields[profiles.FieldTypeID] = struct{}{}
}

// TypeIDCleared returns if the "type_id" field was cleared in this mutation.
func (m *ProfilesMutation) TypeIDCleared() bool {
	_, ok := m.clearedFields[profiles.FieldTypeID]
	return ok
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *ProfilesMutation) ResetTypeID() {
	m.type_id = nil
	m.addtype_id = nil
	delete(m.clearedFields, profiles.FieldTypeID)
}

// SetName sets the "name" field.
func (m *ProfilesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProfilesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProfilesMutation) ClearName() {
	m.name = nil
	m.clearedFields[profiles.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProfilesMutation) NameCleared() bool {
	_, ok := m.clearedFields[profiles.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProfilesMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, profiles.FieldName)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProfilesMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProfilesMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ProfilesMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[profiles.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ProfilesMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[profiles.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProfilesMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, profiles.FieldTenantID)
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *ProfilesMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *ProfilesMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldIDCardNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ClearIDCardNumber clears the value of the "id_card_number" field.
func (m *ProfilesMutation) ClearIDCardNumber() {
	m.id_card_number = nil
	m.clearedFields[profiles.FieldIDCardNumber] = struct{}{}
}

// IDCardNumberCleared returns if the "id_card_number" field was cleared in this mutation.
func (m *ProfilesMutation) IDCardNumberCleared() bool {
	_, ok := m.clearedFields[profiles.FieldIDCardNumber]
	return ok
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *ProfilesMutation) ResetIDCardNumber() {
	m.id_card_number = nil
	delete(m.clearedFields, profiles.FieldIDCardNumber)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *ProfilesMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *ProfilesMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *ProfilesMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[profiles.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *ProfilesMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[profiles.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *ProfilesMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, profiles.FieldPhoneNumber)
}

// SetEnabled sets the "enabled" field.
func (m *ProfilesMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ProfilesMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldEnabled(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *ProfilesMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[profiles.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *ProfilesMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[profiles.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ProfilesMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, profiles.FieldEnabled)
}

// SetRoomID sets the "room_id" field.
func (m *ProfilesMutation) SetRoomID(s string) {
	m.room_id = &s
}

// RoomID returns the value of the "room_id" field in the mutation.
func (m *ProfilesMutation) RoomID() (r string, exists bool) {
	v := m.room_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomID returns the old "room_id" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldRoomID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomID: %w", err)
	}
	return oldValue.RoomID, nil
}

// ClearRoomID clears the value of the "room_id" field.
func (m *ProfilesMutation) ClearRoomID() {
	m.room_id = nil
	m.clearedFields[profiles.FieldRoomID] = struct{}{}
}

// RoomIDCleared returns if the "room_id" field was cleared in this mutation.
func (m *ProfilesMutation) RoomIDCleared() bool {
	_, ok := m.clearedFields[profiles.FieldRoomID]
	return ok
}

// ResetRoomID resets all changes to the "room_id" field.
func (m *ProfilesMutation) ResetRoomID() {
	m.room_id = nil
	delete(m.clearedFields, profiles.FieldRoomID)
}

// SetTmpURL sets the "tmp_url" field.
func (m *ProfilesMutation) SetTmpURL(s string) {
	m.tmp_url = &s
}

// TmpURL returns the value of the "tmp_url" field in the mutation.
func (m *ProfilesMutation) TmpURL() (r string, exists bool) {
	v := m.tmp_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTmpURL returns the old "tmp_url" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldTmpURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTmpURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTmpURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTmpURL: %w", err)
	}
	return oldValue.TmpURL, nil
}

// ClearTmpURL clears the value of the "tmp_url" field.
func (m *ProfilesMutation) ClearTmpURL() {
	m.tmp_url = nil
	m.clearedFields[profiles.FieldTmpURL] = struct{}{}
}

// TmpURLCleared returns if the "tmp_url" field was cleared in this mutation.
func (m *ProfilesMutation) TmpURLCleared() bool {
	_, ok := m.clearedFields[profiles.FieldTmpURL]
	return ok
}

// ResetTmpURL resets all changes to the "tmp_url" field.
func (m *ProfilesMutation) ResetTmpURL() {
	m.tmp_url = nil
	delete(m.clearedFields, profiles.FieldTmpURL)
}

// SetCreatedTime sets the "created_time" field.
func (m *ProfilesMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProfilesMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *ProfilesMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[profiles.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *ProfilesMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[profiles.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProfilesMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, profiles.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *ProfilesMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *ProfilesMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Profiles entity.
// If the Profiles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfilesMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *ProfilesMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[profiles.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *ProfilesMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[profiles.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *ProfilesMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, profiles.FieldUpdatedTime)
}

// Where appends a list predicates to the ProfilesMutation builder.
func (m *ProfilesMutation) Where(ps ...predicate.Profiles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfilesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfilesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profiles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfilesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfilesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profiles).
func (m *ProfilesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfilesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.type_id != nil {
		fields = append(fields, profiles.FieldTypeID)
	}
	if m.name != nil {
		fields = append(fields, profiles.FieldName)
	}
	if m.tenant_id != nil {
		fields = append(fields, profiles.FieldTenantID)
	}
	if m.id_card_number != nil {
		fields = append(fields, profiles.FieldIDCardNumber)
	}
	if m.phone_number != nil {
		fields = append(fields, profiles.FieldPhoneNumber)
	}
	if m.enabled != nil {
		fields = append(fields, profiles.FieldEnabled)
	}
	if m.room_id != nil {
		fields = append(fields, profiles.FieldRoomID)
	}
	if m.tmp_url != nil {
		fields = append(fields, profiles.FieldTmpURL)
	}
	if m.created_time != nil {
		fields = append(fields, profiles.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, profiles.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfilesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profiles.FieldTypeID:
		return m.TypeID()
	case profiles.FieldName:
		return m.Name()
	case profiles.FieldTenantID:
		return m.TenantID()
	case profiles.FieldIDCardNumber:
		return m.IDCardNumber()
	case profiles.FieldPhoneNumber:
		return m.PhoneNumber()
	case profiles.FieldEnabled:
		return m.Enabled()
	case profiles.FieldRoomID:
		return m.RoomID()
	case profiles.FieldTmpURL:
		return m.TmpURL()
	case profiles.FieldCreatedTime:
		return m.CreatedTime()
	case profiles.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfilesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profiles.FieldTypeID:
		return m.OldTypeID(ctx)
	case profiles.FieldName:
		return m.OldName(ctx)
	case profiles.FieldTenantID:
		return m.OldTenantID(ctx)
	case profiles.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case profiles.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case profiles.FieldEnabled:
		return m.OldEnabled(ctx)
	case profiles.FieldRoomID:
		return m.OldRoomID(ctx)
	case profiles.FieldTmpURL:
		return m.OldTmpURL(ctx)
	case profiles.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case profiles.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Profiles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfilesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profiles.FieldTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case profiles.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profiles.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case profiles.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case profiles.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case profiles.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case profiles.FieldRoomID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomID(v)
		return nil
	case profiles.FieldTmpURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTmpURL(v)
		return nil
	case profiles.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case profiles.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Profiles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfilesMutation) AddedFields() []string {
	var fields []string
	if m.addtype_id != nil {
		fields = append(fields, profiles.FieldTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfilesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profiles.FieldTypeID:
		return m.AddedTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfilesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profiles.FieldTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Profiles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfilesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profiles.FieldTypeID) {
		fields = append(fields, profiles.FieldTypeID)
	}
	if m.FieldCleared(profiles.FieldName) {
		fields = append(fields, profiles.FieldName)
	}
	if m.FieldCleared(profiles.FieldTenantID) {
		fields = append(fields, profiles.FieldTenantID)
	}
	if m.FieldCleared(profiles.FieldIDCardNumber) {
		fields = append(fields, profiles.FieldIDCardNumber)
	}
	if m.FieldCleared(profiles.FieldPhoneNumber) {
		fields = append(fields, profiles.FieldPhoneNumber)
	}
	if m.FieldCleared(profiles.FieldEnabled) {
		fields = append(fields, profiles.FieldEnabled)
	}
	if m.FieldCleared(profiles.FieldRoomID) {
		fields = append(fields, profiles.FieldRoomID)
	}
	if m.FieldCleared(profiles.FieldTmpURL) {
		fields = append(fields, profiles.FieldTmpURL)
	}
	if m.FieldCleared(profiles.FieldCreatedTime) {
		fields = append(fields, profiles.FieldCreatedTime)
	}
	if m.FieldCleared(profiles.FieldUpdatedTime) {
		fields = append(fields, profiles.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfilesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfilesMutation) ClearField(name string) error {
	switch name {
	case profiles.FieldTypeID:
		m.ClearTypeID()
		return nil
	case profiles.FieldName:
		m.ClearName()
		return nil
	case profiles.FieldTenantID:
		m.ClearTenantID()
		return nil
	case profiles.FieldIDCardNumber:
		m.ClearIDCardNumber()
		return nil
	case profiles.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case profiles.FieldEnabled:
		m.ClearEnabled()
		return nil
	case profiles.FieldRoomID:
		m.ClearRoomID()
		return nil
	case profiles.FieldTmpURL:
		m.ClearTmpURL()
		return nil
	case profiles.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case profiles.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Profiles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfilesMutation) ResetField(name string) error {
	switch name {
	case profiles.FieldTypeID:
		m.ResetTypeID()
		return nil
	case profiles.FieldName:
		m.ResetName()
		return nil
	case profiles.FieldTenantID:
		m.ResetTenantID()
		return nil
	case profiles.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case profiles.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case profiles.FieldEnabled:
		m.ResetEnabled()
		return nil
	case profiles.FieldRoomID:
		m.ResetRoomID()
		return nil
	case profiles.FieldTmpURL:
		m.ResetTmpURL()
		return nil
	case profiles.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case profiles.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Profiles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfilesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfilesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfilesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfilesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfilesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfilesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfilesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Profiles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfilesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Profiles edge %s", name)
}

// ProvinceMutation represents an operation that mutates the Province nodes in the graph.
type ProvinceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	code          *string
	name          *string
	creator       *string
	delete_flag   *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Province, error)
	predicates    []predicate.Province
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows management of the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for the Province entity.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the ID field of the mutation.
func withProvinceID(id int64) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Province entities.
func (m *ProvinceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvinceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvinceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Province.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ProvinceMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ProvinceMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ProvinceMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// SetCreator sets the "creator" field.
func (m *ProvinceMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ProvinceMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *ProvinceMutation) ResetCreator() {
	m.creator = nil
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *ProvinceMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *ProvinceMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldDeleteFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *ProvinceMutation) ResetDeleteFlag() {
	m.delete_flag = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ProvinceMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProvinceMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *ProvinceMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[province.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *ProvinceMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[province.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProvinceMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, province.FieldCreatedTime)
}

// Where appends a list predicates to the ProvinceMutation builder.
func (m *ProvinceMutation) Where(ps ...predicate.Province) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvinceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvinceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Province, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvinceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, province.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	if m.creator != nil {
		fields = append(fields, province.FieldCreator)
	}
	if m.delete_flag != nil {
		fields = append(fields, province.FieldDeleteFlag)
	}
	if m.created_time != nil {
		fields = append(fields, province.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldCode:
		return m.Code()
	case province.FieldName:
		return m.Name()
	case province.FieldCreator:
		return m.Creator()
	case province.FieldDeleteFlag:
		return m.DeleteFlag()
	case province.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldCode:
		return m.OldCode(ctx)
	case province.FieldName:
		return m.OldName(ctx)
	case province.FieldCreator:
		return m.OldCreator(ctx)
	case province.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case province.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case province.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case province.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case province.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(province.FieldCreatedTime) {
		fields = append(fields, province.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	switch name {
	case province.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldCode:
		m.ResetCode()
		return nil
	case province.FieldName:
		m.ResetName()
		return nil
	case province.FieldCreator:
		m.ResetCreator()
		return nil
	case province.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case province.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Province edge %s", name)
}

// SqlLogMutation represents an operation that mutates the SqlLog nodes in the graph.
type SqlLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	table_name    *string
	query         *string
	args          *string
	action        *string
	db_name       *string
	pk_value      *int
	addpk_value   *int
	old_data      *map[string]interface{}
	new_data      *map[string]interface{}
	creator       *string
	created_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SqlLog, error)
	predicates    []predicate.SqlLog
}

var _ ent.Mutation = (*SqlLogMutation)(nil)

// sqllogOption allows management of the mutation configuration using functional options.
type sqllogOption func(*SqlLogMutation)

// newSqlLogMutation creates new mutation for the SqlLog entity.
func newSqlLogMutation(c config, op Op, opts ...sqllogOption) *SqlLogMutation {
	m := &SqlLogMutation{
		config:        c,
		op:            op,
		typ:           TypeSqlLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSqlLogID sets the ID field of the mutation.
func withSqlLogID(id int) sqllogOption {
	return func(m *SqlLogMutation) {
		var (
			err   error
			once  sync.Once
			value *SqlLog
		)
		m.oldValue = func(ctx context.Context) (*SqlLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SqlLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSqlLog sets the old SqlLog of the mutation.
func withSqlLog(node *SqlLog) sqllogOption {
	return func(m *SqlLogMutation) {
		m.oldValue = func(context.Context) (*SqlLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SqlLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SqlLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SqlLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SqlLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SqlLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTableName sets the "table_name" field.
func (m *SqlLogMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *SqlLogMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ResetTableName resets all changes to the "table_name" field.
func (m *SqlLogMutation) ResetTableName() {
	m.table_name = nil
}

// SetQuery sets the "query" field.
func (m *SqlLogMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *SqlLogMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldQuery(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *SqlLogMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[sqllog.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *SqlLogMutation) QueryCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *SqlLogMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, sqllog.FieldQuery)
}

// SetArgs sets the "args" field.
func (m *SqlLogMutation) SetArgs(s string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *SqlLogMutation) Args() (r string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldArgs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ClearArgs clears the value of the "args" field.
func (m *SqlLogMutation) ClearArgs() {
	m.args = nil
	m.clearedFields[sqllog.FieldArgs] = struct{}{}
}

// ArgsCleared returns if the "args" field was cleared in this mutation.
func (m *SqlLogMutation) ArgsCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldArgs]
	return ok
}

// ResetArgs resets all changes to the "args" field.
func (m *SqlLogMutation) ResetArgs() {
	m.args = nil
	delete(m.clearedFields, sqllog.FieldArgs)
}

// SetAction sets the "action" field.
func (m *SqlLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SqlLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldAction(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *SqlLogMutation) ClearAction() {
	m.action = nil
	m.clearedFields[sqllog.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *SqlLogMutation) ActionCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *SqlLogMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, sqllog.FieldAction)
}

// SetDbName sets the "db_name" field.
func (m *SqlLogMutation) SetDbName(s string) {
	m.db_name = &s
}

// DbName returns the value of the "db_name" field in the mutation.
func (m *SqlLogMutation) DbName() (r string, exists bool) {
	v := m.db_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDbName returns the old "db_name" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldDbName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbName: %w", err)
	}
	return oldValue.DbName, nil
}

// ClearDbName clears the value of the "db_name" field.
func (m *SqlLogMutation) ClearDbName() {
	m.db_name = nil
	m.clearedFields[sqllog.FieldDbName] = struct{}{}
}

// DbNameCleared returns if the "db_name" field was cleared in this mutation.
func (m *SqlLogMutation) DbNameCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldDbName]
	return ok
}

// ResetDbName resets all changes to the "db_name" field.
func (m *SqlLogMutation) ResetDbName() {
	m.db_name = nil
	delete(m.clearedFields, sqllog.FieldDbName)
}

// SetPkValue sets the "pk_value" field.
func (m *SqlLogMutation) SetPkValue(i int) {
	m.pk_value = &i
	m.addpk_value = nil
}

// PkValue returns the value of the "pk_value" field in the mutation.
func (m *SqlLogMutation) PkValue() (r int, exists bool) {
	v := m.pk_value
	if v == nil {
		return
	}
	return *v, true
}

// OldPkValue returns the old "pk_value" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldPkValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkValue: %w", err)
	}
	return oldValue.PkValue, nil
}

// AddPkValue adds i to the "pk_value" field.
func (m *SqlLogMutation) AddPkValue(i int) {
	if m.addpk_value != nil {
		*m.addpk_value += i
	} else {
		m.addpk_value = &i
	}
}

// AddedPkValue returns the value that was added to the "pk_value" field in this mutation.
func (m *SqlLogMutation) AddedPkValue() (r int, exists bool) {
	v := m.addpk_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearPkValue clears the value of the "pk_value" field.
func (m *SqlLogMutation) ClearPkValue() {
	m.pk_value = nil
	m.addpk_value = nil
	m.clearedFields[sqllog.FieldPkValue] = struct{}{}
}

// PkValueCleared returns if the "pk_value" field was cleared in this mutation.
func (m *SqlLogMutation) PkValueCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldPkValue]
	return ok
}

// ResetPkValue resets all changes to the "pk_value" field.
func (m *SqlLogMutation) ResetPkValue() {
	m.pk_value = nil
	m.addpk_value = nil
	delete(m.clearedFields, sqllog.FieldPkValue)
}

// SetOldData sets the "old_data" field.
func (m *SqlLogMutation) SetOldData(value map[string]interface{}) {
	m.old_data = &value
}

// OldData returns the value of the "old_data" field in the mutation.
func (m *SqlLogMutation) OldData() (r map[string]interface{}, exists bool) {
	v := m.old_data
	if v == nil {
		return
	}
	return *v, true
}

// OldOldData returns the old "old_data" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldOldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldData: %w", err)
	}
	return oldValue.OldData, nil
}

// ClearOldData clears the value of the "old_data" field.
func (m *SqlLogMutation) ClearOldData() {
	m.old_data = nil
	m.clearedFields[sqllog.FieldOldData] = struct{}{}
}

// OldDataCleared returns if the "old_data" field was cleared in this mutation.
func (m *SqlLogMutation) OldDataCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldOldData]
	return ok
}

// ResetOldData resets all changes to the "old_data" field.
func (m *SqlLogMutation) ResetOldData() {
	m.old_data = nil
	delete(m.clearedFields, sqllog.FieldOldData)
}

// SetNewData sets the "new_data" field.
func (m *SqlLogMutation) SetNewData(value map[string]interface{}) {
	m.new_data = &value
}

// NewData returns the value of the "new_data" field in the mutation.
func (m *SqlLogMutation) NewData() (r map[string]interface{}, exists bool) {
	v := m.new_data
	if v == nil {
		return
	}
	return *v, true
}

// OldNewData returns the old "new_data" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldNewData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewData: %w", err)
	}
	return oldValue.NewData, nil
}

// ClearNewData clears the value of the "new_data" field.
func (m *SqlLogMutation) ClearNewData() {
	m.new_data = nil
	m.clearedFields[sqllog.FieldNewData] = struct{}{}
}

// NewDataCleared returns if the "new_data" field was cleared in this mutation.
func (m *SqlLogMutation) NewDataCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldNewData]
	return ok
}

// ResetNewData resets all changes to the "new_data" field.
func (m *SqlLogMutation) ResetNewData() {
	m.new_data = nil
	delete(m.clearedFields, sqllog.FieldNewData)
}

// SetCreator sets the "creator" field.
func (m *SqlLogMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SqlLogMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldCreator(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SqlLogMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[sqllog.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SqlLogMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SqlLogMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, sqllog.FieldCreator)
}

// SetCreatedTime sets the "created_time" field.
func (m *SqlLogMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *SqlLogMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the SqlLog entity.
// If the SqlLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SqlLogMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *SqlLogMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[sqllog.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *SqlLogMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[sqllog.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *SqlLogMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, sqllog.FieldCreatedTime)
}

// Where appends a list predicates to the SqlLogMutation builder.
func (m *SqlLogMutation) Where(ps ...predicate.SqlLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SqlLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SqlLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SqlLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SqlLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SqlLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SqlLog).
func (m *SqlLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SqlLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.table_name != nil {
		fields = append(fields, sqllog.FieldTableName)
	}
	if m.query != nil {
		fields = append(fields, sqllog.FieldQuery)
	}
	if m.args != nil {
		fields = append(fields, sqllog.FieldArgs)
	}
	if m.action != nil {
		fields = append(fields, sqllog.FieldAction)
	}
	if m.db_name != nil {
		fields = append(fields, sqllog.FieldDbName)
	}
	if m.pk_value != nil {
		fields = append(fields, sqllog.FieldPkValue)
	}
	if m.old_data != nil {
		fields = append(fields, sqllog.FieldOldData)
	}
	if m.new_data != nil {
		fields = append(fields, sqllog.FieldNewData)
	}
	if m.creator != nil {
		fields = append(fields, sqllog.FieldCreator)
	}
	if m.created_time != nil {
		fields = append(fields, sqllog.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SqlLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sqllog.FieldTableName:
		return m.TableName()
	case sqllog.FieldQuery:
		return m.Query()
	case sqllog.FieldArgs:
		return m.Args()
	case sqllog.FieldAction:
		return m.Action()
	case sqllog.FieldDbName:
		return m.DbName()
	case sqllog.FieldPkValue:
		return m.PkValue()
	case sqllog.FieldOldData:
		return m.OldData()
	case sqllog.FieldNewData:
		return m.NewData()
	case sqllog.FieldCreator:
		return m.Creator()
	case sqllog.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SqlLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sqllog.FieldTableName:
		return m.OldTableName(ctx)
	case sqllog.FieldQuery:
		return m.OldQuery(ctx)
	case sqllog.FieldArgs:
		return m.OldArgs(ctx)
	case sqllog.FieldAction:
		return m.OldAction(ctx)
	case sqllog.FieldDbName:
		return m.OldDbName(ctx)
	case sqllog.FieldPkValue:
		return m.OldPkValue(ctx)
	case sqllog.FieldOldData:
		return m.OldOldData(ctx)
	case sqllog.FieldNewData:
		return m.OldNewData(ctx)
	case sqllog.FieldCreator:
		return m.OldCreator(ctx)
	case sqllog.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown SqlLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SqlLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sqllog.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case sqllog.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case sqllog.FieldArgs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case sqllog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case sqllog.FieldDbName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbName(v)
		return nil
	case sqllog.FieldPkValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkValue(v)
		return nil
	case sqllog.FieldOldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldData(v)
		return nil
	case sqllog.FieldNewData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewData(v)
		return nil
	case sqllog.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case sqllog.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown SqlLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SqlLogMutation) AddedFields() []string {
	var fields []string
	if m.addpk_value != nil {
		fields = append(fields, sqllog.FieldPkValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SqlLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sqllog.FieldPkValue:
		return m.AddedPkValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SqlLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sqllog.FieldPkValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPkValue(v)
		return nil
	}
	return fmt.Errorf("unknown SqlLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SqlLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sqllog.FieldQuery) {
		fields = append(fields, sqllog.FieldQuery)
	}
	if m.FieldCleared(sqllog.FieldArgs) {
		fields = append(fields, sqllog.FieldArgs)
	}
	if m.FieldCleared(sqllog.FieldAction) {
		fields = append(fields, sqllog.FieldAction)
	}
	if m.FieldCleared(sqllog.FieldDbName) {
		fields = append(fields, sqllog.FieldDbName)
	}
	if m.FieldCleared(sqllog.FieldPkValue) {
		fields = append(fields, sqllog.FieldPkValue)
	}
	if m.FieldCleared(sqllog.FieldOldData) {
		fields = append(fields, sqllog.FieldOldData)
	}
	if m.FieldCleared(sqllog.FieldNewData) {
		fields = append(fields, sqllog.FieldNewData)
	}
	if m.FieldCleared(sqllog.FieldCreator) {
		fields = append(fields, sqllog.FieldCreator)
	}
	if m.FieldCleared(sqllog.FieldCreatedTime) {
		fields = append(fields, sqllog.FieldCreatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SqlLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SqlLogMutation) ClearField(name string) error {
	switch name {
	case sqllog.FieldQuery:
		m.ClearQuery()
		return nil
	case sqllog.FieldArgs:
		m.ClearArgs()
		return nil
	case sqllog.FieldAction:
		m.ClearAction()
		return nil
	case sqllog.FieldDbName:
		m.ClearDbName()
		return nil
	case sqllog.FieldPkValue:
		m.ClearPkValue()
		return nil
	case sqllog.FieldOldData:
		m.ClearOldData()
		return nil
	case sqllog.FieldNewData:
		m.ClearNewData()
		return nil
	case sqllog.FieldCreator:
		m.ClearCreator()
		return nil
	case sqllog.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown SqlLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SqlLogMutation) ResetField(name string) error {
	switch name {
	case sqllog.FieldTableName:
		m.ResetTableName()
		return nil
	case sqllog.FieldQuery:
		m.ResetQuery()
		return nil
	case sqllog.FieldArgs:
		m.ResetArgs()
		return nil
	case sqllog.FieldAction:
		m.ResetAction()
		return nil
	case sqllog.FieldDbName:
		m.ResetDbName()
		return nil
	case sqllog.FieldPkValue:
		m.ResetPkValue()
		return nil
	case sqllog.FieldOldData:
		m.ResetOldData()
		return nil
	case sqllog.FieldNewData:
		m.ResetNewData()
		return nil
	case sqllog.FieldCreator:
		m.ResetCreator()
		return nil
	case sqllog.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown SqlLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SqlLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SqlLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SqlLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SqlLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SqlLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SqlLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SqlLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SqlLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SqlLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SqlLog edge %s", name)
}

// TemporaryFaceMutation represents an operation that mutates the TemporaryFace nodes in the graph.
type TemporaryFaceMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	tenant_id        *uuid.UUID
	profile_id       *int64
	addprofile_id    *int64
	face_embedding   *[]byte
	img_url          *string
	updated_location *string
	capture_count    *int
	addcapture_count *int
	created_time     *time.Time
	updated_time     *time.Time
	expires_time     *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TemporaryFace, error)
	predicates       []predicate.TemporaryFace
}

var _ ent.Mutation = (*TemporaryFaceMutation)(nil)

// temporaryfaceOption allows management of the mutation configuration using functional options.
type temporaryfaceOption func(*TemporaryFaceMutation)

// newTemporaryFaceMutation creates new mutation for the TemporaryFace entity.
func newTemporaryFaceMutation(c config, op Op, opts ...temporaryfaceOption) *TemporaryFaceMutation {
	m := &TemporaryFaceMutation{
		config:        c,
		op:            op,
		typ:           TypeTemporaryFace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemporaryFaceID sets the ID field of the mutation.
func withTemporaryFaceID(id int64) temporaryfaceOption {
	return func(m *TemporaryFaceMutation) {
		var (
			err   error
			once  sync.Once
			value *TemporaryFace
		)
		m.oldValue = func(ctx context.Context) (*TemporaryFace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemporaryFace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemporaryFace sets the old TemporaryFace of the mutation.
func withTemporaryFace(node *TemporaryFace) temporaryfaceOption {
	return func(m *TemporaryFaceMutation) {
		m.oldValue = func(context.Context) (*TemporaryFace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemporaryFaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemporaryFaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemporaryFace entities.
func (m *TemporaryFaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemporaryFaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemporaryFaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemporaryFace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TemporaryFaceMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TemporaryFaceMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TemporaryFaceMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetProfileID sets the "profile_id" field.
func (m *TemporaryFaceMutation) SetProfileID(i int64) {
	m.profile_id = &i
	m.addprofile_id = nil
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *TemporaryFaceMutation) ProfileID() (r int64, exists bool) {
	v := m.profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldProfileID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// AddProfileID adds i to the "profile_id" field.
func (m *TemporaryFaceMutation) AddProfileID(i int64) {
	if m.addprofile_id != nil {
		*m.addprofile_id += i
	} else {
		m.addprofile_id = &i
	}
}

// AddedProfileID returns the value that was added to the "profile_id" field in this mutation.
func (m *TemporaryFaceMutation) AddedProfileID() (r int64, exists bool) {
	v := m.addprofile_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfileID clears the value of the "profile_id" field.
func (m *TemporaryFaceMutation) ClearProfileID() {
	m.profile_id = nil
	m.addprofile_id = nil
	m.clearedFields[temporaryface.FieldProfileID] = struct{}{}
}

// ProfileIDCleared returns if the "profile_id" field was cleared in this mutation.
func (m *TemporaryFaceMutation) ProfileIDCleared() bool {
	_, ok := m.clearedFields[temporaryface.FieldProfileID]
	return ok
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *TemporaryFaceMutation) ResetProfileID() {
	m.profile_id = nil
	m.addprofile_id = nil
	delete(m.clearedFields, temporaryface.FieldProfileID)
}

// SetFaceEmbedding sets the "face_embedding" field.
func (m *TemporaryFaceMutation) SetFaceEmbedding(b []byte) {
	m.face_embedding = &b
}

// FaceEmbedding returns the value of the "face_embedding" field in the mutation.
func (m *TemporaryFaceMutation) FaceEmbedding() (r []byte, exists bool) {
	v := m.face_embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceEmbedding returns the old "face_embedding" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldFaceEmbedding(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceEmbedding: %w", err)
	}
	return oldValue.FaceEmbedding, nil
}

// ResetFaceEmbedding resets all changes to the "face_embedding" field.
func (m *TemporaryFaceMutation) ResetFaceEmbedding() {
	m.face_embedding = nil
}

// SetImgURL sets the "img_url" field.
func (m *TemporaryFaceMutation) SetImgURL(s string) {
	m.img_url = &s
}

// ImgURL returns the value of the "img_url" field in the mutation.
func (m *TemporaryFaceMutation) ImgURL() (r string, exists bool) {
	v := m.img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImgURL returns the old "img_url" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldImgURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgURL: %w", err)
	}
	return oldValue.ImgURL, nil
}

// ClearImgURL clears the value of the "img_url" field.
func (m *TemporaryFaceMutation) ClearImgURL() {
	m.img_url = nil
	m.clearedFields[temporaryface.FieldImgURL] = struct{}{}
}

// ImgURLCleared returns if the "img_url" field was cleared in this mutation.
func (m *TemporaryFaceMutation) ImgURLCleared() bool {
	_, ok := m.clearedFields[temporaryface.FieldImgURL]
	return ok
}

// ResetImgURL resets all changes to the "img_url" field.
func (m *TemporaryFaceMutation) ResetImgURL() {
	m.img_url = nil
	delete(m.clearedFields, temporaryface.FieldImgURL)
}

// SetUpdatedLocation sets the "updated_location" field.
func (m *TemporaryFaceMutation) SetUpdatedLocation(s string) {
	m.updated_location = &s
}

// UpdatedLocation returns the value of the "updated_location" field in the mutation.
func (m *TemporaryFaceMutation) UpdatedLocation() (r string, exists bool) {
	v := m.updated_location
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedLocation returns the old "updated_location" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldUpdatedLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedLocation: %w", err)
	}
	return oldValue.UpdatedLocation, nil
}

// ClearUpdatedLocation clears the value of the "updated_location" field.
func (m *TemporaryFaceMutation) ClearUpdatedLocation() {
	m.updated_location = nil
	m.clearedFields[temporaryface.FieldUpdatedLocation] = struct{}{}
}

// UpdatedLocationCleared returns if the "updated_location" field was cleared in this mutation.
func (m *TemporaryFaceMutation) UpdatedLocationCleared() bool {
	_, ok := m.clearedFields[temporaryface.FieldUpdatedLocation]
	return ok
}

// ResetUpdatedLocation resets all changes to the "updated_location" field.
func (m *TemporaryFaceMutation) ResetUpdatedLocation() {
	m.updated_location = nil
	delete(m.clearedFields, temporaryface.FieldUpdatedLocation)
}

// SetCaptureCount sets the "capture_count" field.
func (m *TemporaryFaceMutation) SetCaptureCount(i int) {
	m.capture_count = &i
	m.addcapture_count = nil
}

// CaptureCount returns the value of the "capture_count" field in the mutation.
func (m *TemporaryFaceMutation) CaptureCount() (r int, exists bool) {
	v := m.capture_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCaptureCount returns the old "capture_count" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldCaptureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaptureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaptureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaptureCount: %w", err)
	}
	return oldValue.CaptureCount, nil
}

// AddCaptureCount adds i to the "capture_count" field.
func (m *TemporaryFaceMutation) AddCaptureCount(i int) {
	if m.addcapture_count != nil {
		*m.addcapture_count += i
	} else {
		m.addcapture_count = &i
	}
}

// AddedCaptureCount returns the value that was added to the "capture_count" field in this mutation.
func (m *TemporaryFaceMutation) AddedCaptureCount() (r int, exists bool) {
	v := m.addcapture_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaptureCount resets all changes to the "capture_count" field.
func (m *TemporaryFaceMutation) ResetCaptureCount() {
	m.capture_count = nil
	m.addcapture_count = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *TemporaryFaceMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *TemporaryFaceMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *TemporaryFaceMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[temporaryface.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *TemporaryFaceMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[temporaryface.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *TemporaryFaceMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, temporaryface.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *TemporaryFaceMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *TemporaryFaceMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *TemporaryFaceMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[temporaryface.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *TemporaryFaceMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[temporaryface.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *TemporaryFaceMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, temporaryface.FieldUpdatedTime)
}

// SetExpiresTime sets the "expires_time" field.
func (m *TemporaryFaceMutation) SetExpiresTime(t time.Time) {
	m.expires_time = &t
}

// ExpiresTime returns the value of the "expires_time" field in the mutation.
func (m *TemporaryFaceMutation) ExpiresTime() (r time.Time, exists bool) {
	v := m.expires_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresTime returns the old "expires_time" field's value of the TemporaryFace entity.
// If the TemporaryFace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFaceMutation) OldExpiresTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresTime: %w", err)
	}
	return oldValue.ExpiresTime, nil
}

// ResetExpiresTime resets all changes to the "expires_time" field.
func (m *TemporaryFaceMutation) ResetExpiresTime() {
	m.expires_time = nil
}

// Where appends a list predicates to the TemporaryFaceMutation builder.
func (m *TemporaryFaceMutation) Where(ps ...predicate.TemporaryFace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemporaryFaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemporaryFaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemporaryFace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemporaryFaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemporaryFaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemporaryFace).
func (m *TemporaryFaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemporaryFaceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant_id != nil {
		fields = append(fields, temporaryface.FieldTenantID)
	}
	if m.profile_id != nil {
		fields = append(fields, temporaryface.FieldProfileID)
	}
	if m.face_embedding != nil {
		fields = append(fields, temporaryface.FieldFaceEmbedding)
	}
	if m.img_url != nil {
		fields = append(fields, temporaryface.FieldImgURL)
	}
	if m.updated_location != nil {
		fields = append(fields, temporaryface.FieldUpdatedLocation)
	}
	if m.capture_count != nil {
		fields = append(fields, temporaryface.FieldCaptureCount)
	}
	if m.created_time != nil {
		fields = append(fields, temporaryface.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, temporaryface.FieldUpdatedTime)
	}
	if m.expires_time != nil {
		fields = append(fields, temporaryface.FieldExpiresTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemporaryFaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case temporaryface.FieldTenantID:
		return m.TenantID()
	case temporaryface.FieldProfileID:
		return m.ProfileID()
	case temporaryface.FieldFaceEmbedding:
		return m.FaceEmbedding()
	case temporaryface.FieldImgURL:
		return m.ImgURL()
	case temporaryface.FieldUpdatedLocation:
		return m.UpdatedLocation()
	case temporaryface.FieldCaptureCount:
		return m.CaptureCount()
	case temporaryface.FieldCreatedTime:
		return m.CreatedTime()
	case temporaryface.FieldUpdatedTime:
		return m.UpdatedTime()
	case temporaryface.FieldExpiresTime:
		return m.ExpiresTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemporaryFaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case temporaryface.FieldTenantID:
		return m.OldTenantID(ctx)
	case temporaryface.FieldProfileID:
		return m.OldProfileID(ctx)
	case temporaryface.FieldFaceEmbedding:
		return m.OldFaceEmbedding(ctx)
	case temporaryface.FieldImgURL:
		return m.OldImgURL(ctx)
	case temporaryface.FieldUpdatedLocation:
		return m.OldUpdatedLocation(ctx)
	case temporaryface.FieldCaptureCount:
		return m.OldCaptureCount(ctx)
	case temporaryface.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case temporaryface.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case temporaryface.FieldExpiresTime:
		return m.OldExpiresTime(ctx)
	}
	return nil, fmt.Errorf("unknown TemporaryFace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporaryFaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case temporaryface.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case temporaryface.FieldProfileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	case temporaryface.FieldFaceEmbedding:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceEmbedding(v)
		return nil
	case temporaryface.FieldImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgURL(v)
		return nil
	case temporaryface.FieldUpdatedLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedLocation(v)
		return nil
	case temporaryface.FieldCaptureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaptureCount(v)
		return nil
	case temporaryface.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case temporaryface.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case temporaryface.FieldExpiresTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresTime(v)
		return nil
	}
	return fmt.Errorf("unknown TemporaryFace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemporaryFaceMutation) AddedFields() []string {
	var fields []string
	if m.addprofile_id != nil {
		fields = append(fields, temporaryface.FieldProfileID)
	}
	if m.addcapture_count != nil {
		fields = append(fields, temporaryface.FieldCaptureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemporaryFaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case temporaryface.FieldProfileID:
		return m.AddedProfileID()
	case temporaryface.FieldCaptureCount:
		return m.AddedCaptureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporaryFaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case temporaryface.FieldProfileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfileID(v)
		return nil
	case temporaryface.FieldCaptureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaptureCount(v)
		return nil
	}
	return fmt.Errorf("unknown TemporaryFace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemporaryFaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(temporaryface.FieldProfileID) {
		fields = append(fields, temporaryface.FieldProfileID)
	}
	if m.FieldCleared(temporaryface.FieldImgURL) {
		fields = append(fields, temporaryface.FieldImgURL)
	}
	if m.FieldCleared(temporaryface.FieldUpdatedLocation) {
		fields = append(fields, temporaryface.FieldUpdatedLocation)
	}
	if m.FieldCleared(temporaryface.FieldCreatedTime) {
		fields = append(fields, temporaryface.FieldCreatedTime)
	}
	if m.FieldCleared(temporaryface.FieldUpdatedTime) {
		fields = append(fields, temporaryface.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemporaryFaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemporaryFaceMutation) ClearField(name string) error {
	switch name {
	case temporaryface.FieldProfileID:
		m.ClearProfileID()
		return nil
	case temporaryface.FieldImgURL:
		m.ClearImgURL()
		return nil
	case temporaryface.FieldUpdatedLocation:
		m.ClearUpdatedLocation()
		return nil
	case temporaryface.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case temporaryface.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown TemporaryFace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemporaryFaceMutation) ResetField(name string) error {
	switch name {
	case temporaryface.FieldTenantID:
		m.ResetTenantID()
		return nil
	case temporaryface.FieldProfileID:
		m.ResetProfileID()
		return nil
	case temporaryface.FieldFaceEmbedding:
		m.ResetFaceEmbedding()
		return nil
	case temporaryface.FieldImgURL:
		m.ResetImgURL()
		return nil
	case temporaryface.FieldUpdatedLocation:
		m.ResetUpdatedLocation()
		return nil
	case temporaryface.FieldCaptureCount:
		m.ResetCaptureCount()
		return nil
	case temporaryface.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case temporaryface.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case temporaryface.FieldExpiresTime:
		m.ResetExpiresTime()
		return nil
	}
	return fmt.Errorf("unknown TemporaryFace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemporaryFaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemporaryFaceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemporaryFaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemporaryFaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemporaryFaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemporaryFaceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemporaryFaceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TemporaryFace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemporaryFaceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TemporaryFace edge %s", name)
}

// TenantsMutation represents an operation that mutates the Tenants nodes in the graph.
type TenantsMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	supplier       *string
	tenant_id      *uuid.UUID
	contacts       *string
	email          *string
	description    *string
	_type          *string
	province       *string
	city           *string
	area           *string
	street         *string
	address        *string
	addr_code      *string
	fax            *string
	phone_num      *string
	telephone      *string
	tax_num        *string
	bank_name      *string
	account_number *string
	sort           *string
	enabled        *bool
	delete_flag    *string
	isystem        *bool
	tax_rate       *schema.Decimal
	advance_in     *schema.Decimal
	begin_need_get *schema.Decimal
	begin_need_pay *schema.Decimal
	all_need_get   *schema.Decimal
	all_need_pay   *schema.Decimal
	creator        *string
	created_time   *time.Time
	updated_time   *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Tenants, error)
	predicates     []predicate.Tenants
}

var _ ent.Mutation = (*TenantsMutation)(nil)

// tenantsOption allows management of the mutation configuration using functional options.
type tenantsOption func(*TenantsMutation)

// newTenantsMutation creates new mutation for the Tenants entity.
func newTenantsMutation(c config, op Op, opts ...tenantsOption) *TenantsMutation {
	m := &TenantsMutation{
		config:        c,
		op:            op,
		typ:           TypeTenants,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantsID sets the ID field of the mutation.
func withTenantsID(id int64) tenantsOption {
	return func(m *TenantsMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenants
		)
		m.oldValue = func(ctx context.Context) (*Tenants, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenants.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenants sets the old Tenants of the mutation.
func withTenants(node *Tenants) tenantsOption {
	return func(m *TenantsMutation) {
		m.oldValue = func(context.Context) (*Tenants, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("genclients: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenants entities.
func (m *TenantsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenants.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSupplier sets the "supplier" field.
func (m *TenantsMutation) SetSupplier(s string) {
	m.supplier = &s
}

// Supplier returns the value of the "supplier" field in the mutation.
func (m *TenantsMutation) Supplier() (r string, exists bool) {
	v := m.supplier
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplier returns the old "supplier" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldSupplier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplier: %w", err)
	}
	return oldValue.Supplier, nil
}

// ResetSupplier resets all changes to the "supplier" field.
func (m *TenantsMutation) ResetSupplier() {
	m.supplier = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantsMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantsMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantsMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetContacts sets the "contacts" field.
func (m *TenantsMutation) SetContacts(s string) {
	m.contacts = &s
}

// Contacts returns the value of the "contacts" field in the mutation.
func (m *TenantsMutation) Contacts() (r string, exists bool) {
	v := m.contacts
	if v == nil {
		return
	}
	return *v, true
}

// OldContacts returns the old "contacts" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldContacts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContacts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContacts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContacts: %w", err)
	}
	return oldValue.Contacts, nil
}

// ResetContacts resets all changes to the "contacts" field.
func (m *TenantsMutation) ResetContacts() {
	m.contacts = nil
}

// SetEmail sets the "email" field.
func (m *TenantsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TenantsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TenantsMutation) ResetEmail() {
	m.email = nil
}

// SetDescription sets the "description" field.
func (m *TenantsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantsMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *TenantsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TenantsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TenantsMutation) ResetType() {
	m._type = nil
}

// SetProvince sets the "province" field.
func (m *TenantsMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *TenantsMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *TenantsMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *TenantsMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *TenantsMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *TenantsMutation) ResetCity() {
	m.city = nil
}

// SetArea sets the "area" field.
func (m *TenantsMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *TenantsMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ResetArea resets all changes to the "area" field.
func (m *TenantsMutation) ResetArea() {
	m.area = nil
}

// SetStreet sets the "street" field.
func (m *TenantsMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *TenantsMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ResetStreet resets all changes to the "street" field.
func (m *TenantsMutation) ResetStreet() {
	m.street = nil
}

// SetAddress sets the "address" field.
func (m *TenantsMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TenantsMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *TenantsMutation) ResetAddress() {
	m.address = nil
}

// SetAddrCode sets the "addr_code" field.
func (m *TenantsMutation) SetAddrCode(s string) {
	m.addr_code = &s
}

// AddrCode returns the value of the "addr_code" field in the mutation.
func (m *TenantsMutation) AddrCode() (r string, exists bool) {
	v := m.addr_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrCode returns the old "addr_code" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldAddrCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddrCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddrCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrCode: %w", err)
	}
	return oldValue.AddrCode, nil
}

// ResetAddrCode resets all changes to the "addr_code" field.
func (m *TenantsMutation) ResetAddrCode() {
	m.addr_code = nil
}

// SetFax sets the "fax" field.
func (m *TenantsMutation) SetFax(s string) {
	m.fax = &s
}

// Fax returns the value of the "fax" field in the mutation.
func (m *TenantsMutation) Fax() (r string, exists bool) {
	v := m.fax
	if v == nil {
		return
	}
	return *v, true
}

// OldFax returns the old "fax" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldFax(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFax: %w", err)
	}
	return oldValue.Fax, nil
}

// ResetFax resets all changes to the "fax" field.
func (m *TenantsMutation) ResetFax() {
	m.fax = nil
}

// SetPhoneNum sets the "phone_num" field.
func (m *TenantsMutation) SetPhoneNum(s string) {
	m.phone_num = &s
}

// PhoneNum returns the value of the "phone_num" field in the mutation.
func (m *TenantsMutation) PhoneNum() (r string, exists bool) {
	v := m.phone_num
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNum returns the old "phone_num" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldPhoneNum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNum: %w", err)
	}
	return oldValue.PhoneNum, nil
}

// ResetPhoneNum resets all changes to the "phone_num" field.
func (m *TenantsMutation) ResetPhoneNum() {
	m.phone_num = nil
}

// SetTelephone sets the "telephone" field.
func (m *TenantsMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *TenantsMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *TenantsMutation) ResetTelephone() {
	m.telephone = nil
}

// SetTaxNum sets the "tax_num" field.
func (m *TenantsMutation) SetTaxNum(s string) {
	m.tax_num = &s
}

// TaxNum returns the value of the "tax_num" field in the mutation.
func (m *TenantsMutation) TaxNum() (r string, exists bool) {
	v := m.tax_num
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNum returns the old "tax_num" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldTaxNum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNum: %w", err)
	}
	return oldValue.TaxNum, nil
}

// ResetTaxNum resets all changes to the "tax_num" field.
func (m *TenantsMutation) ResetTaxNum() {
	m.tax_num = nil
}

// SetBankName sets the "bank_name" field.
func (m *TenantsMutation) SetBankName(s string) {
	m.bank_name = &s
}

// BankName returns the value of the "bank_name" field in the mutation.
func (m *TenantsMutation) BankName() (r string, exists bool) {
	v := m.bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bank_name" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldBankName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// ResetBankName resets all changes to the "bank_name" field.
func (m *TenantsMutation) ResetBankName() {
	m.bank_name = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *TenantsMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *TenantsMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *TenantsMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetSort sets the "sort" field.
func (m *TenantsMutation) SetSort(s string) {
	m.sort = &s
}

// Sort returns the value of the "sort" field in the mutation.
func (m *TenantsMutation) Sort() (r string, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// ResetSort resets all changes to the "sort" field.
func (m *TenantsMutation) ResetSort() {
	m.sort = nil
}

// SetEnabled sets the "enabled" field.
func (m *TenantsMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *TenantsMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *TenantsMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[tenants.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *TenantsMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[tenants.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *TenantsMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, tenants.FieldEnabled)
}

// SetDeleteFlag sets the "delete_flag" field.
func (m *TenantsMutation) SetDeleteFlag(s string) {
	m.delete_flag = &s
}

// DeleteFlag returns the value of the "delete_flag" field in the mutation.
func (m *TenantsMutation) DeleteFlag() (r string, exists bool) {
	v := m.delete_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteFlag returns the old "delete_flag" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldDeleteFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteFlag: %w", err)
	}
	return oldValue.DeleteFlag, nil
}

// ResetDeleteFlag resets all changes to the "delete_flag" field.
func (m *TenantsMutation) ResetDeleteFlag() {
	m.delete_flag = nil
}

// SetIsystem sets the "isystem" field.
func (m *TenantsMutation) SetIsystem(b bool) {
	m.isystem = &b
}

// Isystem returns the value of the "isystem" field in the mutation.
func (m *TenantsMutation) Isystem() (r bool, exists bool) {
	v := m.isystem
	if v == nil {
		return
	}
	return *v, true
}

// OldIsystem returns the old "isystem" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldIsystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsystem: %w", err)
	}
	return oldValue.Isystem, nil
}

// ResetIsystem resets all changes to the "isystem" field.
func (m *TenantsMutation) ResetIsystem() {
	m.isystem = nil
}

// SetTaxRate sets the "tax_rate" field.
func (m *TenantsMutation) SetTaxRate(s schema.Decimal) {
	m.tax_rate = &s
}

// TaxRate returns the value of the "tax_rate" field in the mutation.
func (m *TenantsMutation) TaxRate() (r schema.Decimal, exists bool) {
	v := m.tax_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxRate returns the old "tax_rate" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldTaxRate(ctx context.Context) (v schema.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxRate: %w", err)
	}
	return oldValue.TaxRate, nil
}

// ResetTaxRate resets all changes to the "tax_rate" field.
func (m *TenantsMutation) ResetTaxRate() {
	m.tax_rate = nil
}

// SetAdvanceIn sets the "advance_in" field.
func (m *TenantsMutation) SetAdvanceIn(s schema.Decimal) {
	m.advance_in = &s
}

// AdvanceIn returns the value of the "advance_in" field in the mutation.
func (m *TenantsMutation) AdvanceIn() (r schema.Decimal, exists bool) {
	v := m.advance_in
	if v == nil {
		return
	}
	return *v, true
}

// OldAdvanceIn returns the old "advance_in" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldAdvanceIn(ctx context.Context) (v schema.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdvanceIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdvanceIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdvanceIn: %w", err)
	}
	return oldValue.AdvanceIn, nil
}

// ResetAdvanceIn resets all changes to the "advance_in" field.
func (m *TenantsMutation) ResetAdvanceIn() {
	m.advance_in = nil
}

// SetBeginNeedGet sets the "begin_need_get" field.
func (m *TenantsMutation) SetBeginNeedGet(s schema.Decimal) {
	m.begin_need_get = &s
}

// BeginNeedGet returns the value of the "begin_need_get" field in the mutation.
func (m *TenantsMutation) BeginNeedGet() (r schema.Decimal, exists bool) {
	v := m.begin_need_get
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginNeedGet returns the old "begin_need_get" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldBeginNeedGet(ctx context.Context) (v schema.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginNeedGet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginNeedGet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginNeedGet: %w", err)
	}
	return oldValue.BeginNeedGet, nil
}

// ResetBeginNeedGet resets all changes to the "begin_need_get" field.
func (m *TenantsMutation) ResetBeginNeedGet() {
	m.begin_need_get = nil
}

// SetBeginNeedPay sets the "begin_need_pay" field.
func (m *TenantsMutation) SetBeginNeedPay(s schema.Decimal) {
	m.begin_need_pay = &s
}

// BeginNeedPay returns the value of the "begin_need_pay" field in the mutation.
func (m *TenantsMutation) BeginNeedPay() (r schema.Decimal, exists bool) {
	v := m.begin_need_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginNeedPay returns the old "begin_need_pay" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldBeginNeedPay(ctx context.Context) (v schema.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginNeedPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginNeedPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginNeedPay: %w", err)
	}
	return oldValue.BeginNeedPay, nil
}

// ResetBeginNeedPay resets all changes to the "begin_need_pay" field.
func (m *TenantsMutation) ResetBeginNeedPay() {
	m.begin_need_pay = nil
}

// SetAllNeedGet sets the "all_need_get" field.
func (m *TenantsMutation) SetAllNeedGet(s schema.Decimal) {
	m.all_need_get = &s
}

// AllNeedGet returns the value of the "all_need_get" field in the mutation.
func (m *TenantsMutation) AllNeedGet() (r schema.Decimal, exists bool) {
	v := m.all_need_get
	if v == nil {
		return
	}
	return *v, true
}

// OldAllNeedGet returns the old "all_need_get" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldAllNeedGet(ctx context.Context) (v schema.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllNeedGet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllNeedGet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllNeedGet: %w", err)
	}
	return oldValue.AllNeedGet, nil
}

// ResetAllNeedGet resets all changes to the "all_need_get" field.
func (m *TenantsMutation) ResetAllNeedGet() {
	m.all_need_get = nil
}

// SetAllNeedPay sets the "all_need_pay" field.
func (m *TenantsMutation) SetAllNeedPay(s schema.Decimal) {
	m.all_need_pay = &s
}

// AllNeedPay returns the value of the "all_need_pay" field in the mutation.
func (m *TenantsMutation) AllNeedPay() (r schema.Decimal, exists bool) {
	v := m.all_need_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldAllNeedPay returns the old "all_need_pay" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldAllNeedPay(ctx context.Context) (v schema.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllNeedPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllNeedPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllNeedPay: %w", err)
	}
	return oldValue.AllNeedPay, nil
}

// ResetAllNeedPay resets all changes to the "all_need_pay" field.
func (m *TenantsMutation) ResetAllNeedPay() {
	m.all_need_pay = nil
}

// SetCreator sets the "creator" field.
func (m *TenantsMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *TenantsMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *TenantsMutation) ResetCreator() {
	m.creator = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *TenantsMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *TenantsMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldCreatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ClearCreatedTime clears the value of the "created_time" field.
func (m *TenantsMutation) ClearCreatedTime() {
	m.created_time = nil
	m.clearedFields[tenants.FieldCreatedTime] = struct{}{}
}

// CreatedTimeCleared returns if the "created_time" field was cleared in this mutation.
func (m *TenantsMutation) CreatedTimeCleared() bool {
	_, ok := m.clearedFields[tenants.FieldCreatedTime]
	return ok
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *TenantsMutation) ResetCreatedTime() {
	m.created_time = nil
	delete(m.clearedFields, tenants.FieldCreatedTime)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *TenantsMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *TenantsMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Tenants entity.
// If the Tenants object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantsMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *TenantsMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[tenants.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *TenantsMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[tenants.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *TenantsMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, tenants.FieldUpdatedTime)
}

// Where appends a list predicates to the TenantsMutation builder.
func (m *TenantsMutation) Where(ps ...predicate.Tenants) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenants, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenants).
func (m *TenantsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantsMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.supplier != nil {
		fields = append(fields, tenants.FieldSupplier)
	}
	if m.tenant_id != nil {
		fields = append(fields, tenants.FieldTenantID)
	}
	if m.contacts != nil {
		fields = append(fields, tenants.FieldContacts)
	}
	if m.email != nil {
		fields = append(fields, tenants.FieldEmail)
	}
	if m.description != nil {
		fields = append(fields, tenants.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, tenants.FieldType)
	}
	if m.province != nil {
		fields = append(fields, tenants.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, tenants.FieldCity)
	}
	if m.area != nil {
		fields = append(fields, tenants.FieldArea)
	}
	if m.street != nil {
		fields = append(fields, tenants.FieldStreet)
	}
	if m.address != nil {
		fields = append(fields, tenants.FieldAddress)
	}
	if m.addr_code != nil {
		fields = append(fields, tenants.FieldAddrCode)
	}
	if m.fax != nil {
		fields = append(fields, tenants.FieldFax)
	}
	if m.phone_num != nil {
		fields = append(fields, tenants.FieldPhoneNum)
	}
	if m.telephone != nil {
		fields = append(fields, tenants.FieldTelephone)
	}
	if m.tax_num != nil {
		fields = append(fields, tenants.FieldTaxNum)
	}
	if m.bank_name != nil {
		fields = append(fields, tenants.FieldBankName)
	}
	if m.account_number != nil {
		fields = append(fields, tenants.FieldAccountNumber)
	}
	if m.sort != nil {
		fields = append(fields, tenants.FieldSort)
	}
	if m.enabled != nil {
		fields = append(fields, tenants.FieldEnabled)
	}
	if m.delete_flag != nil {
		fields = append(fields, tenants.FieldDeleteFlag)
	}
	if m.isystem != nil {
		fields = append(fields, tenants.FieldIsystem)
	}
	if m.tax_rate != nil {
		fields = append(fields, tenants.FieldTaxRate)
	}
	if m.advance_in != nil {
		fields = append(fields, tenants.FieldAdvanceIn)
	}
	if m.begin_need_get != nil {
		fields = append(fields, tenants.FieldBeginNeedGet)
	}
	if m.begin_need_pay != nil {
		fields = append(fields, tenants.FieldBeginNeedPay)
	}
	if m.all_need_get != nil {
		fields = append(fields, tenants.FieldAllNeedGet)
	}
	if m.all_need_pay != nil {
		fields = append(fields, tenants.FieldAllNeedPay)
	}
	if m.creator != nil {
		fields = append(fields, tenants.FieldCreator)
	}
	if m.created_time != nil {
		fields = append(fields, tenants.FieldCreatedTime)
	}
	if m.updated_time != nil {
		fields = append(fields, tenants.FieldUpdatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenants.FieldSupplier:
		return m.Supplier()
	case tenants.FieldTenantID:
		return m.TenantID()
	case tenants.FieldContacts:
		return m.Contacts()
	case tenants.FieldEmail:
		return m.Email()
	case tenants.FieldDescription:
		return m.Description()
	case tenants.FieldType:
		return m.GetType()
	case tenants.FieldProvince:
		return m.Province()
	case tenants.FieldCity:
		return m.City()
	case tenants.FieldArea:
		return m.Area()
	case tenants.FieldStreet:
		return m.Street()
	case tenants.FieldAddress:
		return m.Address()
	case tenants.FieldAddrCode:
		return m.AddrCode()
	case tenants.FieldFax:
		return m.Fax()
	case tenants.FieldPhoneNum:
		return m.PhoneNum()
	case tenants.FieldTelephone:
		return m.Telephone()
	case tenants.FieldTaxNum:
		return m.TaxNum()
	case tenants.FieldBankName:
		return m.BankName()
	case tenants.FieldAccountNumber:
		return m.AccountNumber()
	case tenants.FieldSort:
		return m.Sort()
	case tenants.FieldEnabled:
		return m.Enabled()
	case tenants.FieldDeleteFlag:
		return m.DeleteFlag()
	case tenants.FieldIsystem:
		return m.Isystem()
	case tenants.FieldTaxRate:
		return m.TaxRate()
	case tenants.FieldAdvanceIn:
		return m.AdvanceIn()
	case tenants.FieldBeginNeedGet:
		return m.BeginNeedGet()
	case tenants.FieldBeginNeedPay:
		return m.BeginNeedPay()
	case tenants.FieldAllNeedGet:
		return m.AllNeedGet()
	case tenants.FieldAllNeedPay:
		return m.AllNeedPay()
	case tenants.FieldCreator:
		return m.Creator()
	case tenants.FieldCreatedTime:
		return m.CreatedTime()
	case tenants.FieldUpdatedTime:
		return m.UpdatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenants.FieldSupplier:
		return m.OldSupplier(ctx)
	case tenants.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenants.FieldContacts:
		return m.OldContacts(ctx)
	case tenants.FieldEmail:
		return m.OldEmail(ctx)
	case tenants.FieldDescription:
		return m.OldDescription(ctx)
	case tenants.FieldType:
		return m.OldType(ctx)
	case tenants.FieldProvince:
		return m.OldProvince(ctx)
	case tenants.FieldCity:
		return m.OldCity(ctx)
	case tenants.FieldArea:
		return m.OldArea(ctx)
	case tenants.FieldStreet:
		return m.OldStreet(ctx)
	case tenants.FieldAddress:
		return m.OldAddress(ctx)
	case tenants.FieldAddrCode:
		return m.OldAddrCode(ctx)
	case tenants.FieldFax:
		return m.OldFax(ctx)
	case tenants.FieldPhoneNum:
		return m.OldPhoneNum(ctx)
	case tenants.FieldTelephone:
		return m.OldTelephone(ctx)
	case tenants.FieldTaxNum:
		return m.OldTaxNum(ctx)
	case tenants.FieldBankName:
		return m.OldBankName(ctx)
	case tenants.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case tenants.FieldSort:
		return m.OldSort(ctx)
	case tenants.FieldEnabled:
		return m.OldEnabled(ctx)
	case tenants.FieldDeleteFlag:
		return m.OldDeleteFlag(ctx)
	case tenants.FieldIsystem:
		return m.OldIsystem(ctx)
	case tenants.FieldTaxRate:
		return m.OldTaxRate(ctx)
	case tenants.FieldAdvanceIn:
		return m.OldAdvanceIn(ctx)
	case tenants.FieldBeginNeedGet:
		return m.OldBeginNeedGet(ctx)
	case tenants.FieldBeginNeedPay:
		return m.OldBeginNeedPay(ctx)
	case tenants.FieldAllNeedGet:
		return m.OldAllNeedGet(ctx)
	case tenants.FieldAllNeedPay:
		return m.OldAllNeedPay(ctx)
	case tenants.FieldCreator:
		return m.OldCreator(ctx)
	case tenants.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case tenants.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Tenants field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenants.FieldSupplier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplier(v)
		return nil
	case tenants.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenants.FieldContacts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContacts(v)
		return nil
	case tenants.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case tenants.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenants.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tenants.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case tenants.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case tenants.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case tenants.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case tenants.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tenants.FieldAddrCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrCode(v)
		return nil
	case tenants.FieldFax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFax(v)
		return nil
	case tenants.FieldPhoneNum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNum(v)
		return nil
	case tenants.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case tenants.FieldTaxNum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNum(v)
		return nil
	case tenants.FieldBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case tenants.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case tenants.FieldSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case tenants.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case tenants.FieldDeleteFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteFlag(v)
		return nil
	case tenants.FieldIsystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsystem(v)
		return nil
	case tenants.FieldTaxRate:
		v, ok := value.(schema.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxRate(v)
		return nil
	case tenants.FieldAdvanceIn:
		v, ok := value.(schema.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdvanceIn(v)
		return nil
	case tenants.FieldBeginNeedGet:
		v, ok := value.(schema.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginNeedGet(v)
		return nil
	case tenants.FieldBeginNeedPay:
		v, ok := value.(schema.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginNeedPay(v)
		return nil
	case tenants.FieldAllNeedGet:
		v, ok := value.(schema.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllNeedGet(v)
		return nil
	case tenants.FieldAllNeedPay:
		v, ok := value.(schema.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllNeedPay(v)
		return nil
	case tenants.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case tenants.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case tenants.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Tenants field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenants numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenants.FieldEnabled) {
		fields = append(fields, tenants.FieldEnabled)
	}
	if m.FieldCleared(tenants.FieldCreatedTime) {
		fields = append(fields, tenants.FieldCreatedTime)
	}
	if m.FieldCleared(tenants.FieldUpdatedTime) {
		fields = append(fields, tenants.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantsMutation) ClearField(name string) error {
	switch name {
	case tenants.FieldEnabled:
		m.ClearEnabled()
		return nil
	case tenants.FieldCreatedTime:
		m.ClearCreatedTime()
		return nil
	case tenants.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Tenants nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantsMutation) ResetField(name string) error {
	switch name {
	case tenants.FieldSupplier:
		m.ResetSupplier()
		return nil
	case tenants.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenants.FieldContacts:
		m.ResetContacts()
		return nil
	case tenants.FieldEmail:
		m.ResetEmail()
		return nil
	case tenants.FieldDescription:
		m.ResetDescription()
		return nil
	case tenants.FieldType:
		m.ResetType()
		return nil
	case tenants.FieldProvince:
		m.ResetProvince()
		return nil
	case tenants.FieldCity:
		m.ResetCity()
		return nil
	case tenants.FieldArea:
		m.ResetArea()
		return nil
	case tenants.FieldStreet:
		m.ResetStreet()
		return nil
	case tenants.FieldAddress:
		m.ResetAddress()
		return nil
	case tenants.FieldAddrCode:
		m.ResetAddrCode()
		return nil
	case tenants.FieldFax:
		m.ResetFax()
		return nil
	case tenants.FieldPhoneNum:
		m.ResetPhoneNum()
		return nil
	case tenants.FieldTelephone:
		m.ResetTelephone()
		return nil
	case tenants.FieldTaxNum:
		m.ResetTaxNum()
		return nil
	case tenants.FieldBankName:
		m.ResetBankName()
		return nil
	case tenants.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case tenants.FieldSort:
		m.ResetSort()
		return nil
	case tenants.FieldEnabled:
		m.ResetEnabled()
		return nil
	case tenants.FieldDeleteFlag:
		m.ResetDeleteFlag()
		return nil
	case tenants.FieldIsystem:
		m.ResetIsystem()
		return nil
	case tenants.FieldTaxRate:
		m.ResetTaxRate()
		return nil
	case tenants.FieldAdvanceIn:
		m.ResetAdvanceIn()
		return nil
	case tenants.FieldBeginNeedGet:
		m.ResetBeginNeedGet()
		return nil
	case tenants.FieldBeginNeedPay:
		m.ResetBeginNeedPay()
		return nil
	case tenants.FieldAllNeedGet:
		m.ResetAllNeedGet()
		return nil
	case tenants.FieldAllNeedPay:
		m.ResetAllNeedPay()
		return nil
	case tenants.FieldCreator:
		m.ResetCreator()
		return nil
	case tenants.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case tenants.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Tenants field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenants unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenants edge %s", name)
}
