// Code generated by ent, DO NOT EDIT.

package genclients

import (
	"fmcam/systems/genclients/capturelogs"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// CaptureLogs is the model entity for the CaptureLogs schema.
type CaptureLogs struct {
	config `db:"-" json:"-"`
	// ID of the ent.
	ID int64 `json:"id" db:"id"`
	// 租户号
	TenantID uuid.UUID `json:"tenant_id"  db:"tenant_id"`
	// 设备 ID
	DeviceID int64 `json:"device_id" db:"device_id"`
	// 比中人员ID
	MatchedProfileID int64 `json:"matched_profile_id" db:"matched_profile_id"`
	// 是否抓拍
	FuncType int8 `json:"func_type" db:"func_type"`
	// 比对得分
	MatchScore float32 `json:"match_score" db:"match_score"`
	// 触发预警
	HasAlert bool `json:"has_alert" db:"has_alert"`
	// 设备名称
	DeviceName *string `json:"device_name"  db:"device_name"`
	// 设备位置
	DeviceLocation *string `json:"device_location"  db:"device_location"`
	// 抓拍记录内容
	Content *string `json:"content"  db:"content"`
	// 抓拍的图片地址
	CaptureImageURL string `json:"capture_image_url"  db:"capture_image_url"`
	// 抓拍时间
	CaptureTime  *time.Time `json:"capture_time" db:"capture_time"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*CaptureLogs) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case capturelogs.FieldHasAlert:
			values[i] = new(sql.NullBool)
		case capturelogs.FieldMatchScore:
			values[i] = new(sql.NullFloat64)
		case capturelogs.FieldID, capturelogs.FieldDeviceID, capturelogs.FieldMatchedProfileID, capturelogs.FieldFuncType:
			values[i] = new(sql.NullInt64)
		case capturelogs.FieldDeviceName, capturelogs.FieldDeviceLocation, capturelogs.FieldContent, capturelogs.FieldCaptureImageURL:
			values[i] = new(sql.NullString)
		case capturelogs.FieldCaptureTime:
			values[i] = new(sql.NullTime)
		case capturelogs.FieldTenantID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the CaptureLogs fields.
func (cl *CaptureLogs) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case capturelogs.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			cl.ID = int64(value.Int64)
		case capturelogs.FieldTenantID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value != nil {
				cl.TenantID = *value
			}
		case capturelogs.FieldDeviceID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field device_id", values[i])
			} else if value.Valid {
				cl.DeviceID = value.Int64
			}
		case capturelogs.FieldMatchedProfileID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field matched_profile_id", values[i])
			} else if value.Valid {
				cl.MatchedProfileID = value.Int64
			}
		case capturelogs.FieldFuncType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field func_type", values[i])
			} else if value.Valid {
				cl.FuncType = int8(value.Int64)
			}
		case capturelogs.FieldMatchScore:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field match_score", values[i])
			} else if value.Valid {
				cl.MatchScore = float32(value.Float64)
			}
		case capturelogs.FieldHasAlert:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field has_alert", values[i])
			} else if value.Valid {
				cl.HasAlert = value.Bool
			}
		case capturelogs.FieldDeviceName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field device_name", values[i])
			} else if value.Valid {
				cl.DeviceName = new(string)
				*cl.DeviceName = value.String
			}
		case capturelogs.FieldDeviceLocation:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field device_location", values[i])
			} else if value.Valid {
				cl.DeviceLocation = new(string)
				*cl.DeviceLocation = value.String
			}
		case capturelogs.FieldContent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field content", values[i])
			} else if value.Valid {
				cl.Content = new(string)
				*cl.Content = value.String
			}
		case capturelogs.FieldCaptureImageURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field capture_image_url", values[i])
			} else if value.Valid {
				cl.CaptureImageURL = value.String
			}
		case capturelogs.FieldCaptureTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field capture_time", values[i])
			} else if value.Valid {
				cl.CaptureTime = new(time.Time)
				*cl.CaptureTime = value.Time
			}
		default:
			cl.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the CaptureLogs.
// This includes values selected through modifiers, order, etc.
func (cl *CaptureLogs) Value(name string) (ent.Value, error) {
	return cl.selectValues.Get(name)
}

// Update returns a builder for updating this CaptureLogs.
// Note that you need to call CaptureLogs.Unwrap() before calling this method if this CaptureLogs
// was returned from a transaction, and the transaction was committed or rolled back.
func (cl *CaptureLogs) Update() *CaptureLogsUpdateOne {
	return NewCaptureLogsClient(cl.config).UpdateOne(cl)
}

// Unwrap unwraps the CaptureLogs entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (cl *CaptureLogs) Unwrap() *CaptureLogs {
	_tx, ok := cl.config.driver.(*txDriver)
	if !ok {
		panic("genclients: CaptureLogs is not a transactional entity")
	}
	cl.config.driver = _tx.drv
	return cl
}

// String implements the fmt.Stringer.
func (cl *CaptureLogs) String() string {
	var builder strings.Builder
	builder.WriteString("CaptureLogs(")
	builder.WriteString(fmt.Sprintf("id=%v, ", cl.ID))
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", cl.TenantID))
	builder.WriteString(", ")
	builder.WriteString("device_id=")
	builder.WriteString(fmt.Sprintf("%v", cl.DeviceID))
	builder.WriteString(", ")
	builder.WriteString("matched_profile_id=")
	builder.WriteString(fmt.Sprintf("%v", cl.MatchedProfileID))
	builder.WriteString(", ")
	builder.WriteString("func_type=")
	builder.WriteString(fmt.Sprintf("%v", cl.FuncType))
	builder.WriteString(", ")
	builder.WriteString("match_score=")
	builder.WriteString(fmt.Sprintf("%v", cl.MatchScore))
	builder.WriteString(", ")
	builder.WriteString("has_alert=")
	builder.WriteString(fmt.Sprintf("%v", cl.HasAlert))
	builder.WriteString(", ")
	if v := cl.DeviceName; v != nil {
		builder.WriteString("device_name=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := cl.DeviceLocation; v != nil {
		builder.WriteString("device_location=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := cl.Content; v != nil {
		builder.WriteString("content=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("capture_image_url=")
	builder.WriteString(cl.CaptureImageURL)
	builder.WriteString(", ")
	if v := cl.CaptureTime; v != nil {
		builder.WriteString("capture_time=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// CaptureLogsSlice is a parsable slice of CaptureLogs.
type CaptureLogsSlice []*CaptureLogs
